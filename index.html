<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>ATC Radar Trainer — v5.1</title>
<style>
  :root{
  /* Near-black scope */
  --bg:#060707;
  --grid:#0c0c0c;         /* very faint grid (optional) */
  --ring:#141414;         /* very faint rings (optional) */

  /* UI text + panel remain readable */
  --text:#e8eef2;
  --accent:#8fd3ff;
  --panel:#0d1115;

  /* not used for labels anymore, but keep */
  --tag:#0d2230; --tagBorder:#1b3a4f;
  --sel:#9bf6a9; --warn:#ffcc66; --alert:#ff6a6a;
  --muted:#9fb3c1; --magenta:#ff7bff;

  /* leader/rect colors no longer blue; vectors & leaders will be white in JS */
  --leader:#ffffff; --rect:#3a3a3a;
}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:var(--bg); color:var(--text);
    font:15px/1.35 ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Courier New",monospace;
    display:grid; grid-template-columns:1fr 380px; grid-template-rows:56px 1fr;
    grid-template-areas:"top top" "radar panel";
    overflow:hidden auto;
  }
  header{grid-area:top; display:flex; align-items:center; gap:12px;
    padding:10px 14px; background:linear-gradient(180deg,#0d1921,#0a1117);
    border-bottom:1px solid #162737}
  header h1{margin:0; font-size:16px; font-weight:600; letter-spacing:.5px; color:var(--accent)}
  header .controls{display:flex; gap:8px; flex-wrap:wrap; margin-left:auto}
  button,input,select{background:#0d1a22; border:1px solid #1b3243; color:var(--text); padding:8px 10px; border-radius:8px; outline:none}
  button:hover{border-color:#24516e; cursor:pointer}
  input[type="number"],input[type="text"]{width:110px}
  #radarWrap{grid-area:radar; position:relative}
  canvas{display:block; width:100%; height:100%}
  aside{grid-area:panel; border-left:1px solid #162737; background:var(--panel); padding:12px; overflow:auto}
  .section{margin-bottom:14px; padding-bottom:12px; border-bottom:1px dashed #173243}
  .row{display:flex; gap:8px; align-items:center; margin:6px 0; flex-wrap:wrap}
  label{font-size:12px; color:var(--muted); min-width:86px}
  .small{font-size:12px; color:var(--muted)}
  .aircraftCard{border:1px solid #193246; background:#0b1620; border-radius:10px; padding:10px; margin:8px 0}
  .aircraftCard.selected{border-color:var(--sel)}
  .grid2{display:grid; grid-template-columns:1fr 1fr; gap:8px}
  .kbd{padding:2px 6px; border:1px solid #274b64; border-radius:6px; background:#0c1b25}

/* ===== Track labels (text only; no box) ===== */
.tag{
  position:absolute;
  background:transparent;        /* no box */
  border:none;                   /* no border */
  padding:0;                     /* tight */
  filter:none;
  touch-action:none; user-select:none; cursor:grab;
  opacity:1;                     /* solid text */
}
.tag:hover,.tag.dragging{opacity:1}

/* simple type ramp */
.tag .l1{ font-weight:700; font-size:14px; line-height:1.05 }
.tag .l2{ font-size:12px; line-height:1.05; letter-spacing:.2px }

/* state-driven colors */
.tag.st-controlled { color:#69ff8a; }     /* green */
.tag.st-inbound    { color:#ffffff; }     /* white */
.tag.st-intruder   { color:#ffd9b3; }     /* very light orange */
.tag.st-outbound   { color:#9aa3aa; }     /* greyed out */

/* tiny inline button to mark handoff (optional) */
.tag .ho{
  display:inline-block; margin-left:8px; padding:1px 6px;
  font-size:10px; border:1px solid currentColor; border-radius:999px;
}
  .tag:hover,.tag.dragging{opacity:1}
  .tag .line1{font-weight:600}
  .tag .line2{font-size:12px; color:var(--muted)}
  .tag.alert{border-color:var(--alert)}
  .tag.warn{border-color:var(--warn)}
  .pill{padding:2px 6px; border:1px solid #2c4a5f; border-radius:999px; background:#0c1b25; font-size:11px; color:var(--muted)}
  .waypointLabel{position:absolute; background:transparent; border:0px solid #2c4a5f; border-radius:6px; padding:0px 6px; font-size:11px; color:#cde; opacity:.85}
  /* --- SFP floating window --- */
.sfpWin{
  position:absolute; right:12px; top:64px; width:260px;
  background:#0b1620; border:1px solid #1b3a4f; border-radius:10px;
  box-shadow:0 6px 18px rgba(0,0,0,.35); z-index:20; user-select:none;
}
.sfpWin .hdr{
  display:flex; align-items:center; justify-content:space-between;
  padding:8px 10px; border-bottom:1px solid #173243; color:#9fb3c1; font-size:12px;
  background:linear-gradient(180deg,#0e1820,#0b141a);
  border-top-left-radius:10px; border-top-right-radius:10px;
}
.sfpWin .hdr .title{ font-weight:600; color:#cfe8f7; font-size:12px; letter-spacing:.3px }
.sfpWin .hdr button{
  background:#0d1a22; border:1px solid #274b64; color:#cfe8f7; padding:4px 8px; border-radius:6px; cursor:pointer;
}
.sfpWin .body{ padding:10px }
.sfpWin table{ width:100%; border-collapse:collapse; font-size:12px; color:#cfe8f7 }
.sfpWin td{ padding:4px 0; vertical-align:top }
.sfpWin td.key{ color:#9fb3c1; width:88px }
.sfpWin .route{ margin-top:8px; font-size:12px; color:#9ad6ff; line-height:1.35 }

</style>
</head>
<body>
<header>
  <h1>ATC Radar Trainer — v5.1</h1>
  <div class="controls">
    <button id="spawn">Spawn traffic</button>
    <label class="small">
  <input id="autoSpawnToggle" type="checkbox"> Auto-spawn
</label>
<button id="spawnConflict">Spawn conflict</button>

    <button id="clear">Clear all</button>
    <button id="pause">Pause</button>
    <label class="small">Range (NM)
      <select id="rangeSel"><option>20</option><option selected>40</option><option>60</option><option>80</option><option>120</option></select>
    </label>
    <label class="small">Sim speed
      <select id="simSpeed"><option value="0.5">0.5×</option><option value="1" selected>1×</option><option value="2">2×</option><option value="4">4×</option></select>
    </label>
  </div>
</header>

<div id="radarWrap">
  <canvas id="radar"></canvas>
</div>

<aside>
  <div class="section">
    <div class="row"><strong>Selected track</strong></div>
    <div id="selectedInfo" class="aircraftCard small">Tap/click a tag to select; drag tags anywhere (works on mobile).</div>
  </div>

  <div class="section">
    <div class="row"><strong>Vectors</strong></div>
    <div class="row">
      <label for="hdg">Heading</label>
      <input id="hdg" type="number" min="1" max="360" placeholder="1–360">
      <button id="btnHdg">Issue vector</button>
    </div>
    <div class="row small">Standard-rate ≈3°/s, shortest way. (Displays 360, not 000.)</div>
  </div>

  <div class="section">
    <div class="row"><strong>Altitude</strong></div>
    <div class="row">
      <label for="alt">Altitude</label>
      <input id="alt" type="number" step="1" min="0" placeholder="e.g. 150">
      <button id="btnAlt">Climb/Descent</button>
    </div>
    <div class="row">
      <label for="vs">Vertical speed</label>
      <input id="vs" type="number" step="100" placeholder="fpm (default 1800)">
      <button id="btnHold">Altitude hold</button>
    </div>
    <div class="row small">
      <label><input id="useFL" type="checkbox" checked> Enter Flight Level (e.g., <b>150</b> for FL150)</label>
      <span id="altModeHint" class="small"></span>
    </div>
  </div>

  <div class="section">
    <div class="row"><strong>Speed</strong></div>
    <div class="row">
      <label for="spd">Speed (kt)</label>
      <input id="spd" type="number" step="5" min="60" placeholder="e.g. 250">
      <button id="btnSpd">Set kt</button>
    </div>
    <div class="row">
      <label for="mach">Mach</label>
      <input id="mach" type="number" step="0.01" min="0.30" max="0.99" placeholder="e.g. 0.78">
      <button id="btnMach">Set M</button>
    </div>
    <div class="row small">Mach converts using ISA a(alt).</div>
  </div>

  <div class="section">
    <div class="row"><strong>Predict vectors</strong></div>
    <div class="row small">
      <label><input type="checkbox" id="pred1" checked> 1 min</label>
      <label><input type="checkbox" id="pred3" checked> 3 min</label>
      <label><input type="checkbox" id="pred5" checked> 5 min</label>
      <label style="margin-left:auto;">Show for
        <select id="predFor"><option value="sel">selected</option><option value="all" selected>all tracks</option></select>
      </label>
    </div>
    <div class="row small">Solid lines only; no labels on scope.</div>
  </div>

  <div class="section">
    <div class="row"><strong>Conflict alerts</strong></div>
    <div class="row small">Minima: <span class="pill">5 NM</span> / <span class="pill">1000 ft</span></div>
    <div class="row">
      <label for="lookahead">Lookahead</label>
      <select id="lookahead"><option value="0">0 min (current)</option><option value="1">1 min</option><option value="2" selected>2 min</option><option value="3">3 min</option></select>
    </div>
    <div class="row small">Red = actual, Amber = predicted within lookahead.</div>
  </div>

  <!-- NEW: Measure tool controls -->
  <div class="section">
    <div class="row"><strong>Measure tool</strong></div>
    <div class="row">
      <button id="clearRulers">Clear rulers</button>
    </div>
    <div class="row small">Shift+LMB = start/finish (snaps to nearest a/c) •
Plain Left Click = place ruler •
Esc = delete last ruler</div>
  </div>

  <div class="section">
    <div class="row"><strong>Altitude filter</strong></div>
    <div class="row">
      <label for="fltMin">Min (ft)</label><input id="fltMin" type="number" step="100" value="0">
      <label for="fltMax">Max (ft)</label><input id="fltMax" type="number" step="100" value="60000">
      <button id="btnFilter">Apply</button>
    </div>
    <div class="row small">Off-band tracks dimmed.</div>
  </div>

  <div class="section">
    <div class="row"><strong>Speed restrictions</strong></div>
    <div class="row small">
      <label><input id="spd250" type="checkbox" checked> 250 kt at/under 10,000 ft</label>
    </div>
  </div>

  <div class="section">
    <div class="row"><strong>Waypoints & Direct-to</strong></div>
    <div class="row">
      <button id="addWpt">Add waypoint</button>
      <button id="clearWpt">Clear wpts</button>
    </div>
    <div id="wptList" class="small"></div>
  </div>

  <div class="section">
    <div class="row"><strong>Sector (rectangular)</strong></div>
    <div class="row small">Rect centered on scope. Handoff triggers when crossing the rectangle boundary.</div>
    <div class="row">
      <label for="rectW">Width (NM)</label><input id="rectW" type="number" value="80">
      <label for="rectH">Height (NM)</label><input id="rectH" type="number" value="60">
      <button id="btnRect">Apply</button>
    </div>
    <div class="row small">
      <label><input id="autoHandoff" type="checkbox" checked> Auto-handoff</label>
      <button id="btnHandoff">Handoff selected</button>
    </div>
  </div>

  <div class="section small">
    <div class="row"><strong>Shortcuts</strong></div>
    <div class="grid2">
      <div><span class="kbd">H</span> vector • <span class="kbd">A</span> altitude • <span class="kbd">S</span> speed • <span class="kbd">M</span> Mach</div>
      <div><span class="kbd">Space</span> pause • <span class="kbd">N</span> spawn • Click scope to add waypoint (when enabled)</div>
    </div>
  </div>
</aside>

<script>
  // ---------- Utilities ----------
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const toRad=d=>d*Math.PI/180; const toDeg=r=>r*180/Math.PI;
  const mod360=d=>(d%360+360)%360;
  const nmPerKtPerSec = 1/3600; const ftPerMinToFtPerSec = 1/60;

  function isaSpeedOfSoundKts(alt_ft){
    const h = Math.max(0, Math.min(86000, alt_ft)) * 0.3048;
    let T; if(h<=11000) T=288.15-0.0065*h; else if(h<=20000) T=216.65; else T=216.65+0.001*(h-20000);
    const a_ms = Math.sqrt(1.4*287.05287*T); return a_ms*1.943844;
  }
  function formatHeading(h){
    let n = Math.round(mod360(h));
    n = n===0 ? 360 : n;
    return String(n).padStart(3,'0');
  }
  function parseAltitudeInput(val, useFL){
    if(val===""||val==null) return null;
    let txt = String(val).trim().toUpperCase();
    if(useFL){
      if(txt.startsWith("FL")) txt = txt.slice(2);
      const fl = parseInt(txt,10);
      if(Number.isFinite(fl)) return fl*100;
      return null;
    }else{
      if(txt.startsWith("FL")){
        const fl=parseInt(txt.slice(2),10); return Number.isFinite(fl)? fl*100:null;
      }
      const ft = parseInt(txt,10); return Number.isFinite(ft)? ft:null;
    }
  }
  function bearingFromTo(x1,y1,x2,y2){
    return mod360(toDeg(Math.atan2(x2-x1, -(y2-y1))));
  }
  function nextWptName(a, env){
  if(a.navMode==="DIRECT" && a.directWptId) return env.getWaypoint(a.directWptId)?.name || "—";
  if(a.navMode==="ROUTE" && a.routeIdx < a.route.length) return env.getWaypoint(a.route[a.routeIdx])?.name || "—";
  return "—";
}
function fmtFLshort(ft){ return 'FL' + String(Math.round(ft/100)).padStart(3,'0'); }
function fmtCFL(ft){ return 'CFL' + String(Math.round(ft/100)).padStart(3,'0'); }
function fmtVS100(vs_fpm){
  const h = Math.round(vs_fpm/100);
  if (h===0) return "0";
  return (h>0?"+":"−") + Math.abs(h);
}
function getTrackState(a){
  if (a.inSector){
    return a.hoMarked ? "intruder" : "controlled";
  } else {
    return a.everInRect ? "outbound" : "inbound";
  }
}

  // --- Short Flight Plan (SFP) & helpers ---
const DEP_PORTS = ["EPWA","EPKT","EPPO"];   // tweak later
const ARR_PORTS = ["EDDF","EPWR","EPLL"];   // tweak later
const TYPES     = ["A320","B738","E190","B744","B789"];

const rand = (a,b)=> a + Math.random()*(b-a);
const randi = (a,b)=> Math.floor(rand(a,b+1));
const pick = arr => arr[Math.floor(Math.random()*arr.length)];

function makeSFP({dep=null, dest=null, cruiseFL=360, tasKt=450, type=null}={}){
  return {
    dep:  dep  ?? pick(DEP_PORTS),
    dest: dest ?? pick(ARR_PORTS),
    cruiseFL, tasKt, type: type ?? pick(TYPES)
  };
}
// Departures: usually inner fix → exit (rarely CTR → exit)
function buildDepartureRoute(fp){
  const exit = randomEdge(null);
  if (Math.random() < ROUTE_CFG.goViaCTRProb) return [WP.CTR.id, exit];

  // start near center: sometimes go via a non-CTR inner fix, sometimes straight out
  if (Math.random() < ROUTE_CFG.addMidProb) {
    const inner = pickInnerFixId();
    if (inner !== WP.CTR.id) return [inner, exit];
  }
  return [exit]; // straight to exit
}


// Simple arrival: entry → CTR (then you might handoff below/after CTR)
function buildArrivalRoute(fp){
  const entries = [WP.ENE.id, WP.ESE.id, WP.WNW.id, WP.WSW.id, WP.N01.id, WP.S01.id];
  const entry = entries[Math.floor(Math.random()*entries.length)];
  return [entry, WP.CTR.id];
}
// Transit: entry → (usually inner fix) → exit (not same as entry)
function buildTransitRoute(fp){
  const entry = randomEdge(null);
  if (Math.random() < ROUTE_CFG.goViaCTRProb) return [entry, WP.CTR.id];

  const inner = pickInnerFixId();
  const exit  = randomEdge(entry);
  if (inner !== WP.CTR.id) return [entry, inner, exit];
  return [entry, exit];
}


 function findNearestAcPx(xPx, yPx, tolPx=16){
  let best=null, bestD=Infinity;
  for(const a of state.ac){
    const ax = cx + nmToPx(a.x_nm);
    const ay = cy + nmToPx(a.y_nm);
    const d = Math.hypot(ax - xPx, ay - yPx);
    if(d < bestD){ bestD = d; best = a; }
  }
  return bestD <= tolPx ? best : null;
}

function resolveEndpoint(ep){
  if(!ep) return null;
  if(ep.type === 'ac'){
    const ac = state.ac.find(a=>a.id===ep.id);
    if(!ac) return null; // a/c may have been cleared
    return { x_nm: ac.x_nm, y_nm: ac.y_nm };
  }
  // point endpoint
  if('x_nm' in ep && 'y_nm' in ep) return { x_nm: ep.x_nm, y_nm: ep.y_nm };
  return null;
}


  // ---------- Aircraft ----------
  let nextId=1;
  function genCallsign(){
    const ops=["LOT","DLH","BAW","RYR","WZZ","KLM","AFR","AUA","SAS","UAE","QTR","IBE"];
    return ops[Math.floor(Math.random()*ops.length)]+String(Math.floor(100+Math.random()*899));
  }

  class Aircraft{
    constructor(opts){
      this.id=nextId++; this.cs=opts.cs||genCallsign();
      this.x_nm=opts.x_nm??0; this.y_nm=opts.y_nm??0;
      this.hdg=opts.hdg??Math.floor(Math.random()*360);
      this.alt_ft=opts.alt_ft??(30000);
      this.spd_kt=opts.spd_kt??(this.alt_ft>24000?450:250);
      this.fp = opts.fp ?? null;   // Short Flight Plan (dep, dest, cruiseFL, tasKt, type)
      this.route = [];         // array of waypoint ids
      this.routeIdx = 0;       // current active leg target index



      // Dotted trail: last 5 positions max
      this.trail=[]; this.trailMax=5;

      // Targets
      this.tgtHdg=this.hdg; this.tgtAlt=this.alt_ft;
      this.vs_fpm=0; this.defaultVS=1800;
      this.tgtSpeedMode="KT"; this.tgtSpd_kt=this.spd_kt; this.tgtMach=null;

      // Dynamics
      this.turnRateDps=3; this.accel_ktps=1.0; this.maxVS_fps=4000*ftPerMinToFtPerSec;

      // Nav
      this.navMode=null; this.directWptId=null;
          this.route = [];        // array of waypoint ids
    this.routeIdx = 0;      // which fix we’re heading to now


      // Label offsets
      this.labelDx=12; this.labelDy=-16;
      // Visibility/despawn bookkeeping
this.seenOnScreenOnce = false;
this.spawnSec = (typeof simNowSec !== 'undefined') ? simNowSec : 0;


      // Rect sector state
      this.inSector = true; this.handoffPending=false; this.pendingState=null; 
      // coloring / state bookkeeping
this.everInRect = env.inRect(this.x_nm, this.y_nm); // ever been inside?
this.hoMarked   = false;                             // we marked H/O manually

    }
    setHeading(h){ this.navMode=null; this.directWptId=null; this.tgtHdg=mod360(h); }
    setAltitude(alt_ft,vs=null){ this.tgtAlt=Math.max(0,Math.round(alt_ft));
      const sign=this.tgtAlt>this.alt_ft?1:-1; const mag=Math.max(0,Math.abs(vs??this.defaultVS)); this.vs_fpm=sign*mag; }
    holdAltitude(){ this.tgtAlt=this.alt_ft; this.vs_fpm=0; }
    setSpeedKt(kt){ this.tgtSpeedMode="KT"; this.tgtSpd_kt=Math.max(60,kt|0); this.tgtMach=null; }
    setMach(m){ this.tgtSpeedMode="MACH"; this.tgtMach=clamp(m,0.3,0.99); }
    directTo(id){ this.navMode="DIRECT"; this.directWptId=id; }
    get mach(){ return this.spd_kt/isaSpeedOfSoundKts(this.alt_ft); }
      setRoute(ids){
    this.route = Array.isArray(ids) ? ids.slice() : [];
    this.routeIdx = 0;
    this.navMode = this.route.length ? "ROUTE" : null;
    this.directWptId = null; // clear direct if switching
  }


    update(dt, env){
      if(this.tgtSpeedMode==="MACH" && this.tgtMach) this.tgtSpd_kt=this.tgtMach*isaSpeedOfSoundKts(this.alt_ft);
      let targetSpd=this.tgtSpd_kt;
      if(env.restrict250 && this.alt_ft<=10000) targetSpd=Math.min(targetSpd,250);

      if(this.navMode==="DIRECT" && this.directWptId!=null){
        const w = env.getWaypoint(this.directWptId);
        if(w){
          const hdgTo = mod360(toDeg(Math.atan2(w.x_nm-this.x_nm, -(w.y_nm-this.y_nm))));
          this.tgtHdg = hdgTo;
          const dist = Math.hypot(w.x_nm-this.x_nm, w.y_nm-this.y_nm);
          if(dist<0.5){ this.navMode=null; this.directWptId=null; }
        } else { this.navMode=null; this.directWptId=null; }
      }
       // ROUTE nav: fly fix to fix
    if(this.navMode==="ROUTE" && this.routeIdx < this.route.length){
      const curId = env.getWaypoint(this.route[this.routeIdx]);
      if(curId){
        const hdgTo = mod360(toDeg(Math.atan2(curId.x_nm-this.x_nm, -(curId.y_nm-this.y_nm))));
        this.tgtHdg = hdgTo;

        const dist = Math.hypot(curId.x_nm-this.x_nm, curId.y_nm-this.y_nm);
        if(dist < 0.8){ // within ~0.8 NM
          this.routeIdx++;
          if(this.routeIdx >= this.route.length){
            this.navMode = null; // route complete
          }
        }
      } else {
        this.navMode = null; // waypoint missing
      }
    }


      let diff = mod360(this.tgtHdg-this.hdg); if(diff>180) diff-=360;
      const maxTurn=this.turnRateDps*dt; if(Math.abs(diff)<maxTurn) this.hdg=this.tgtHdg; else this.hdg=mod360(this.hdg+Math.sign(diff)*maxTurn);

      const dSpd=targetSpd-this.spd_kt; const maxAcc=this.accel_ktps*dt;
      if(Math.abs(dSpd)<maxAcc) this.spd_kt=targetSpd; else this.spd_kt+=Math.sign(dSpd)*maxAcc;

      if(this.alt_ft!==this.tgtAlt){
        let vs_fps=this.vs_fpm*ftPerMinToFtPerSec; const delta=this.tgtAlt-this.alt_ft;
        if(Math.abs(delta)<600){ const s=Math.sign(delta); vs_fps=s*Math.min(Math.abs(vs_fps),800*ftPerMinToFtPerSec); }
        vs_fps=clamp(vs_fps,-this.maxVS_fps,this.maxVS_fps);
        const step=vs_fps*dt;
        if(Math.sign(delta)!==Math.sign(step)||Math.abs(step)>Math.abs(delta)){ this.alt_ft=this.tgtAlt; this.vs_fpm=0; }
        else this.alt_ft+=step;
      }

      const dist_nm=this.spd_kt*nmPerKtPerSec*dt;
      this.x_nm += Math.sin(toRad(this.hdg))*dist_nm;
      this.y_nm += -Math.cos(toRad(this.hdg))*dist_nm;

      // Sector (rectangle)
const inside = env.inRect(this.x_nm, this.y_nm);
if (inside) this.everInRect = true;

if (inside !== this.inSector) {
  const leftSector = this.inSector && !inside; // just crossed OUT
  if (env.autoHandoff) {
    this.inSector = inside;
    this.handoffPending = false;
    this.pendingState = null;
  } else {
    this.handoffPending = true;
    this.pendingState = inside;
  }
  if (leftSector) {
    // leaving sector: stop any nav guidance and keep current track
    this.navMode = null;
    this.directWptId = null;
    this.tgtHdg = this.hdg; // hold present heading
  }
}

      // Dotted trail (every step call adds one); keep only last 5
      this.trail.push({x:this.x_nm,y:this.y_nm});
      if(this.trail.length>this.trailMax) this.trail.shift();
    }
  }

 // ---------- World / Sim ----------
const canvas=document.getElementById('radar'); const ctx=canvas.getContext('2d');
const wrap=document.getElementById('radarWrap');
let W=0,H=0,cx=0,cy=0;
let booted = false;

function resize(){
  const r=wrap.getBoundingClientRect();
  canvas.width=r.width; canvas.height=r.height;
  W=canvas.width; H=canvas.height; cx=W/2; cy=H/2;
  if (booted) drawAll(); // only redraw after full boot
}
window.addEventListener('resize', resize);

  let rangeNM=40; function nmToPx(nm){ return nm*(Math.min(W,H)/2)/rangeNM; }
  function pxToNm(xPx,yPx){ return { x_nm:(xPx-cx)*rangeNM/(Math.min(W,H)/2), y_nm:(yPx-cy)*rangeNM/(Math.min(W,H)/2) }; }
  function isOnScreenPx(x_px, y_px, marginPx=24){
  return x_px >= -marginPx && x_px <= W + marginPx &&
         y_px >= -marginPx && y_px <= H + marginPx;
}
function acIsOnScreen(a, marginPx=24){
  const x = cx + nmToPx(a.x_nm);
  const y = cy + nmToPx(a.y_nm);
  return isOnScreenPx(x, y, marginPx);
}

function acInScopeNm(a, marginNm=0){
  // inside the circular scope radius + margin
  return Math.hypot(a.x_nm, a.y_nm) <= (rangeNM + marginNm);
}



  const env = {
    restrict250:true, autoHandoff:true,
    rectW:80, rectH:60,
    getWaypoint: id => getWPById(id),
    inRect: (x_nm,y_nm)=>Math.abs(x_nm)<=env.rectW/2 && Math.abs(y_nm)<=env.rectH/2
  };

  const state = {
    ac:[], selectedId:null, paused:false,
    simSpeed:1,
    filterMin:0, filterMax:60000,
    pred1:true, pred3:true, pred5:true, predFor:"all",
    lookaheadMin:2,
    conflictsNow:[], conflictsPred:[],
    addingWpt:false,
    refreshSec:3,
    measure:null,        // active ruler being drawn {fromX_nm,fromY_nm,toX_nm,toY_nm}
    measures:[]          // NEW: committed rulers dropped with RMB
  };
  function getSelected(){ return state.ac.find(a=>a.id===state.selectedId)||null; }
  // --- Sim clock (seconds) ---
let simNowSec = 0;


  // Waypoints
  let wptNext=1; const wpts=[];
  // ---- Random waypoint naming + min-spacing placement ----
const WPT_MIN_SPACING_NM = 15;     // tweak to taste
const WPT_TRIES_PER_POINT = 350;  // how hard we try per waypoint

function randWptName(){
  const vowels = "AEIOU";
  const cons   = "BCDFGHJKLMNPQRSTVWXYZ";
  // Make it feel "airway-ish": CVCVC or CVCCV with a dash of weirdness
  const pat = Math.random() < 0.5 ? "CVCVC" : "CVCCV";
  const pick = (s)=> s[Math.floor(Math.random()*s.length)];
  let out = "";
  for (const c of pat){
    out += (c==="C") ? pick(cons) : pick(vowels);
  }
  // ~15% chance to flip one letter to make it quirky
  if (Math.random() < 0.15){
    const i = Math.floor(Math.random()*out.length);
    const pool = Math.random()<0.5?vowels:cons;
    out = out.slice(0,i) + pick(pool) + out.slice(i+1);
  }
  return out;
}

function addWaypointNamedAt(name, x_nm, y_nm){
  const id = wptNext++;
  const w = { id, name, x_nm, y_nm };
  wpts.push(w);
  return w;
}

/** Place N random waypoints inside the current rectangular sector
 *  with at least WPT_MIN_SPACING_NM separation.
 */
function seedRandomWaypoints(count){
  const halfW = env.rectW/2, halfH = env.rectH/2;
  for (let k=0; k<count; k++){
    let placed = false;
    let tries = 0;
    let spacing = WPT_MIN_SPACING_NM;

    while(!placed && tries < WPT_TRIES_PER_POINT){
      tries++;
      const x = (Math.random()*2 - 1) * (halfW * 0.95);
      const y = (Math.random()*2 - 1) * (halfH * 0.95);

      // inside rect (belt-and-suspenders)
      if (!env.inRect(x,y)) continue;

      // distance check vs all existing waypoints
      let ok = true;
      for (const w of wpts){
        const d = Math.hypot(x - w.x_nm, y - w.y_nm);
        if (d < spacing){ ok = false; break; }
      }
      if (!ok) {
        // After many misses, ease spacing a bit so we don’t stall
        if (tries % 50 === 0) spacing *= 0.9;
        continue;
      }

      addWaypointNamedAt(randWptName(), x, y);
      placed = true;
    }
  }
  renderWptList();
  drawAll();
}

  function addWaypointAt(x_nm,y_nm){ const id=wptNext++; const w={id,name:"WPT"+id,x_nm,y_nm}; wpts.push(w); renderWptList(); drawAll(); }
  function clearWaypoints(){ wpts.length=0; renderWptList(); drawAll(); }
  function renderWptList(){
    const box=document.getElementById('wptList');
    if(wpts.length===0){ box.innerHTML='<div class="small">No waypoints.</div>'; return; }
    box.innerHTML=wpts.map(w=>`
      <div style="display:flex;align-items:center;gap:8px;margin:4px 0;">
        <span class="pill">${w.name}</span>
        <button data-w="${w.id}" class="btnDirect small">Direct-to</button>
      </div>`).join("");
    for(const btn of box.querySelectorAll('.btnDirect')){
      btn.addEventListener('click', e=>{
        const id=parseInt(e.target.getAttribute('data-w'),10);
        const sel=getSelected(); if(!sel){ alert("Select a track first."); return; }
        sel.directTo(id); updateSelectedPanel(); drawAll();
      });
    }
  }
  function fmtFL(flFt){ return 'FL' + String(Math.round(flFt/100)).padStart(3,'0'); }
function fmtTas(kt){ return (kt|0) + " kt"; }

function ensureSfpWin(){
  let el = document.querySelector('.sfpWin');
  if(el) return el;
  el = document.createElement('div');
  el.className = 'sfpWin';
  el.innerHTML = `
    <div class="hdr">
      <div class="title">Short Flight Plan</div>
      <div>
        <button class="btnSfpClose">Close</button>
      </div>
    </div>
    <div class="body"></div>
  `;
  document.getElementById('radarWrap').appendChild(el);
  el.querySelector('.btnSfpClose').addEventListener('click', closeSFP);
  return el;
}

function renderSFP(ac){
  const el = ensureSfpWin();
  const body = el.querySelector('.body');
  if(!ac || !ac.fp){
    body.innerHTML = `<div class="small" style="color:#9fb3c1">No SFP for this aircraft.</div>`;
    return;
  }
  const fp = ac.fp;
  const routeNames = (ac.route||[]).map(id => (env.getWaypoint(id)?.name || String(id)));
  body.innerHTML = `
    <table>
      <tr><td class="key">Callsign</td><td>${ac.cs}</td></tr>
      <tr><td class="key">Type</td><td>${fp.type || '—'}</td></tr>
      <tr><td class="key">From</td><td>${fp.dep || '—'}</td></tr>
      <tr><td class="key">To</td><td>${fp.dest || '—'}</td></tr>
      <tr><td class="key">Cruise</td><td>${fmtFL(fp.cruiseFL*100)}</td></tr>
      <tr><td class="key">TAS</td><td>${fmtTas(fp.tasKt||ac.spd_kt)}</td></tr>
    </table>
    <div class="route"><span style="color:#9fb3c1">Route:</span> ${
      routeNames.length ? routeNames.join(' → ') : '—'
    }</div>
  `;
  // keep it on-screen if window is small
  const r = el.getBoundingClientRect(), wrapR = document.getElementById('radarWrap').getBoundingClientRect();
  if(r.right > wrapR.right) el.style.right = '12px';
  if(r.top < wrapR.top) el.style.top = '64px';
}

function openSFP(ac){ renderSFP(ac); }
function closeSFP(){
  const el = document.querySelector('.sfpWin');
  if(el) el.remove();
}

  
  // ===== Random waypoints inside sector + faint airways =====
let airways = []; // pairs of waypoint ids to draw lines between

const FUN_FIXES = [
  "YEETR","BORKD","LOLNO","NOMMY","PIZZA","SAUCE","ZAPPY","FIZZY","BANJO","NINJA",
  "TANGO","NACHO","BAGEL","WAFFL","DONUT","BINGO","CHILL","HAPPY","GRUMP","ZORRO",
  "BEEFY","NOODS","SPICY","MUNCH","CRONK","GOOFY","SNEKD","WHAAA","YUMMY","BUBBL"
];
const VOWELS = ["A","E","I","O","U","Y"];
const CONS   = ["B","C","D","F","G","H","J","K","L","M","N","P","Q","R","S","T","V","W","X","Z"];
const usedFixNames = new Set();

function genFunnyFixName(){
  // prefer from list without reusing
  const candidates = FUN_FIXES.filter(n => !usedFixNames.has(n));
  if (candidates.length){
    const n = candidates[Math.floor(Math.random()*candidates.length)];
    usedFixNames.add(n);
    return n;
  }
  // fallback: make something pronounceable(ish) CCVCV
  const pick = arr => arr[Math.floor(Math.random()*arr.length)];
  const name = (pick(CONS)+pick(CONS)+pick(VOWELS)+pick(CONS)+pick(VOWELS)).toUpperCase();
  usedFixNames.add(name);
  return name;
}

// Seed N random waypoints inside current rectangular sector
function seedWaypointsInside(count=12, minSepNm=6){
  const halfW = env.rectW/2, halfH = env.rectH/2;
  const margin = 4; // keep a little away from the edge

  function tooClose(x_nm,y_nm){
    return wpts.some(w => Math.hypot(w.x_nm - x_nm, w.y_nm - y_nm) < minSepNm);
  }

  for(let i=0;i<count;i++){
    let tries=0, x=0, y=0;
    do{
      x = (Math.random()*2-1) * (halfW - margin);
      y = (Math.random()*2-1) * (halfH - margin);
      tries++;
    } while(tries<40 && tooClose(x,y));

    const id = wptNext++;
    const w = { id, name: genFunnyFixName(), x_nm:x, y_nm:y };
    wpts.push(w);
  }
  renderWptList();
}

// Build “airways” by connecting each waypoint to its k nearest neighbors
function buildAirways(k=2){
  const byId = new Map(wpts.map(w=>[w.id,w]));
  const uniq = new Set(); // store "min-max" string keys
  for(const a of wpts){
    const dists = [];
    for(const b of wpts){
      if (a.id===b.id) continue;
      dists.push([b.id, Math.hypot(a.x_nm-b.x_nm, a.y_nm-b.y_nm)]);
    }
    dists.sort((p,q)=>p[1]-q[1]);
    for(let i=0;i<Math.min(k,dists.length);i++){
      const bId = dists[i][0];
      const key = a.id < bId ? `${a.id}-${bId}` : `${bId}-${a.id}`;
      uniq.add(key);
    }
  }
  airways = Array.from(uniq).map(s => s.split('-').map(n=>parseInt(n,10)));
}

  
  // === Named waypoints & airways (static catalog) ===
const WP = {
  CTR: { id: 1000, name: "CTR", x_nm: 0, y_nm: 0 },        // center point
  ENE: { id: 1001, name: "ENE", x_nm:  22, y_nm: -30 },
  ESE: { id: 1002, name: "ESE", x_nm:  32, y_nm:  18 },
  WNW: { id: 1003, name: "WNW", x_nm: -34, y_nm: -12 },
  WSW: { id: 1004, name: "WSW", x_nm: -30, y_nm:  20 },
  N01: { id: 1005, name: "N01", x_nm:   0, y_nm: -40 },
  S01: { id: 1006, name: "S01", x_nm:   0, y_nm:  40 }
};
// Make an immutable array for drawing labels if you want
const WP_ALL = Object.values(WP);

// Airways are pairs of waypoint ids (segments)
const AIRWAYS = [
  [WP.WNW.id, WP.CTR.id], [WP.CTR.id, WP.ENE.id],
  [WP.WSW.id, WP.CTR.id], [WP.CTR.id, WP.ESE.id],
  [WP.N01.id, WP.CTR.id], [WP.CTR.id, WP.S01.id],
];


// helper
function getWPById(id){
  // prefer dynamic wpts the user added, then static catalog
  return wpts.find(w=>w.id===id) || WP_ALL.find(w=>w.id===id) || null;
}
// ---- Routing config + helpers (avoid dogpiling CTR) ----
const EDGE_FIXES = [WP.ENE.id, WP.ESE.id, WP.WNW.id, WP.WSW.id, WP.N01.id, WP.S01.id];

const ROUTE_CFG = {
  goViaCTRProb: 0.00,     // 20% still via CTR; set 0 to ban it
  innerRadiusNm: 16,      // pick a dynamic fix within this radius of center
  addMidProb: 0.3         // chance to include an inner mid-fix on transits/deps
};

function pickInnerFixId(radiusNm = ROUTE_CFG.innerRadiusNm){
  const cands = wpts.filter(w => Math.hypot(w.x_nm, w.y_nm) <= radiusNm);
  if (cands.length) return cands[Math.random()*cands.length|0].id;
  return WP.CTR.id; // fallback if no dynamic waypoints exist yet
}

function randomEdge(excludeId=null){
  const opts = EDGE_FIXES.filter(id => id !== excludeId);
  return opts[Math.random()*opts.length|0];
}


// Put this near your other globals (above spawnAircraft)
const SPAWN = {
  flMin: 330,      // inclusive
  flMax: 400,      // inclusive
  marginNM: 6,     // how far outside the sector to spawn
  jitterDeg: 45    // ± jitter to avoid perfectly cardinal inbounds
};

// --- Auto spawner (cooldown-based; guarantees ≤1 spawn per tick) ---
const AutoSpawn = {
  enabled: false,
  cooldownSec: Infinity,   // counts down while enabled; Infinity when disabled
  minGap: 45,
  maxGap: 65,
  conflictChance: 0.15
};
function randGap(){
  return AutoSpawn.minGap + Math.random()*(AutoSpawn.maxGap - AutoSpawn.minGap);
}
function armCooldown(){ AutoSpawn.cooldownSec = randGap(); }
function disarmCooldown(){ AutoSpawn.cooldownSec = Infinity; }

// routeMode can be 'arrival' | 'departure' | 'transit' | null
function spawnWithParams({x_nm,y_nm,hdg,alt_ft,spd_kt, jitterDeg=0, routeMode=null}, fp=null){
  const a = new Aircraft({ x_nm, y_nm, hdg, alt_ft, spd_kt, fp });
  if (jitterDeg) hdg = mod360(hdg + rand(-jitterDeg, +jitterDeg));
  a.setHeading(hdg);
  a.inSector = env.inRect(a.x_nm, a.y_nm);

  if (fp) {
    let mode = routeMode;
    if (!mode) {
      // backward-compat heuristic if no mode provided
      mode = (!env.inRect(x_nm, y_nm)) ? 'arrival' : 'departure';
    }
    let route;
    if (mode === 'transit')      route = buildTransitRoute(fp);
    else if (mode === 'arrival') route = buildArrivalRoute(fp);
    else                         route = buildDepartureRoute(fp);
    a.setRoute(route);
  }

  state.ac.push(a);
  state.selectedId = a.id;
  flashSelected(); updateSelectedPanel(); drawAll();
  return a;
}


function spawnPlannedAircraft(){
  const halfW = env.rectW/2, halfH = env.rectH/2, m = SPAWN.marginNM;

  // --- choose mode (weights) ---
  const wTransit=0.60, wArrival=0.20, wDepart=0.20; // tweak to taste
  const r = Math.random();
  let mode = 'transit';
  if (r < wTransit) mode = 'transit';
  else if (r < wTransit + wArrival) mode = 'arrival';
  else mode = 'departure';

  // Choose alt/speed & SFP
  const tMin = Math.floor(SPAWN.flMin/10);
  const tMax = Math.floor(SPAWN.flMax/10);
  const FL   = (tMin + randi(0, tMax - tMin))*10;
  const alt  = FL*100;
  const spd  = 420 + Math.random()*70;
  const fp   = makeSFP({ cruiseFL: FL, tasKt: Math.round(spd) });

  if (mode === 'departure'){
    // spawn near center pointing out
    const ang = Math.random()*Math.PI*2;
    const r   = rand(0, Math.min(halfW, halfH)*0.25);
    const x   = Math.sin(ang)*r;
    const y   = -Math.cos(ang)*r;
    const hdg = mod360(toDeg(Math.atan2(x, -y)));
    return spawnWithParams({x_nm:x,y_nm:y,hdg,alt_ft:alt,spd_kt:spd, routeMode:'departure'}, fp);
  }

  // edge spawns share similar logic
  const side = randi(0,3);
  let x=0,y=0,baseHdg=0;
  if (side===0){ y=-(halfH+m); x=rand(-halfW*0.9, halfW*0.9); baseHdg=180; }
  else if(side===1){ x=(halfW+m); y=rand(-halfH*0.9, halfH*0.9); baseHdg=270; }
  else if(side===2){ y=(halfH+m); x=rand(-halfW*0.9, halfW*0.9); baseHdg=0; }
  else { x=-(halfW+m); y=rand(-halfH*0.9, halfH*0.9); baseHdg=90; }

  // small jitter to avoid perfect lines
  const hdg = mod360(baseHdg + rand(-SPAWN.jitterDeg, SPAWN.jitterDeg));

  if (mode === 'arrival'){
    // treat as arrival route (could still avoid CTR per your ROUTE_CFG)
    return spawnWithParams({x_nm:x,y_nm:y,hdg,alt_ft:alt,spd_kt:spd, routeMode:'arrival'}, fp);
  } else {
    // true transit: edge -> inner/exit (route builder ensures exit ≠ entry)
    return spawnWithParams({x_nm:x,y_nm:y,hdg,alt_ft:alt,spd_kt:spd, routeMode:'transit'}, fp);
  }
}


// Spawn a conflict pack (pair or triple) that will converge near center
function spawnConflictPack(useRoutes=false){
  const halfW = env.rectW/2, halfH = env.rectH/2, m = SPAWN.marginNM;

  // Same level for all units in the pack
  const tMin = Math.floor(SPAWN.flMin/10);
  const tMax = Math.floor(SPAWN.flMax/10);
  const FL   = (tMin + randi(0, tMax - tMin))*10;
  const alt  = FL*100;
  const spd1 = 430 + Math.random()*60;
  const spd2 = 430 + Math.random()*60;

  // Choose axis pair (E↔W or N↔S) so they cross the middle
  const EW = Math.random() < 0.5;
  
    const fpArg = useRoutes ? makeSFP({cruiseFL:FL}) : null;


  if (EW){
    // One from West → East, one from East → West, slight vertical offset
    const y = rand(-halfH*0.6, halfH*0.6);
    spawnWithParams({ x_nm:-(halfW+m), y_nm:y+rand(-4, +4), hdg:90+rand(-10,10), alt_ft:alt, spd_kt:spd1 }, fpArg);
    spawnWithParams({ x_nm:(halfW+m),  y_nm:y+rand(-4, +4), hdg:270+rand(-10,10),alt_ft:alt, spd_kt:spd2 }, fpArg);


  } else {
    // One from North → South, one from South → North
    const x = rand(-halfW*0.6, halfW*0.6);
    spawnWithParams({ x_nm:x+rand(-4,+4), y_nm:-(halfH+m), hdg:180+rand(-10,10), alt_ft:alt, spd_kt:spd1 }, fpArg);
    spawnWithParams({ x_nm:x+rand(-4,+4), y_nm:(halfH+m),  hdg:0+rand(-10,10),   alt_ft:alt, spd_kt:spd2 }, fpArg);

  }

  // 30% chance add a third crosser to spice it up
  if (Math.random() < 0.30){
    const hdg = randi(0,3)*90 + rand(-20,20);
    const side = randi(0,3);
    let x=0,y=0;
    if (side===0){ y=-(halfH+m); x=rand(-halfW*0.9, halfW*0.9); }
    else if(side===1){ x=(halfW+m); y=rand(-halfH*0.9, halfH*0.9); }
    else if(side===2){ y=(halfH+m); x=rand(-halfW*0.9, halfW*0.9); }
    else { x=-(halfW+m); y=rand(-halfH*0.9, halfH*0.9); }
    spawnWithParams({ x_nm:x, y_nm:y, hdg, alt_ft:alt, spd_kt: 430+Math.random()*60 }, fpArg);
  }
}


 function spawnAircraft(){
  // Choose a sector edge to spawn from: 0=N, 1=E, 2=S, 3=W
  const side = Math.floor(Math.random()*4);
  const halfW = env.rectW/2, halfH = env.rectH/2;
  const m = SPAWN.marginNM;

  let x=0, y=0, hdg=0;

  switch(side){
    case 0: // from North → heading South
      y = -(halfH + m);
      x = (Math.random()*2 - 1) * (halfW * 0.9);
      hdg = 180;
      break;
    case 1: // from East → heading West
      x =  (halfW + m);
      y = (Math.random()*2 - 1) * (halfH * 0.9);
      hdg = 270;
      break;
    case 2: // from South → heading North
      y =  (halfH + m);
      x = (Math.random()*2 - 1) * (halfW * 0.9);
      hdg = 0;
      break;
    default: // from West → heading East
      x = -(halfW + m);
      y = (Math.random()*2 - 1) * (halfH * 0.9);
      hdg = 90;
      break;
  }



  // Add a little randomization so they’re not laser-straight
  hdg = mod360(hdg + (Math.random()*SPAWN.jitterDeg*2 - SPAWN.jitterDeg));

  // Pick FL in tens within [flMin, flMax]
  const tMin = Math.floor(SPAWN.flMin/10);
  const tMax = Math.floor(SPAWN.flMax/10);
  const tens = tMin + Math.floor(Math.random()*(tMax - tMin + 1)); // integer step of 10 FLs
  const FL = tens * 10;
  const alt = FL * 100; // your sim uses FL * 100 = feet

  // Cruise-y speed; you can also switch to Mach if you prefer
  const spd = 430 + Math.random()*60;

  const a = new Aircraft({ x_nm:x, y_nm:y, hdg:hdg, alt_ft:alt, spd_kt:spd });
  a.setHeading(hdg);                   // ensure initial vector is inbound
  a.inSector = env.inRect(a.x_nm, a.y_nm);

  state.ac.push(a);
  state.selectedId = a.id;
  flashSelected();
  updateSelectedPanel();
  drawAll();
}

  function clearAll(){
    state.ac.length=0; state.selectedId=null; updateSelectedPanel();
    // remove leftover tags
    for(const el of tagMap.values()) el.remove(); tagMap.clear();
    drawAll();
  }

  // ---------- Conflict detection ----------
  const sepNM=5, sepFT=1000;
  function project(ac,tSec){
    const dist_nm=ac.spd_kt*nmPerKtPerSec*tSec;
    const x=ac.x_nm+Math.sin(toRad(ac.hdg))*dist_nm;
    const y=ac.y_nm-Math.cos(toRad(ac.hdg))*dist_nm;
    let alt=ac.alt_ft;
    if(ac.alt_ft!==ac.tgtAlt){
      const vs_fps=clamp(ac.vs_fpm*ftPerMinToFtPerSec, -ac.maxVS_fps, ac.maxVS_fps);
      const delta=vs_fps*tSec; const rem=ac.tgtAlt-ac.alt_ft;
      if(Math.sign(rem)===Math.sign(delta)&&Math.abs(delta)<=Math.abs(rem)) alt=ac.alt_ft+delta; else alt=ac.tgtAlt;
    }
    return {x,y,alt};
  }
  function detectConflicts(){
    state.conflictsNow.length=0; state.conflictsPred.length=0;
    for(let i=0;i<state.ac.length;i++){
      for(let j=i+1;j<state.ac.length;j++){
        const a=state.ac[i], b=state.ac[j];
        const dnm=Math.hypot(a.x_nm-b.x_nm,a.y_nm-b.y_nm);
        const dft=Math.abs(a.alt_ft-b.alt_ft);
        if(dnm<sepNM && dft<sepFT){ state.conflictsNow.push([a.id,b.id]); continue; }
        const t=state.lookaheadMin*60; if(t>0){
          const pa=project(a,t), pb=project(b,t);
          const dnmP=Math.hypot(pa.x-pb.x,pa.y-pb.y);
          const dftP=Math.abs(pa.alt-pb.alt);
          if(dnmP<sepNM && dftP<sepFT) state.conflictsPred.push([a.id,b.id]);
        }
      }
    }
  }

  // ---------- Drawing (split: canvas vs DOM) ----------
  const tagMap = new Map(); // id -> element
  let wptElems=[];

  function layoutWptLabels(){
    // Clear old
    for(const e of wptElems) e.remove(); wptElems.length=0;
    for(const w of wpts){
      const x=cx+nmToPx(w.x_nm), y=cy+nmToPx(w.y_nm);
      const lab=document.createElement('div'); lab.className='waypointLabel'; lab.textContent=w.name;
      lab.style.left=(x+8)+'px'; lab.style.top=(y-10)+'px'; wptElems.push(lab); wrap.appendChild(lab);
    }
  }

  function layoutTags(){
    const presentIds = new Set();
    for(const a of state.ac){
      presentIds.add(a.id);
      const x=cx+nmToPx(a.x_nm), y=cy+nmToPx(a.y_nm);
      let tag = tagMap.get(a.id);
      if(!tag){
        tag=document.createElement('div');
        tag.className='tag';
        tag.dataset.trackId=String(a.id);
        // Drag/select handlers
        let dragging=false, startX=0,startY=0, startDx=0,startDy=0, moved=false;
        tag.addEventListener('pointerdown', ev=>{
  // NEW: Shift + Left Click on tag → use that aircraft position as a measure point
  if (ev.shiftKey && ev.button === 0) {
    const ax = cx + nmToPx(a.x_nm);
    const ay = cy + nmToPx(a.y_nm);
    handleMeasureSmartClick(ax, ay);
    ev.preventDefault();
    return;
  }

  if(ev.button!==0) return; // left only
  dragging=true; moved=false; tag.setPointerCapture(ev.pointerId);
  tag.classList.add('dragging');
  const aObj = state.ac.find(z=>z.id===a.id); if(!aObj) return;
  startX=ev.clientX; startY=ev.clientY; startDx=aObj.labelDx; startDy=aObj.labelDy; ev.preventDefault();
});

        tag.addEventListener('pointermove', ev=>{
          if(!dragging) return;
          const aObj = state.ac.find(z=>z.id===a.id); if(!aObj) return;
          const dx=ev.clientX-startX, dy=ev.clientY-startY;
          if(Math.hypot(dx,dy)>3) moved=true;
          aObj.labelDx = startDx + dx; aObj.labelDy = startDy + dy;
          tag.style.left = (cx+nmToPx(aObj.x_nm) + aObj.labelDx) + 'px';
          tag.style.top  = (cy+nmToPx(aObj.y_nm) + aObj.labelDy) + 'px';
          drawCanvasOnly(); // canvas only for smoothness
        });
        tag.addEventListener('pointerup', ev=>{
          tag.classList.remove('dragging');
          if(dragging && !moved){ state.selectedId=a.id; flashSelected(); updateSelectedPanel(); layoutTags(); drawCanvasOnly(); }
          dragging=false;
        });
        tag.addEventListener('click', ev=>{ ev.stopPropagation(); });
        wrap.appendChild(tag);
        tagMap.set(a.id, tag);
      }
      // Update classes/content/position
      tag.classList.toggle('alert', state.conflictsNow.some(([p,q])=>p===a.id||q===a.id));
      tag.classList.toggle('warn', !tag.classList.contains('alert') && state.conflictsPred.some(([p,q])=>p===a.id||q===a.id));
      // apply state color class for text-only labels
const st = getTrackState(a);   // uses helpers from step 2.3
tag.classList.remove('st-controlled','st-inbound','st-intruder','st-outbound');
tag.classList.add('st-'+st);

// build 4 text lines (no box, no table)
const curFL = fmtFLshort(a.alt_ft);
const cfl   = fmtCFL(a.tgtAlt);
const type  = a.fp?.type || "—";
const wpt   = nextWptName(a, env);
const vs100 = fmtVS100(a.vs_fpm);

tag.innerHTML = `
  <div class="l1">${a.cs}<span class="ho" data-ho="1" title="Toggle H/O">H/O</span></div>
  <div class="l2">${curFL}    ${cfl}</div>
  <div class="l2">${type}    ${wpt}</div>
  <div class="l2">H${formatHeading(a.hdg)}    S${a.spd_kt|0}/M${a.mach.toFixed(2)}    VS${vs100}</div>

`;

// wire the tiny H/O toggle (marks a.hoMarked to drive "intruder" color)
const hoBtn = tag.querySelector('[data-ho]');
if (hoBtn){
  hoBtn.onclick = (ev)=>{
    ev.stopPropagation();
    a.hoMarked = !a.hoMarked;
    layoutTags(); drawCanvasOnly();
  };
}


      tag.style.left=(x+a.labelDx)+'px'; tag.style.top=(y+a.labelDy)+'px';
    }
    

    // Remove tags for AC that no longer exist
    for(const [id,el] of tagMap.entries()){
      if(!presentIds.has(Number(id))){ el.remove(); tagMap.delete(id); }
    }
  }

  function drawScope(){
  // Background (near-black)
  ctx.save();
  ctx.setTransform(1,0,0,1,0,0);
  ctx.globalAlpha = 1;
  ctx.fillStyle = "#060707";
  ctx.fillRect(0,0,W,H);

  // Very faint grid (optional)
  ctx.strokeStyle = "#0b0b0b";
  ctx.lineWidth = 1;
  ctx.beginPath();
  for(let x=0;x<W;x+=40){ ctx.moveTo(x,0); ctx.lineTo(x,H); }
  for(let y=0;y<H;y+=40){ ctx.moveTo(0,y); ctx.lineTo(W,y); }
  ctx.stroke();

  // Faint range rings (no labels)
  ctx.strokeStyle = "#141414";
  ctx.lineWidth = 1;
  const ringCount = 5;
  for(let i=1;i<=ringCount;i++){
    const r = (Math.min(W,H)/2) * i / ringCount;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI*2);
    ctx.stroke();
  }

  // Crosshair
  ctx.strokeStyle = "#1a1a1a";
  ctx.beginPath();
  ctx.moveTo(cx,0); ctx.lineTo(cx,H);
  ctx.moveTo(0,cy); ctx.lineTo(W,cy);
  ctx.stroke();

  // Rectangular sector (subtle grey)
  const halfWpx = nmToPx(env.rectW/2);
  const halfHpx = nmToPx(env.rectH/2);
  ctx.strokeStyle = "#3a3a3a";
  ctx.lineWidth = 1.6;
  ctx.setLineDash([6,6]);
  ctx.strokeRect(cx-halfWpx, cy-halfHpx, halfWpx*2, halfHpx*2);
  ctx.setLineDash([]);
  ctx.restore();
}


  function formatAltitude(ft){ return ft>=18000?("FL"+String(Math.round(ft/100)).padStart(3,'0')):((ft|0)+" ft"); }
  function inFilter(ft){ return ft>=state.filterMin && ft<=state.filterMax; }

  function drawPredictLines(ac){
  const wants=[ state.pred1?60:0, state.pred3?180:0, state.pred5?300:0 ].filter(Boolean);
  if(!wants.length) return;
  const x0=cx+nmToPx(ac.x_nm), y0=cy+nmToPx(ac.y_nm);
  ctx.lineWidth=1.5; ctx.setLineDash([]);      // solid
  ctx.strokeStyle = "#ffffff";                  // white
  for(const t of wants){
    const dist_nm=ac.spd_kt*nmPerKtPerSec*t;
    const x=x0+nmToPx(Math.sin(toRad(ac.hdg))*dist_nm);
    const y=y0+nmToPx(-Math.cos(toRad(ac.hdg))*dist_nm);
    ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x,y); ctx.stroke();
  }
}

  
function drawAirways(){
  ctx.save();
  ctx.strokeStyle = "rgba(150, 200, 255, 0.5)";
  ctx.lineWidth = 1.2;
  ctx.setLineDash([2,10]);
  for(const [a,b] of AIRWAYS){
    const A = getWPById(a), B = getWPById(b);
    if(!A || !B) continue;
    const x1 = cx + nmToPx(A.x_nm), y1 = cy + nmToPx(A.y_nm);
    const x2 = cx + nmToPx(B.x_nm), y2 = cy + nmToPx(B.y_nm);
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  }
  ctx.restore();
}

  function drawWaypointsCrosses(){
  // Airways (faint lines first)
  ctx.strokeStyle = "rgba(150, 200, 255, 0.5)";
  ctx.lineWidth = 1;
  ctx.setLineDash([4,8]); // faint dashed
  ctx.beginPath();
  for(const [aId,bId] of airways){
    const a = wpts.find(w=>w.id===aId);
    const b = wpts.find(w=>w.id===bId);
    if(!a||!b) continue;
    const x1 = cx + nmToPx(a.x_nm), y1 = cy + nmToPx(a.y_nm);
    const x2 = cx + nmToPx(b.x_nm), y2 = cy + nmToPx(b.y_nm);
    ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
  }
  ctx.stroke();
  ctx.setLineDash([]);

  // Waypoint crosses on top
  for(const w of wpts){
    const x=cx+nmToPx(w.x_nm), y=cy+nmToPx(w.y_nm);
    ctx.strokeStyle="#ff7bff"; ctx.lineWidth=1.2;
    ctx.beginPath(); ctx.moveTo(x-6,y); ctx.lineTo(x+6,y); ctx.moveTo(x,y-6); ctx.lineTo(x,y+6); ctx.stroke();
  }
}


  function drawConflicts(){
    for(const [aId,bId] of state.conflictsPred){
      const a=state.ac.find(x=>x.id===aId), b=state.ac.find(x=>x.id===bId); if(!a||!b) continue;
      ctx.strokeStyle="#ffcc66"; ctx.lineWidth=1.5; ctx.setLineDash([4,6]);
      ctx.beginPath(); ctx.moveTo(cx+nmToPx(a.x_nm), cy+nmToPx(a.y_nm)); ctx.lineTo(cx+nmToPx(b.x_nm), cy+nmToPx(b.y_nm)); ctx.stroke();
    }
    for(const [aId,bId] of state.conflictsNow){
      const a=state.ac.find(x=>x.id===aId), b=state.ac.find(x=>x.id===bId); if(!a||!b) continue;
      ctx.strokeStyle="#ff6a6a"; ctx.lineWidth=2.2; ctx.setLineDash([]);
      ctx.beginPath(); ctx.moveTo(cx+nmToPx(a.x_nm), cy+nmToPx(a.y_nm)); ctx.lineTo(cx+nmToPx(b.x_nm), cy+nmToPx(b.y_nm)); ctx.stroke();
    }
    ctx.setLineDash([]);
  }

// --- Measuring (refactored) ---
// Measures now support endpoints that can be either:
//  - {type:'ac', id:<trackId>}  -> follows that aircraft live
//  - {x_nm:<num>, y_nm:<num>}   -> fixed point in space
// Backward compatibility: we still render old {fromX_nm, toX_nm, ...} shapes.

function drawMeasureSegment(m){
  ctx.save();

  // Resolve endpoints (support both new and legacy shapes)
  const p1 = m.from ? resolveEndpoint(m.from) : {x_nm:m.fromX_nm, y_nm:m.fromY_nm};
  const p2 = m.to   ? resolveEndpoint(m.to)   : {x_nm:m.toX_nm,   y_nm:m.toY_nm};
  if(!p1 || !p2){ ctx.restore(); return; }

  const x1 = cx + nmToPx(p1.x_nm), y1 = cy + nmToPx(p1.y_nm);
  const x2 = cx + nmToPx(p2.x_nm), y2 = cy + nmToPx(p2.y_nm);

  // line
  ctx.strokeStyle="#9ad6ff";
  ctx.lineWidth=1.8;
  ctx.setLineDash([8,6]);
  ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  ctx.setLineDash([]);

  // endpoints
  ctx.fillStyle="#e6f0f7";
  ctx.beginPath(); ctx.arc(x1,y1,3,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x2,y2,3,0,Math.PI*2); ctx.fill();

  // label text (no box): place slightly "above" the segment midpoint
  const dnm = Math.hypot(p2.x_nm-p1.x_nm, p2.y_nm-p1.y_nm);
  const brg = bearingFromTo(p1.x_nm,p1.y_nm,p2.x_nm,p2.y_nm);
  const text = `${dnm.toFixed(1)} NM • HDG ${formatHeading(brg)}`;

  const midx = (x1+x2)/2, midy = (y1+y2)/2;
  // screen-space normal (perpendicular) for offset
  const nx = (y2 - y1), ny = -(x2 - x1);
  const nlen = Math.hypot(nx, ny) || 1;
  const off = 14; // how far above the line (px)
  const tx = midx + (nx / nlen) * off;
  const ty = midy + (ny / nlen) * off;

  // halo + fill for readability
  ctx.font = "12px ui-monospace";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.lineWidth = 4;
  ctx.strokeStyle = "rgba(7,16,24,0.9)"; // dark halo
  ctx.strokeText(text, tx, ty);
  ctx.fillStyle = "#cfe8f7";
  ctx.fillText(text, tx, ty);

  ctx.restore();
}


function drawActiveMeasure(){
  if(!state.measure) return;
  ctx.save();
  ctx.globalAlpha = 1;      // don’t inherit any dimming
  ctx.setLineDash([]);      // don’t inherit dashes
  drawMeasureSegment(state.measure);
  ctx.restore();
}
function drawRulers(){
  ctx.save();
  ctx.globalAlpha = 1;
  ctx.setLineDash([]);
  for(const m of state.measures) drawMeasureSegment(m);
  ctx.restore();
}


// NEW: Shift+Left click handler — snaps to aircraft (live) or uses free point.
function handleMeasureSmartClick(xPx, yPx){
  const ac = findNearestAcPx(xPx, yPx, 16);
  const ep = ac ? { type:'ac', id: ac.id }
                : pxToNm(xPx, yPx); // {x_nm, y_nm}

  if(!state.measure){
    // Start: from = ep, to = cursor (temporary same ep)
    state.measure = { from: ep, to: ep };
  }else{
    // Finish: set 'to' endpoint and commit
    state.measure.to = ep;
    state.measures.push({ ...state.measure }); // store by reference
    state.measure = null;
  }
  drawAll();
}



  function drawCanvasBase(){
    drawScope();
    drawAirways();
    drawWaypointsCrosses();
    detectConflicts();

    for(const a of state.ac){
      const selected = a.id===state.selectedId;
      const dim = !inFilter(a.alt_ft); ctx.globalAlpha = dim?0.35:1.0;

      // Dotted trail (dots only)
      ctx.fillStyle = "#ffffff";
      for(const p of a.trail){
        const tx = cx+nmToPx(p.x), ty = cy+nmToPx(p.y);
        ctx.beginPath(); ctx.arc(tx,ty,2.4,0,Math.PI*2); ctx.fill();
      }

      // Predict lines (solid only)
      const showPred = state.predFor==="all" || (state.predFor==="sel" && selected);
      if(showPred) drawPredictLines(a, selected);

      // Aircraft symbol: diamond (45° rotated square)
const x = cx + nmToPx(a.x_nm), y = cy + nmToPx(a.y_nm);
const s = 5; // half-size in px; tweak 4–6 to taste
ctx.fillStyle = "#ffffff";
ctx.beginPath();
ctx.moveTo(x, y - s);   // top
ctx.lineTo(x + s, y);   // right
ctx.lineTo(x, y + s);   // bottom
ctx.lineTo(x - s, y);   // left
ctx.closePath();
ctx.fill();
// (optional outline)
// ctx.lineWidth = 1; ctx.strokeStyle = "#ffffff"; ctx.stroke();


    }

    drawConflicts();
    ctx.globalAlpha=1.0;
  }

  function drawLeaders(){
    for(const a of state.ac){
      const dotX=cx+nmToPx(a.x_nm), dotY=cy+nmToPx(a.y_nm);
      const tag = tagMap.get(a.id); if(!tag) continue;
      const rect = tag.getBoundingClientRect(), wrapRect = wrap.getBoundingClientRect();
      const left = rect.left - wrapRect.left, top = rect.top - wrapRect.top;
      const right = left + rect.width, bottom = top + rect.height;
      const ex = clamp(dotX, left, right), ey = clamp(dotY, top, bottom);
      ctx.strokeStyle = "#ffffff";

      ctx.beginPath(); ctx.moveTo(dotX, dotY); ctx.lineTo(ex, ey); ctx.stroke();
    }
  }

  function drawCanvasOnly(){ // fast path during drags
    drawCanvasBase();
    drawLeaders();
    drawRulers();     // NEW: draw committed rulers
    drawActiveMeasure();
  }

  function drawAll(){ // full layout
    drawCanvasBase();
    layoutWptLabels();
    layoutTags();
    drawLeaders();
    drawRulers();     // NEW: draw committed rulers
    drawActiveMeasure();
  }

// ---------- Simulation (3s refresh) ----------
function stepOnce(){
  if(state.paused){ 
    drawCanvasOnly(); 
    return; 
  }

  // advance sim clock
  simNowSec += state.refreshSec * state.simSpeed;
  const dt = state.refreshSec * state.simSpeed;

  // move all aircraft
  for(const a of state.ac) a.update(dt, env);
  // Mark seen-once and cull only after they actually appeared
for (const a of state.ac) {
  if (acInScopeNm(a, 0)) a.seenOnScreenOnce = true;
}

const TTL_NEVER_SEEN_SEC = 180; // safety: if something never appears in 3 min, drop it
state.ac = state.ac.filter(a => {
  if (!a.seenOnScreenOnce) {
    // Keep until it appears, unless TTL expires (or it has already entered)
    return (simNowSec - a.spawnSec) < TTL_NEVER_SEEN_SEC || acInScopeNm(a, 0);
  }
  // Once seen at least once, despawn after it leaves the scope by 8 NM
  return acInScopeNm(a, 8);
});

if (state.selectedId && !state.ac.some(a => a.id === state.selectedId)) {
  state.selectedId = null;
}


// auto-spawn (cooldown)
if (AutoSpawn.enabled && Number.isFinite(AutoSpawn.cooldownSec)) {
  AutoSpawn.cooldownSec -= dt;        // dt = state.refreshSec * state.simSpeed
  if (AutoSpawn.cooldownSec <= 0) {
    if (Math.random() < AutoSpawn.conflictChance) {
  spawnConflictPack(true);   // routed conflicts for autos
} else {
  spawnPlannedAircraft();    // routed singles for autos
}

    armCooldown();                    // reset for next randomized gap
  }
}


  drawAll();
}
let timer = setInterval(stepOnce, 3000);


  // ---------- UI ----------
  const altInput=document.getElementById('alt'); const useFL=document.getElementById('useFL'); const altHint=document.getElementById('altModeHint');
  function updateAltPlaceholder(){
    if(useFL.checked){ altInput.placeholder="e.g. 150 (FL150)"; altHint.textContent="Input interpreted as Flight Level (hundreds of feet)"; }
    else{ altInput.placeholder="e.g. 15000 (ft)"; altHint.textContent="Input interpreted as feet (type FL120 to use FL)"; }
  }
  useFL.addEventListener('change', ()=>{
    const a=getSelected();
    if(a){ altInput.value = useFL.checked ? Math.round(a.tgtAlt/100) : Math.round(a.tgtAlt); }
    updateAltPlaceholder();
  });
  updateAltPlaceholder();

  // Canvas interactions
  canvas.addEventListener('click', e=>{
    if(state.addingWpt){
      const rect=canvas.getBoundingClientRect();
      const xPx=e.clientX-rect.left, yPx=e.clientY-rect.top;
      const {x_nm,y_nm}=pxToNm(xPx,yPx);
      addWaypointAt(x_nm,y_nm); state.addingWpt=false;
      document.getElementById('addWpt').textContent="Add waypoint"; return;
    }
    state.selectedId=null; updateSelectedPanel(); layoutTags(); drawCanvasOnly();
  });

// Measuring: Shift+MMB start/update, RMB now DROPS (commits) instead of clearing.
//           NEW: Shift+Left Click = start/finish with snapping
canvas.addEventListener('pointerdown', e=>{
  const rect = canvas.getBoundingClientRect();
  const xPx = e.clientX - rect.left, yPx = e.clientY - rect.top;

  // Shift + Left Click = smart start/finish (snaps to aircraft if close)
  if (e.shiftKey && e.button === 0) {
    handleMeasureSmartClick(xPx, yPx);
    e.preventDefault();
    return;
  }

  // Plain Left Click = if already measuring, drop/commit immediately
  if (!e.shiftKey && e.button === 0 && state.measure) {
    state.measures.push({ ...state.measure });
    state.measure = null;
    drawAll();
    e.preventDefault();
    return;
  }
});



canvas.addEventListener('pointermove', e=>{
  if(!state.measure) return;
  // If we're mid-placing the second endpoint and it's NOT an aircraft-linked endpoint,
  // update it to follow the cursor for a live preview.
  const rect=canvas.getBoundingClientRect();
  const xPx=e.clientX-rect.left, yPx=e.clientY-rect.top;

  // If 'to' is aircraft-linked, don't override it.
  if(state.measure.to && state.measure.to.type === 'ac') return;

  const {x_nm,y_nm}=pxToNm(xPx,yPx);
  // Ensure the new-style shape exists
  if(!state.measure.from && 'fromX_nm' in state.measure){
    state.measure = { from:{x_nm:state.measure.fromX_nm, y_nm:state.measure.fromY_nm},
                      to:{x_nm, y_nm} };
  }else{
    state.measure.to = {x_nm, y_nm};
  }
  drawCanvasOnly();
});


canvas.addEventListener('pointerup', e=>{
  // keep the ruler until RMB/Esc clears or commits; release capture if we had it
  try { canvas.releasePointerCapture(e.pointerId); } catch {}
});

canvas.addEventListener('pointercancel', e=>{
  try { canvas.releasePointerCapture(e.pointerId); } catch {}
});

// Allow context menu unless we just handled a commit above
canvas.addEventListener('contextmenu', e=>{
  // If a ruler is active, let RMB commit handler above run and suppress menu; otherwise allow menu.
  if (state.measure) e.preventDefault();
});

  function flashSelected(){ const card=document.getElementById('selectedInfo'); card.classList.add('selected'); setTimeout(()=>card.classList.remove('selected'), 450); }

  function updateSelectedPanel(){
    const el=document.getElementById('selectedInfo'); const a=getSelected();
    if(!a){ el.className='aircraftCard small'; el.innerHTML='Tap/click a tag to select; drag tags anywhere (works on mobile).'; return; }
    el.className='aircraftCard selected';
    const route = a.navMode==="DIRECT"&&a.directWptId ? ` • DIR ${env.getWaypoint(a.directWptId)?.name||""}` : "";
    el.innerHTML = `
  <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
    <div><strong>${a.cs}</strong> — H${formatHeading(a.hdg)} • S${a.spd_kt|0} kt/M${a.mach.toFixed(2)} • ${formatAltitude(a.alt_ft)}${route}</div>
    <button class="btnSfp small" style="white-space:nowrap;">SFP</button>
  </div>
  <div class="small">Targets: H${formatHeading(a.tgtHdg)} • ${
  a.tgtSpeedMode==='MACH'
    ? ('M'+(a.tgtMach?.toFixed(2) ?? (a.tgtSpd_kt/isaSpeedOfSoundKts(a.alt_ft)).toFixed(2)))
    : ('S'+((a.tgtSpd_kt|0))+' kt')
} • ALT ${formatAltitude(a.tgtAlt)} • VS${fmtVS100(a.vs_fpm)} • SEC ${a.inSector?'IN':'OUT'}

`;
const sfpBtn = el.querySelector('.btnSfp');
if(sfpBtn){
  sfpBtn.addEventListener('click', ()=>{
    openSFP(a);
  });
  // If SFP window is open, refresh it for the new selection (or close if none)
const openWin = document.querySelector('.sfpWin');
if(openWin){
  const sel = getSelected();
  if(sel) renderSFP(sel); else closeSFP();
}

}

    altInput.value = useFL.checked ? Math.round(a.tgtAlt/100) : Math.round(a.tgtAlt);
    document.getElementById('hdg').value = Math.round(a.tgtHdg)||0;
    document.getElementById('spd').value = a.tgtSpeedMode==='KT' ? a.tgtSpd_kt|0 : "";
    document.getElementById('mach').value = a.tgtSpeedMode==='MACH'&&a.tgtMach ? a.tgtMach.toFixed(2) : "";
    document.getElementById('vs').value = a.vs_fpm ? (Math.abs(a.vs_fpm)|0) : "";
  }

  document.getElementById('spawn').addEventListener('click', spawnAircraft);
  document.getElementById('autoSpawnToggle').addEventListener('change', e=>{
  AutoSpawn.enabled = e.target.checked;
  if (AutoSpawn.enabled){
    armCooldown();      // start a fresh randomized gap
  } else {
    disarmCooldown();   // stop any pending spawn
  }
});


document.getElementById('spawnConflict').addEventListener('click', ()=>{
  spawnConflictPack();
});

  document.getElementById('clear').addEventListener('click', clearAll);
  document.getElementById('pause').addEventListener('click', e=>{
    state.paused=!state.paused; e.target.textContent=state.paused?"Resume":"Pause";
  });
  document.getElementById('rangeSel').addEventListener('change', e=>{ rangeNM=parseInt(e.target.value,10); drawAll(); });
  document.getElementById('simSpeed').addEventListener('change', e=>{ state.simSpeed=parseFloat(e.target.value); });

  for(const id of ["pred1","pred3","pred5"]) document.getElementById(id).addEventListener('change', e=>{ state[id]=e.target.checked; drawAll(); });
  document.getElementById('predFor').addEventListener('change', e=>{ state.predFor=e.target.value; drawAll(); });

  document.getElementById('lookahead').addEventListener('change', e=>{ state.lookaheadMin=parseInt(e.target.value,10); drawAll(); });

  document.getElementById('btnFilter').addEventListener('click', ()=>{
    state.filterMin=parseInt(document.getElementById('fltMin').value,10)||0;
    state.filterMax=parseInt(document.getElementById('fltMax').value,10)||60000;
    drawAll();
  });

  document.getElementById('spd250').addEventListener('change', e=>{ env.restrict250=e.target.checked; });

  document.getElementById('addWpt').addEventListener('click', e=>{
    state.addingWpt=!state.addingWpt; e.target.textContent=state.addingWpt?"Click scope…":"Add waypoint";
  });
  document.getElementById('clearWpt').addEventListener('click', clearWaypoints);

  document.getElementById('autoHandoff').addEventListener('change', e=>{ env.autoHandoff=e.target.checked; });
  document.getElementById('btnHandoff').addEventListener('click', ()=>{
    const a=getSelected(); if(!a){ alert("Select a track first."); return; }
    if(a.handoffPending){ a.inSector=a.pendingState; a.handoffPending=false; a.pendingState=null; }
    updateSelectedPanel(); drawAll();
  });
  document.getElementById('btnRect').addEventListener('click', ()=>{
    env.rectW=Math.max(5,parseFloat(document.getElementById('rectW').value)||env.rectW);
    env.rectH=Math.max(5,parseFloat(document.getElementById('rectH').value)||env.rectH);
    drawAll();
  });

  // NEW: Measure tool UI button
  document.getElementById('clearRulers').addEventListener('click', ()=>{ state.measures.length=0; drawAll(); });

  // Commands
  document.getElementById('btnHdg').addEventListener('click', ()=>{
    const a=getSelected(); if(!a) return;
    let hdg=parseInt(document.getElementById('hdg').value,10);
    if(!Number.isFinite(hdg)) return;
    if(hdg===360) hdg=0;
    a.setHeading(mod360(hdg));
    updateSelectedPanel(); drawAll();
  });

  document.getElementById('btnAlt').addEventListener('click', ()=>{
    const a=getSelected(); if(!a) return;
    const altFt = parseAltitudeInput(document.getElementById('alt').value, useFL.checked);
    let vs = document.getElementById('vs').value.trim(); vs = vs===""? null : parseInt(vs,10);
    if(altFt!=null) a.setAltitude(altFt, vs);
    updateSelectedPanel(); drawAll();
  });

  document.getElementById('btnHold').addEventListener('click', ()=>{ const a=getSelected(); if(!a) return; a.holdAltitude(); updateSelectedPanel(); drawAll(); });
  document.getElementById('btnSpd').addEventListener('click', ()=>{
    const a=getSelected(); if(!a) return; const spd=parseInt(document.getElementById('spd').value,10);
    if(Number.isFinite(spd)) a.setSpeedKt(spd); updateSelectedPanel(); drawAll();
  });
  document.getElementById('btnMach').addEventListener('click', ()=>{
    const a=getSelected(); if(!a) return; const m=parseFloat(document.getElementById('mach').value);
    if(Number.isFinite(m)) a.setMach(m); updateSelectedPanel(); drawAll();
  });

  // Shortcuts
  window.addEventListener('keydown', e=>{
    if (e.key === 'Escape') {
      if (state.measure) { state.measure = null; drawCanvasOnly(); return; }
      if (state.measures.length) { state.measures.pop(); drawAll(); return; }
    }
    const a=getSelected();
    if(e.code==='Space'){ e.preventDefault(); state.paused=!state.paused; document.getElementById('pause').textContent=state.paused?"Resume":"Pause"; }
    else if(e.key==='N'||e.key==='n'){ spawnAircraft(); }
    else if(a){
      if(e.key==='H'||e.key==='h'){
        const v=prompt("Vector: heading (1–360)", Math.min(360,Math.max(1, Math.round(a.tgtHdg)||1)));
        if(v!==null){ let h=parseInt(v,10); if(h===360) h=0; if(Number.isFinite(h)) a.setHeading(mod360(h)); updateSelectedPanel(); drawAll(); }
      }else if(e.key==='A'||e.key==='a'){
        const hint = useFL.checked ? "FL (e.g. 120), optional VS like 120,1800" : "ft (e.g. 12000), optional VS like 12000,1800";
        const v=prompt("Altitude — "+hint, useFL.checked? String(Math.round(a.tgtAlt/100)) : String(Math.round(a.tgtAlt)));
        if(v!==null){
          const parts=v.toUpperCase().split(',');
          const altFt = parseAltitudeInput(parts[0], useFL.checked);
          const vs = parts[1]? parseInt(parts[1],10) : null;
          if(altFt!=null) a.setAltitude(altFt, vs);
          updateSelectedPanel(); drawAll();
        }
      }else if(e.key==='S'||e.key==='s'){
        const v=prompt("Speed (kt)", a.tgtSpeedMode==='KT'?(a.tgtSpd_kt|0):"");
        if(v!==null && v.trim()!==""){ a.setSpeedKt(parseInt(v,10)); updateSelectedPanel(); drawAll(); }
      }else if(e.key==='M'||e.key==='m'){
        const v=prompt("Mach (e.g. 0.78)", a.tgtSpeedMode==='MACH'&&a.tgtMach?a.tgtMach.toFixed(2):"");
        if(v!==null && v.trim()!==""){ a.setMach(parseFloat(v)); updateSelectedPanel(); drawAll(); }
      }
    }
  });

// Start AFTER the page has laid out (canvas has real size)
window.addEventListener('load', () => {
  resize();            // compute sizes once
  renderWptList();
  seedWaypointsInside(9);   // tweak the number if you want more/less
  buildAirways(2);           // connect each fix to 2 nearest neighbors
  spawnAircraft();
  spawnAircraft();
  booted = true;       // now future resizes can redraw
  drawAll();
});
</script>
</body>
</html>
