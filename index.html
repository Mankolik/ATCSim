<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>ATC Radar Trainer — v7</title>
<style>
  :root{
  /* Near-black scope */
  --bg:#060707;
  --grid:#0c0c0c;         /* very faint grid (optional) */
  --ring:#141414;         /* very faint rings (optional) */

  /* UI text + panel remain readable */
  --text:#e8eef2;
  --accent:#8fd3ff;
  --panel:#0d1115;

  /* not used for labels anymore, but keep */
  --tag:#0d2230; --tagBorder:#1b3a4f;
  --sel:#9bf6a9; --warn:#ffcc66; --alert:#ff6a6a;
  --muted:#9fb3c1; --magenta:#ff7bff;

  /* leader/rect colors no longer blue; vectors & leaders will be white in JS */
  --leader:#ffffff; --rect:#3a3a3a;
}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:var(--bg); color:var(--text);
    font:15px/1.35 ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Courier New",monospace;
    display:grid; grid-template-columns:1fr 380px; grid-template-rows:56px 1fr;
    grid-template-areas:"top top" "radar panel";
    overflow:hidden auto;
  }
  header{grid-area:top; display:flex; align-items:center; gap:12px;
    padding:10px 14px; background:linear-gradient(180deg,#0d1921,#0a1117);
    border-bottom:1px solid #162737}
  header h1{margin:0; font-size:16px; font-weight:600; letter-spacing:.5px; color:var(--accent)}
  header .controls{display:flex; gap:8px; flex-wrap:wrap; margin-left:auto}
  button,input,select{background:#0d1a22; border:1px solid #1b3243; color:var(--text); padding:8px 10px; border-radius:8px; outline:none}
  button:hover{border-color:#24516e; cursor:pointer}
  input[type="number"],input[type="text"]{width:110px}
  #radarWrap{grid-area:radar; position:relative}
  canvas{display:block; width:100%; height:100%}
  aside{grid-area:panel; border-left:1px solid #162737; background:var(--panel); padding:12px; overflow:auto}
  .section{margin-bottom:14px; padding-bottom:12px; border-bottom:1px dashed #173243}
  .row{display:flex; gap:8px; align-items:center; margin:6px 0; flex-wrap:wrap}
  label{font-size:12px; color:var(--muted); min-width:86px}
  .small{font-size:12px; color:var(--muted)}
  .aircraftCard{border:1px solid #193246; background:#0b1620; border-radius:10px; padding:10px; margin:8px 0}
  .aircraftCard.selected{border-color:var(--sel)}
  .grid2{display:grid; grid-template-columns:1fr 1fr; gap:8px}
  .kbd{padding:2px 6px; border:1px solid #274b64; border-radius:6px; background:#0c1b25}

/* ===== Track labels (text only; no box) ===== */
.tag{
  position:absolute;
  background:transparent;        /* no box */
  border:none;                   /* no border */
  padding:0;                     /* tight */
  filter:none;
  touch-action:none; user-select:none; cursor:grab;
  opacity:1;                     /* solid text */
}
.tag:hover,.tag.dragging{opacity:1}

/* simple type ramp */
.tag .l1{ font-weight:700; font-size:14px; line-height:1.05 }
.tag .l2{ font-size:12px; line-height:1.05; letter-spacing:.2px }
/* label size presets */
body.label-sm .tag .l1{ font-size:12px }
body.label-sm .tag .l2{ font-size:10px }
body.label-lg .tag .l1{ font-size:16px }
body.label-lg .tag .l2{ font-size:14px }


/* state-driven colors */
.tag.st-controlled { color:#69ff8a; }     /* green */
.tag.st-inbound    { color:#ffffff; }     /* white */
.tag.st-intruder   { color:#ffd9b3; }     /* very light orange */
.tag.st-outbound   { color:#9aa3aa; }     /* greyed out */
/* highlight the field currently being edited */
.tag [data-act].editing{
  outline:1px dashed currentColor;
  outline-offset:2px;
  border-radius:4px;
  padding:0 2px;
}


/* tiny inline button to mark handoff (optional) */
.tag .ho{
  display:inline-block; margin-left:8px; padding:1px 6px;
  font-size:10px; border:1px solid currentColor; border-radius:999px;
}
  .tag:hover,.tag.dragging{opacity:1}
  .tag .line1{font-weight:600}
  .tag .line2{font-size:12px; color:var(--muted)}
  .tag.alert{border-color:var(--alert)}
  .tag.warn{border-color:var(--warn)}
  .pill{padding:2px 6px; border:1px solid #2c4a5f; border-radius:999px; background:#0c1b25; font-size:11px; color:var(--muted)}
  .waypointLabel{position:absolute; background:transparent; border:0px solid #2c4a5f; border-radius:6px; padding:0px 6px; font-size:11px; color:#cde; opacity:.85}
  /* --- SFP floating window --- */
.sfpWin{
  position:absolute; right:12px; top:64px; width:260px;
  background:#0b1620; border:1px solid #1b3a4f; border-radius:10px;
  box-shadow:0 6px 18px rgba(0,0,0,.35); z-index:20; user-select:auto;
}
.sfpWin .hdr{ cursor:grab; }
.sfpWin.is-dragging .hdr{ cursor:grabbing; }

.sfpWin .hdr{
  display:flex; align-items:center; justify-content:space-between;
  padding:8px 10px; border-bottom:1px solid #173243; color:#9fb3c1; font-size:12px;
  background:linear-gradient(180deg,#0e1820,#0b141a);
  border-top-left-radius:10px; border-top-right-radius:10px;
}
.sfpWin .hdr .title{ font-weight:600; color:#cfe8f7; font-size:12px; letter-spacing:.3px }
.sfpWin .hdr button{
  background:#0d1a22; border:1px solid #274b64; color:#cfe8f7; padding:4px 8px; border-radius:6px; cursor:pointer;
}
.sfpWin .body{ padding:10px }
.sfpWin table{ width:100%; border-collapse:collapse; font-size:12px; color:#cfe8f7 }
.sfpWin td{ padding:4px 0; vertical-align:top }
.sfpWin td.key{ color:#9fb3c1; width:88px }
.sfpWin .route{ margin-top:8px; font-size:12px; color:#9ad6ff; line-height:1.35 }

</style>
</head>
<body>
<header>
  <h1>ATC Radar Trainer — v7</h1>
  <div class="controls">
    <button id="spawn">Spawn traffic</button>
    <label class="small">
  <input id="autoSpawnToggle" type="checkbox"> Auto-spawn
</label>
<button id="spawnConflict">Spawn conflict</button>

    <button id="clear">Clear all</button>
    <button id="pause">Pause</button>
    <label class="small">Range (NM)
      <select id="rangeSel">
  <option>20</option>
  <option>40</option>
  <option>60</option>
  <option>80</option>
  <option selected>120</option>
  <option>160</option>
  <option>200</option>
  <option>240</option>
  <option>320</option>
  <option>400</option>
  <option>600</option>
  <option>800</option>
</select>

    </label>
    <label class="small">Sim speed
      <select id="simSpeed"><option value="0.5">0.5×</option><option value="1" selected>1×</option><option value="2">2×</option><option value="4">4×</option></select>
    </label>
    <label class="small">Labels
  <select id="labelSize">
    <option value="sm">Small</option>
    <option value="md" selected>Medium</option>
    <option value="lg">Large</option>
  </select>
</label>

  </div>
</header>

<div id="radarWrap">
  <canvas id="radar"></canvas>
</div>

<aside>
  <div class="section">
    <div class="row"><strong>Selected track</strong></div>
    <div id="selectedInfo" class="aircraftCard small">Tap/click a tag to select; drag tags anywhere (works on mobile).</div>
  </div>

  <div class="section">
    <div class="row"><strong>Vectors</strong></div>
    <div class="row">
      <label for="hdg">Heading</label>
      <input id="hdg" type="number" min="1" max="360" placeholder="1–360">
      <button id="btnHdg">Issue vector</button>
    </div>
    <div class="row small">Standard-rate ≈3°/s, shortest way. (Displays 360, not 000.)</div>
  </div>

  <div class="section">
    <div class="row"><strong>Altitude</strong></div>
    <div class="row">
      <label for="alt">Altitude</label>
      <input id="alt" type="number" step="1" min="0" placeholder="e.g. 150">
      <button id="btnAlt">Climb/Descent</button>
    </div>
    <div class="row">
      <label for="vs">Vertical speed</label>
      <input id="vs" type="number" step="100" placeholder="×100 fpm (default 18)">
      <button id="btnHold">Altitude hold</button>
    </div>
    <div class="row small">
      <label><input id="useFL" type="checkbox" checked> Enter Flight Level (e.g., <b>150</b> for FL150)</label>
      <span id="altModeHint" class="small"></span>
    </div>
  </div>

  <div class="section">
    <div class="row"><strong>Speed</strong></div>
    <div class="row">
      <label for="spd">Speed (kt)</label>
      <input id="spd" type="number" step="5" min="60" placeholder="e.g. 250">
      <button id="btnSpd">Set kt</button>
    </div>
    <div class="row">
      <label for="mach">Mach</label>
      <input id="mach" type="number" step="0.01" min="0.30" max="0.99" placeholder="e.g. 0.78">
      <button id="btnMach">Set M</button>
    </div>
    <div class="row small">Mach converts using ISA a(alt).</div>
  </div>

  <div class="section">
    <div class="row"><strong>Predict vectors</strong></div>
    <div class="row small">
      <label><input type="checkbox" id="pred1" checked> 1 min</label>
      <label><input type="checkbox" id="pred3" checked> 3 min</label>
      <label><input type="checkbox" id="pred5" checked> 5 min</label>
      <label style="margin-left:auto;">Show for
        <select id="predFor"><option value="sel">selected</option><option value="all" selected>all tracks</option></select>
      </label>
    </div>
    <div class="row small">Solid lines only; no labels on scope.</div>
  </div>

  <div class="section">
    <div class="row"><strong>Conflict alerts</strong></div>
    <div class="row small">Minima: <span class="pill">5 NM</span> / <span class="pill">1000 ft</span></div>
    <div class="row">
      <label for="lookahead">Lookahead</label>
      <select id="lookahead"><option value="0">0 min (current)</option><option value="1">1 min</option><option value="2" selected>2 min</option><option value="3">3 min</option></select>
    </div>
    <div class="row small">Red = actual, Amber = predicted within lookahead.</div>
  </div>

  <!-- NEW: Measure tool controls -->
  <div class="section">
    <div class="row"><strong>Measure tool</strong></div>
    <div class="row">
      <button id="clearRulers">Clear rulers</button>
    </div>
    <div class="row small">Shift+LMB = start/finish (snaps to nearest a/c) •
Plain Left Click = place ruler •
Esc = delete last ruler</div>
  </div>

  <div class="section">
    <div class="row"><strong>Altitude filter</strong></div>
    <div class="row">
      <label for="fltMin">Min (ft)</label><input id="fltMin" type="number" step="100" value="0">
      <label for="fltMax">Max (ft)</label><input id="fltMax" type="number" step="100" value="60000">
      <button id="btnFilter">Apply</button>
    </div>
    <div class="row small">Off-band tracks dimmed.</div>
  </div>

  <div class="section">
    <div class="row"><strong>Speed restrictions</strong></div>
    <div class="row small">
      <label><input id="spd250" type="checkbox" checked> 250 kt at/under 10,000 ft</label>
    </div>
  </div>

  <div class="section">
    <div class="row"><strong>Waypoints & Direct-to</strong></div>
    <div class="row">
      <button id="addWpt">Add waypoint</button>
      <button id="clearWpt">Clear wpts</button>
    </div>
    <div id="wptList" class="small"></div>
  </div>

  <div class="section">
    <div class="row"><strong>Sector (rectangular)</strong></div>
    <div class="row small">Rect centered on scope. Handoff triggers when crossing the rectangle boundary.</div>
    <div class="row">
      <label for="rectW">Width (NM)</label><input id="rectW" type="number" value="160">
      <label for="rectH">Height (NM)</label><input id="rectH" type="number" value="120">
      <button id="btnRect">Apply</button>
    </div>
    <div class="row small">
      <label><input id="autoHandoff" type="checkbox" checked> Auto-handoff</label>
      <button id="btnHandoff">Handoff selected</button>
    </div>
  </div>

  <div class="section small">
    <div class="row"><strong>Shortcuts</strong></div>
    <div class="grid2">
      <div><span class="kbd">H</span> vector • <span class="kbd">A</span> altitude • <span class="kbd">S</span> speed • <span class="kbd">M</span> Mach</div>
      <div><span class="kbd">Space</span> pause • <span class="kbd">N</span> spawn • Click scope to add waypoint (when enabled)</div>
    </div>
  </div>
</aside>

<script>
  // ---------- Utilities ----------
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const toRad=d=>d*Math.PI/180; const toDeg=r=>r*180/Math.PI;
  const mod360=d=>(d%360+360)%360;
  const nmPerKtPerSec = 1/3600; const ftPerMinToFtPerSec = 1/60;
  // --- fix pass logic (buffer + trend) ---
const FIX_PASS_NM = 1.2;       // consider a fix 'made' when within this many NM
const FIX_PASS_TREND_NM = 2.0; // or, if we've been closer than this and range starts increasing, also 'made'


  function isaSpeedOfSoundKts(alt_ft){
    const h = Math.max(0, Math.min(86000, alt_ft)) * 0.3048;
    let T; if(h<=11000) T=288.15-0.0065*h; else if(h<=20000) T=216.65; else T=216.65+0.001*(h-20000);
    const a_ms = Math.sqrt(1.4*287.05287*T); return a_ms*1.943844;
  }
  function formatHeading(h){
    let n = Math.round(mod360(h));
    n = n===0 ? 360 : n;
    return String(n).padStart(3,'0');
  }
  function parseAltitudeInput(val, useFL){
    if(val===""||val==null) return null;
    let txt = String(val).trim().toUpperCase();
    if(useFL){
      if(txt.startsWith("FL")) txt = txt.slice(2);
      const fl = parseInt(txt,10);
      if(Number.isFinite(fl)) return fl*100;
      return null;
    }else{
      if(txt.startsWith("FL")){
        const fl=parseInt(txt.slice(2),10); return Number.isFinite(fl)? fl*100:null;
      }
      const ft = parseInt(txt,10); return Number.isFinite(ft)? ft:null;
    }
  }
  function bearingFromTo(x1,y1,x2,y2){
    return mod360(toDeg(Math.atan2(x2-x1, -(y2-y1))));
  }

// signed angle (deg) between two vectors originating at the *same* point
function turnAngleDeg(ax, ay, bx, by){
  const dot  = ax*bx + ay*by;
  const det  = ax*by - ay*bx;          // cross-product z-component
  const ang  = Math.atan2(det, dot);   // −π … +π
  return Math.abs(ang * 180 / Math.PI);
}


  function nextWptName(a, env){
  if(a.navMode==="DIRECT" && a.directWptId) return env.getWaypoint(a.directWptId)?.name || "—";
  if(a.navMode==="ROUTE" && a.routeIdx < a.route.length) return env.getWaypoint(a.route[a.routeIdx])?.name || "—";
  return "—";
}
function fmtFLshort(ft){ return 'FL' + String(Math.round(ft/100)).padStart(3,'0'); }
function fmtCFL(ft){ return 'CFL' + String(Math.round(ft/100)).padStart(3,'0'); }
function fmtVS100(vs_fpm){
  const h = Math.round(vs_fpm/100);
  if (h===0) return "0";
  return (h>0?"+":"−") + Math.abs(h);
}
function parseVsHundreds(txt){
  if (txt==null) return null;
  const n = parseInt(String(txt).trim(),10);
  return Number.isFinite(n) ? n*100 : null;  // “18” -> 1800 fpm
}

function getTrackState(a){
  if (a.inSector){
    return a.hoMarked ? "intruder" : "controlled";
  } else {
    return a.everInRect ? "outbound" : "inbound";
  }
}

  // --- Short Flight Plan (SFP) & helpers ---
const DEP_PORTS = ["EPWA","EPKT","EPPO"];   // tweak later
const ARR_PORTS = ["EDDF","EPWR","EPLL"];   // tweak later
const TYPES     = ["A320","B738","E190","B744","B789"];

const rand = (a,b)=> a + Math.random()*(b-a);
const randi = (a,b)=> Math.floor(rand(a,b+1));
const pick = arr => arr[Math.floor(Math.random()*arr.length)];



function forceMidBetween(entryId, exitId){
  // Try the gentle picker first
  let mid = pickGentleMidFix(entryId, exitId, 40, 50);
  if (mid) return mid;

  // Fallback 1: closest-to-segment dynamic waypoint (keeps it reasonable)
  const A = getWPById(entryId), B = getWPById(exitId);
  if (A && B && wpts.length){
    const dx = B.x_nm - A.x_nm, dy = B.y_nm - A.y_nm, len2 = dx*dx + dy*dy;
    if (len2 > 1e-6){
      let best=null, bestOff=Infinity;
      for (const w of wpts){
        const t = ((w.x_nm - A.x_nm)*dx + (w.y_nm - A.y_nm)*dy) / len2;
        if (t <= 0 || t >= 1) continue; // avoid extremes
        const px = A.x_nm + t*dx, py = A.y_nm + t*dy;
        const off = Math.hypot(w.x_nm - px, w.y_nm - py);
        if (off < bestOff){ bestOff = off; best = w.id; }
      }
      if (best != null) return best;
    }
  }

  


  // Fallback 2: nearest-to-center dynamic waypoint
  if (wpts.length){
    return wpts.reduce((b,w)=>{
      const d = Math.hypot(w.x_nm,w.y_nm);
      return d < b.d ? {id:w.id,d} : b;
    }, {id:null,d:Infinity}).id;
  }
  return null;
}


 function findNearestAcPx(xPx, yPx, tolPx=16){
  let best=null, bestD=Infinity;
  for(const a of state.ac){
    const ax = cx + nmToPx(a.x_nm);
    const ay = cy + nmToPx(a.y_nm);
    const d = Math.hypot(ax - xPx, ay - yPx);
    if(d < bestD){ bestD = d; best = a; }
  }
  return bestD <= tolPx ? best : null;
}

function resolveEndpoint(ep){
  if(!ep) return null;
  if(ep.type === 'ac'){
    const ac = state.ac.find(a=>a.id===ep.id);
    if(!ac) return null; // a/c may have been cleared
    return { x_nm: ac.x_nm, y_nm: ac.y_nm };
  }
  // point endpoint
  if('x_nm' in ep && 'y_nm' in ep) return { x_nm: ep.x_nm, y_nm: ep.y_nm };
  return null;
}


  // ---------- Aircraft ----------
  let nextId=1;
  function genCallsign(){
    const ops=["LOT","DLH","BAW","RYR","WZZ","KLM","AFR","AUA","SAS","UAE","QTR","IBE"];
    return ops[Math.floor(Math.random()*ops.length)]+String(Math.floor(100+Math.random()*899));
  }

  class Aircraft{
    constructor(opts){
      this.id=nextId++; this.cs=opts.cs||genCallsign();
      this.x_nm=opts.x_nm??0; this.y_nm=opts.y_nm??0;
      this.hdg=opts.hdg??Math.floor(Math.random()*360);
      this.alt_ft=opts.alt_ft??(30000);
      this.spd_kt=opts.spd_kt??(this.alt_ft>24000?450:250);
      this.fp = opts.fp ?? null;   // Short Flight Plan (dep, dest, cruiseFL, tasKt, type)
      this.type = opts.type ?? pick(TYPES);   // <-- new: default a random type
      this.route = [];         // array of waypoint ids
      this.routeIdx = 0;       // current active leg target index



      // Dotted trail: last 5 positions max
      this.trail=[]; this.trailMax=5;

      // Targets
      this.tgtHdg=this.hdg; this.tgtAlt=this.alt_ft;
      this.vs_fpm=0; this.defaultVS=1800;
      this.tgtSpeedMode="KT"; this.tgtSpd_kt=this.spd_kt; this.tgtMach=null;

      // Dynamics
      this.turnRateDps=3; this.accel_ktps=1.0; this.maxVS_fps=4000*ftPerMinToFtPerSec;

      // Nav
      this.navMode=null; this.directWptId=null;
          this.route = [];        // array of waypoint ids
    this.routeIdx = 0;      // which fix we’re heading to now
    // pass logic helpers
this.prevDistToTarget = null; // last range to active fix
this.lastNavTargetId   = null; // which fix that range belonged to



      // Label offsets
      this.labelDx=12; this.labelDy=-16;
      // Visibility/despawn bookkeeping
this.seenOnScreenOnce = false;
this.spawnSec = (typeof simNowSec !== 'undefined') ? simNowSec : 0;


      // Rect sector state
      this.inSector = true; this.handoffPending=false; this.pendingState=null; 
      // coloring / state bookkeeping
this.everInRect = env.inRect(this.x_nm, this.y_nm); // ever been inside?
this.hoMarked   = false;                             // we marked H/O manually

    }
    setHeading(h){ this.navMode=null; this.directWptId=null; this.tgtHdg=mod360(h); }
    setAltitude(alt_ft,vs=null){ this.tgtAlt=Math.max(0,Math.round(alt_ft));
      const sign=this.tgtAlt>this.alt_ft?1:-1; const mag=Math.max(0,Math.abs(vs??this.defaultVS)); this.vs_fpm=sign*mag; }
    holdAltitude(){ this.tgtAlt=this.alt_ft; this.vs_fpm=0; }
    setSpeedKt(kt){ this.tgtSpeedMode="KT"; this.tgtSpd_kt=Math.max(60,kt|0); this.tgtMach=null; }
    setMach(m){ this.tgtSpeedMode="MACH"; this.tgtMach=clamp(m,0.3,0.99); }
    directTo(id){ this.navMode="DIRECT"; this.directWptId=id; }
    get mach(){ return this.spd_kt/isaSpeedOfSoundKts(this.alt_ft); }
      setRoute(ids){
    this.route = Array.isArray(ids) ? ids.slice() : [];
    this.routeIdx = 0;
    this.navMode = this.route.length ? "ROUTE" : null;
    this.directWptId = null; // clear direct if switching
  }


    update(dt, env){
      if(this.tgtSpeedMode==="MACH" && this.tgtMach) this.tgtSpd_kt=this.tgtMach*isaSpeedOfSoundKts(this.alt_ft);
      let targetSpd=this.tgtSpd_kt;
      if(env.restrict250 && this.alt_ft<=10000) targetSpd=Math.min(targetSpd,250);

      // --- DIRECT-to nav ---
if (this.navMode==="DIRECT" && this.directWptId!=null){
  const w = env.getWaypoint(this.directWptId);
  if (w){
    const hdgTo = mod360(toDeg(Math.atan2(w.x_nm-this.x_nm, -(w.y_nm-this.y_nm))));
    this.tgtHdg = hdgTo;
    const dist = Math.hypot(w.x_nm-this.x_nm, w.y_nm-this.y_nm);

    // trend detection (reset if target changes)
    if (this.lastNavTargetId !== this.directWptId) this.prevDistToTarget = null;

    const passed =
      dist < FIX_PASS_NM ||
      (this.prevDistToTarget != null &&
       this.prevDistToTarget < FIX_PASS_TREND_NM &&
       dist > this.prevDistToTarget);

    if (passed){
      // Try to rejoin FPL after this fix
      const idxInRoute = Array.isArray(this.route) ? this.route.indexOf(this.directWptId) : -1;
      this.directWptId = null;

      if (idxInRoute >= 0 && idxInRoute + 1 < this.route.length){
        this.routeIdx = idxInRoute + 1;
        this.navMode = "ROUTE";
      } else {
        // No FPL/no next fix → continue present heading
        this.navMode = null;
        this.tgtHdg = this.hdg;
      }
      this.prevDistToTarget = null;
      this.lastNavTargetId  = null;
    } else {
      this.lastNavTargetId  = this.directWptId;
      this.prevDistToTarget = dist;
    }
  } else {
    // waypoint missing → cancel DIR and hold current
    this.directWptId = null;
    this.navMode = null;
    this.tgtHdg = this.hdg;
    this.prevDistToTarget = null;
    this.lastNavTargetId = null;
  }
}

// --- ROUTE nav: fly fix-to-fix, same pass logic ---
if (this.navMode==="ROUTE" && this.routeIdx < this.route.length){
  const targetId = this.route[this.routeIdx];
  const w = env.getWaypoint(targetId);
  if (w){
    const hdgTo = mod360(toDeg(Math.atan2(w.x_nm-this.x_nm, -(w.y_nm-this.y_nm))));
    this.tgtHdg = hdgTo;
    const dist = Math.hypot(w.x_nm-this.x_nm, w.y_nm-this.y_nm);

    if (this.lastNavTargetId !== targetId) this.prevDistToTarget = null;

    const passed =
      dist < FIX_PASS_NM ||
      (this.prevDistToTarget != null &&
       this.prevDistToTarget < FIX_PASS_TREND_NM &&
       dist > this.prevDistToTarget);

    if (passed){
      this.routeIdx++;
      this.prevDistToTarget = null;
      this.lastNavTargetId  = null;

      if (this.routeIdx >= this.route.length){
        this.navMode = null;   // route complete → continue present heading
        this.tgtHdg = this.hdg;
      }
    } else {
      this.lastNavTargetId  = targetId;
      this.prevDistToTarget = dist;
    }
  } else {
    // target vanished → drop to present heading
    this.navMode = null;
    this.tgtHdg = this.hdg;
    this.prevDistToTarget = null;
    this.lastNavTargetId = null;
  }
}



      let diff = mod360(this.tgtHdg-this.hdg); if(diff>180) diff-=360;
      const maxTurn=this.turnRateDps*dt; if(Math.abs(diff)<maxTurn) this.hdg=this.tgtHdg; else this.hdg=mod360(this.hdg+Math.sign(diff)*maxTurn);

      const dSpd=targetSpd-this.spd_kt; const maxAcc=this.accel_ktps*dt;
      if(Math.abs(dSpd)<maxAcc) this.spd_kt=targetSpd; else this.spd_kt+=Math.sign(dSpd)*maxAcc;

      if(this.alt_ft!==this.tgtAlt){
        let vs_fps=this.vs_fpm*ftPerMinToFtPerSec; const delta=this.tgtAlt-this.alt_ft;
        if(Math.abs(delta)<600){ const s=Math.sign(delta); vs_fps=s*Math.min(Math.abs(vs_fps),800*ftPerMinToFtPerSec); }
        vs_fps=clamp(vs_fps,-this.maxVS_fps,this.maxVS_fps);
        const step=vs_fps*dt;
        if(Math.sign(delta)!==Math.sign(step)||Math.abs(step)>Math.abs(delta)){ this.alt_ft=this.tgtAlt; this.vs_fpm=0; }
        else this.alt_ft+=step;
      }

      const dist_nm=this.spd_kt*nmPerKtPerSec*dt;
      this.x_nm += Math.sin(toRad(this.hdg))*dist_nm;
      this.y_nm += -Math.cos(toRad(this.hdg))*dist_nm;

      // Sector (rectangle)
const inside = env.inRect(this.x_nm, this.y_nm);
if (inside) this.everInRect = true;

if (inside !== this.inSector) {
  const leftSector = this.inSector && !inside; // just crossed OUT
  if (env.autoHandoff) {
    this.inSector = inside;
    this.handoffPending = false;
    this.pendingState = null;
  } else {
    this.handoffPending = true;
    this.pendingState = inside;
  }
  if (leftSector) {
    // leaving sector: stop any nav guidance and keep current track
    this.navMode = null;
    this.directWptId = null;
    this.tgtHdg = this.hdg; // hold present heading
  }
}

      // Dotted trail (every step call adds one); keep only last 5
      this.trail.push({x:this.x_nm,y:this.y_nm});
      if(this.trail.length>this.trailMax) this.trail.shift();
    }
  }

 // ---------- World / Sim ----------
const canvas=document.getElementById('radar'); const ctx=canvas.getContext('2d');
const wrap=document.getElementById('radarWrap');
let W=0,H=0,cx=0,cy=0;
// Center shift in **pixels** ( +x = push content right, -y = push content up )
const CENTER_SHIFT = { x: -90, y: 60 };  // tweak to taste

let booted = false;

function resize(){
  const r=wrap.getBoundingClientRect();
  canvas.width=r.width; canvas.height=r.height;
  W=canvas.width; H=canvas.height;
cx = W/2 + CENTER_SHIFT.x;
cy = H/2 + CENTER_SHIFT.y;

  if (booted) drawAll(); // only redraw after full boot
}
window.addEventListener('resize', resize);

  let rangeNM=80; function nmToPx(nm){ return nm*(Math.min(W,H)/2)/rangeNM; }
  function pxToNm(xPx,yPx){ return { x_nm:(xPx-cx)*rangeNM/(Math.min(W,H)/2), y_nm:(yPx-cy)*rangeNM/(Math.min(W,H)/2) }; }
  function isOnScreenPx(x_px, y_px, marginPx=24){
  return x_px >= -marginPx && x_px <= W + marginPx &&
         y_px >= -marginPx && y_px <= H + marginPx;
}
function acIsOnScreen(a, marginPx=24){
  const x = cx + nmToPx(a.x_nm);
  const y = cy + nmToPx(a.y_nm);
  return isOnScreenPx(x, y, marginPx);
}

function acInScopeNm(a, marginNm=0){
  // inside the circular scope radius + margin
  return Math.hypot(a.x_nm, a.y_nm) <= (rangeNM + marginNm);
}

// ===== NEW sector polygon (nm, centered at 0,0) =====
const SECTOR_POLY = [
  [-75.42, -26.46],
  [30.31, -38.83],
  [29.17, -96.40],
  [108.72, -81.29],
  [128.23, -60.85],
  [125.98, -24.29],
  [84.27, -2.74],
  [46.48, 41.59],
  [46.07, 64.62],
  [41.86, 66.49],
  [39.82, 67.02],
  [26.74, 57.32],
  [33.13, 53.43],
  [31.66, 50.17],
  [19.74, 51.18],
  [-1.33, 40.22],
  [5.12, 49.33],
  [-7.41, 60.37],
  [-27.20, 39.93],
  [-17.12, 30.91],
  [-25.49, 25.85],
  [-33.91, 29.46],
  [-41.71, 20.33],
  [-58.07, 16.85],
  [-60.59, 7.22],
  [-68.56, 4.46],
  [-71.54, 3.90],
  [-72.00, 12.43],
  [-78.09, 11.85],
  [-69.54, -12.75],
  [-71.55, -16.96],
  [-72.05, -24.28],
];

// point-in-polygon (ray casting)
function pointInPoly(x, y, poly){
  let inside = false;
  for (let i=0, j=poly.length-1; i<poly.length; j=i++){
    const [xi, yi] = poly[i], [xj, yj] = poly[j];
    const intersect = ((yi>y)!=(yj>y)) && (x < (xj-xi)*(y-yi)/(yj-yi) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}

// bounding box (for legacy rect-based spawn math)
const SECTOR_BBOX = (() => {
  const xs = SECTOR_POLY.map(p=>p[0]), ys = SECTOR_POLY.map(p=>p[1]);
  const minX = Math.min(...xs), maxX = Math.max(...xs);
  const minY = Math.min(...ys), maxY = Math.max(...ys);
  return {minX,maxX,minY,maxY, width:maxX-minX, height:maxY-minY};
})();


  const env = {
  restrict250:true, autoHandoff:true,
  // keep rectW/H for legacy UI/spawn but derive from polygon bbox
  rectW: SECTOR_BBOX.width,
  rectH: SECTOR_BBOX.height,
  getWaypoint: id => getWPById(id),
  inRect: (x_nm, y_nm) => pointInPoly(x_nm, y_nm, SECTOR_POLY)
};


  const state = {
    ac:[], selectedId:null, paused:false,
    simSpeed:1,
    filterMin:0, filterMax:60000,
    pred1:true, pred3:true, pred5:true, predFor:"all",
    lookaheadMin:2,
    conflictsNow:[], conflictsPred:[],
    addingWpt:false,
    refreshSec:3,
    measure:null,        // active ruler being drawn {fromX_nm,fromY_nm,toX_nm,toY_nm}
    measures:[],          // committed rulers
    editing:null,          // {id, field} e.g. {id: 3, field:'hdg'|'spd'|'mach'|'vs'|'cfl'}
    routePreviewId : null,    // ⇐ NEW – id of a/c to highlight
    

  };
  function getSelected(){ return state.ac.find(a=>a.id===state.selectedId)||null; }
  // --- Sim clock (seconds) ---
let simNowSec = 0;


  // Waypoints
  let wptNext=1; const wpts=[];
  // ---- Random waypoint naming + min-spacing placement ----
const WPT_MIN_SPACING_NM = 15;     // tweak to taste
const WPT_TRIES_PER_POINT = 350;  // how hard we try per waypoint

function randWptName(){
  const vowels = "AEIOU";
  const cons   = "BCDFGHJKLMNPQRSTVWXYZ";
  // Make it feel "airway-ish": CVCVC or CVCCV with a dash of weirdness
  const pat = Math.random() < 0.5 ? "CVCVC" : "CVCCV";
  const pick = (s)=> s[Math.floor(Math.random()*s.length)];
  let out = "";
  for (const c of pat){
    out += (c==="C") ? pick(cons) : pick(vowels);
  }
  // ~15% chance to flip one letter to make it quirky
  if (Math.random() < 0.15){
    const i = Math.floor(Math.random()*out.length);
    const pool = Math.random()<0.5?vowels:cons;
    out = out.slice(0,i) + pick(pool) + out.slice(i+1);
  }
  return out;
}

function addWaypointNamedAt(name, x_nm, y_nm){
  const id = wptNext++;
  const w = { id, name, x_nm, y_nm };
  wpts.push(w);
  return w;
}

/** Place N random waypoints inside the current rectangular sector
 *  with at least WPT_MIN_SPACING_NM separation.
 */
function seedRandomWaypoints(count){
  const halfW = env.rectW/2, halfH = env.rectH/2;
  for (let k=0; k<count; k++){
    let placed = false;
    let tries = 0;
    let spacing = WPT_MIN_SPACING_NM;

    while(!placed && tries < WPT_TRIES_PER_POINT){
      tries++;
      const x = (Math.random()*2 - 1) * (halfW * 0.95);
      const y = (Math.random()*2 - 1) * (halfH * 0.95);

      // inside rect (belt-and-suspenders)
      if (!env.inRect(x,y)) continue;

      // distance check vs all existing waypoints
      let ok = true;
      for (const w of wpts){
        const d = Math.hypot(x - w.x_nm, y - w.y_nm);
        if (d < spacing){ ok = false; break; }
      }
      if (!ok) {
        // After many misses, ease spacing a bit so we don’t stall
        if (tries % 50 === 0) spacing *= 0.9;
        continue;
      }

      addWaypointNamedAt(randWptName(), x, y);
      placed = true;
    }
  }
  renderWptList();
  drawAll();
}

  function addWaypointAt(x_nm,y_nm){ const id=wptNext++; const w={id,name:"WPT"+id,x_nm,y_nm}; wpts.push(w); renderWptList(); drawAll(); }
  function clearWaypoints(){ wpts.length=0; renderWptList(); drawAll(); }
  function renderWptList(){
    const box=document.getElementById('wptList');
    if(wpts.length===0){ box.innerHTML='<div class="small">No waypoints.</div>'; return; }
    box.innerHTML=wpts.map(w=>`
      <div style="display:flex;align-items:center;gap:8px;margin:4px 0;">
        <span class="pill">${w.name}</span>
        <button data-w="${w.id}" class="btnDirect small">Direct-to</button>
      </div>`).join("");
    for(const btn of box.querySelectorAll('.btnDirect')){
      btn.addEventListener('click', e=>{
        const id=parseInt(e.target.getAttribute('data-w'),10);
        const sel=getSelected(); if(!sel){ alert("Select a track first."); return; }
        sel.directTo(id); updateSelectedPanel(); drawAll();
      });
    }
  }
  function fmtFL(flFt){ return 'FL' + String(Math.round(flFt/100)).padStart(3,'0'); }
function fmtTas(kt){ return (kt|0) + " kt"; }

function ensureSfpWin(){
  let el = document.querySelector('.sfpWin');
  if(el) return el;

  el = document.createElement('div');
  el.className = 'sfpWin';
  el.innerHTML = `
    <div class="hdr">
      <div class="title">Short Flight Plan</div>
      <div><button class="btnSfpClose">Close</button></div>
    </div>
    <div class="body"></div>
  `;
  document.getElementById('radarWrap').appendChild(el);
  const closeBtn = el.querySelector('.btnSfpClose');
closeBtn.addEventListener('pointerdown', e=>{ e.stopPropagation(); });
closeBtn.addEventListener('click', closeSFP);


  // Dragging by header — LEFT BUTTON ONLY; capture on the SAME node we listen on
  const hdr = el.querySelector('.hdr');
  let dragging=false, sx=0, sy=0, startLeft=0, startTop=0;

  function endDrag(ev){
    if(!dragging) return;
    dragging=false;
    el.classList.remove('is-dragging');
    try{ hdr.releasePointerCapture(ev.pointerId);}catch{}
  }

  hdr.addEventListener('pointerdown', ev=>{
    if (ev.button !== 0) return;                 // left button only
    if (ev.target.closest('button')) return;
    dragging = true;
    hdr.setPointerCapture(ev.pointerId);         // <-- capture on hdr (not el)
    const r  = el.getBoundingClientRect();
    const wr = document.getElementById('radarWrap').getBoundingClientRect();
    startLeft = r.left - wr.left;
    startTop  = r.top  - wr.top;
    sx = ev.clientX; sy = ev.clientY;
    el.classList.add('is-dragging');
    ev.preventDefault();
    ev.stopPropagation();
  });

  hdr.addEventListener('pointermove', ev=>{
    if(!dragging) return;
    // If LMB is no longer down (missed pointerup), drop the drag.
    if ((ev.buttons & 1) === 0) { endDrag(ev); return; }
    const dx = ev.clientX - sx, dy = ev.clientY - sy;
    el.style.left = (startLeft + dx) + 'px';
    el.style.top  = (startTop  + dy) + 'px';
    el.style.right = 'auto';
  });

  hdr.addEventListener('pointerup', endDrag);
  hdr.addEventListener('pointercancel', endDrag);
  hdr.addEventListener('lostpointercapture', ()=>{ dragging=false; el.classList.remove('is-dragging'); });

  return el;
}




function renderSFP(ac){
  const el = ensureSfpWin();
  const body = el.querySelector('.body');
  if(!ac || !ac.fp){
    body.innerHTML = `<div class="small" style="color:#9fb3c1">No SFP for this aircraft.</div>`;
    return;
  }
  const fp = ac.fp;
  const routeNames = (ac.route||[]).map(id => (env.getWaypoint(id)?.name || String(id)));
  body.innerHTML = `
    <table>
      <tr><td class="key">Callsign</td><td>${ac.cs}</td></tr>
      <tr><td class="key">Type</td><td>${fp.type || ac.type || '—'}</td></tr>
      <tr><td class="key">From</td><td>${fp.dep || '—'}</td></tr>
      <tr><td class="key">To</td><td>${fp.dest || '—'}</td></tr>
      <tr><td class="key">Cruise</td><td>${fmtFL(fp.cruiseFL*100)}</td></tr>
      <tr><td class="key">TAS</td><td>${fmtTas(fp.tasKt||ac.spd_kt)}</td></tr>
    </table>
    <div class="route"><span style="color:#9fb3c1">Route:</span> ${
      routeNames.length ? routeNames.join(' → ') : '—'
    }</div>
  `;
  // keep it on-screen if window is small
  const r = el.getBoundingClientRect(), wrapR = document.getElementById('radarWrap').getBoundingClientRect();
  if(r.right > wrapR.right) el.style.right = '12px';
  if(r.top < wrapR.top) el.style.top = '64px';
}

function openSFP(ac){ renderSFP(ac); }
function closeSFP(){
  const el = document.querySelector('.sfpWin');
  if(el) el.remove();
}

  
  // ===== Random waypoints inside sector + faint airways =====
let airways = []; // pairs of waypoint ids to draw lines between

const FUN_FIXES = [
  "YEETR","BORKD","LOLNO","NOMMY","PIZZA","SAUCE","ZAPPY","FIZZY","BANJO","NINJA",
  "TANGO","NACHO","BAGEL","WAFFL","DONUT","BINGO","CHILL","HAPPY","GRUMP","ZORRO",
  "BEEFY","NOODS","SPICY","MUNCH","CRONK","GOOFY","SNEKD","WHAAA","YUMMY","BUBBL"
];
const VOWELS = ["A","E","I","O","U","Y"];
const CONS   = ["B","C","D","F","G","H","J","K","L","M","N","P","Q","R","S","T","V","W","X","Z"];
const usedFixNames = new Set();

function genFunnyFixName(){
  // prefer from list without reusing
  const candidates = FUN_FIXES.filter(n => !usedFixNames.has(n));
  if (candidates.length){
    const n = candidates[Math.floor(Math.random()*candidates.length)];
    usedFixNames.add(n);
    return n;
  }
  // fallback: make something pronounceable(ish) CCVCV
  const pick = arr => arr[Math.floor(Math.random()*arr.length)];
  const name = (pick(CONS)+pick(CONS)+pick(VOWELS)+pick(CONS)+pick(VOWELS)).toUpperCase();
  usedFixNames.add(name);
  return name;
}

// Seed N random waypoints inside current rectangular sector
function seedWaypointsInside(count=16, minSepNm=5){
  const halfW = env.rectW/2, halfH = env.rectH/2;
  const margin = 4; // keep a little away from the edge

  function tooClose(x_nm,y_nm){
    return wpts.some(w => Math.hypot(w.x_nm - x_nm, w.y_nm - y_nm) < minSepNm);
  }

  for(let i=0;i<count;i++){
    let tries=0, x=0, y=0;
    do{
      x = (Math.random()*2-1) * (halfW - margin);
      y = (Math.random()*2-1) * (halfH - margin);
      tries++;
    } while(tries<40 && tooClose(x,y));

    const id = wptNext++;
    const w = { id, name: genFunnyFixName(), x_nm:x, y_nm:y };
    wpts.push(w);
  }
  renderWptList();
}

// Build “airways” by connecting each waypoint to its k nearest neighbors
function buildAirways(k=2){
  const pts = [...WP_ALL, ...wpts];
  const uniq = new Set(); // "min-max" id keys
  for(const a of pts){
    const dists = [];
    for(const b of pts){
      if (a.id===b.id) continue;
      dists.push([b.id, Math.hypot(a.x_nm-b.x_nm, a.y_nm-b.y_nm)]);
    }
    dists.sort((p,q)=>p[1]-q[1]);
    for(let i=0;i<Math.min(k,dists.length);i++){
      const bId = dists[i][0];
      const key = a.id < bId ? `${a.id}-${bId}` : `${bId}-${a.id}`;
      uniq.add(key);
    }
  }
  airways = Array.from(uniq).map(s => s.split('-').map(n=>parseInt(n,10)));
}


  
  // ==== REPLACED: static waypoints (only new list; no CTR) ====
const WP = {};
Object.assign(WP, {
  NAROX: { id:3000, name:"NAROX", x_nm:-71.06, y_nm:-8.69 },
  LASIS: { id:3001, name:"LASIS", x_nm:-71.80, y_nm:-20.75 },
  DIMEX: { id:3002, name:"DIMEX", x_nm:-27.71, y_nm:-32.13 },
  XIDNA: { id:3003, name:"XIDNA", x_nm:5.23, y_nm:-36.00 },
  BESTO: { id:3004, name:"BESTO", x_nm:20.00, y_nm:-37.67 },
  BADNO: { id:3005, name:"BADNO", x_nm:30.17, y_nm:-38.83 },
  BADUP: { id:3006, name:"BADUP", x_nm:21.21, y_nm:-57.30 },
  DIPKI: { id:3007, name:"DIPKI", x_nm:22.48, y_nm:-65.83 },
  TENVO: { id:3008, name:"TENVO", x_nm:34.27, y_nm:-67.52 },
  MASIV: { id:3009, name:"MASIV", x_nm:37.17, y_nm:-54.50 },
  INDIG: { id:3010, name:"INDIG", x_nm:42.58, y_nm:-53.51 },
  OBOKU: { id:3011, name:"OBOKU", x_nm:42.68, y_nm:-68.68 },
  MOLIL: { id:3012, name:"MOLIL", x_nm:42.94, y_nm:-89.00 },
  ERPAB: { id:3013, name:"ERPAB", x_nm:54.47, y_nm:-91.77 },
  PENEX: { id:3014, name:"PENEX", x_nm:89.66, y_nm:-87.50 },
  VAVEK: { id:3015, name:"VAVEK", x_nm:86.86, y_nm:-95.37 },
  BIMPA: { id:3016, name:"BIMPA", x_nm:107.88, y_nm:-76.82 },
  GODIL: { id:3017, name:"GODIL", x_nm:124.42, y_nm:-79.70 },
  WAR: { id:3018, name:"WAR", x_nm:139.80, y_nm:-70.26 },
  LOLSI: { id:3019, name:"LOLSI", x_nm:111.60, y_nm:-65.56 },
  SOXER: { id:3020, name:"SOXER", x_nm:114.26, y_nm:-56.74 },
  AGAVA: { id:3021, name:"AGAVA", x_nm:115.99, y_nm:-29.23 },
  NUBLI: { id:3022, name:"NUBLI", x_nm:112.66, y_nm:-17.47 },
  MAKOV: { id:3023, name:"MAKOV", x_nm:84.27, y_nm:-2.74 },
  BAREX: { id:3024, name:"BAREX", x_nm:70.62, y_nm:13.43 },
  SUDOL: { id:3025, name:"SUDOL", x_nm:58.08, y_nm:27.58 },
  MAPIK: { id:3026, name:"MAPIK", x_nm:51.80, y_nm:35.26 },
  NUMBA: { id:3027, name:"NUMBA", x_nm:46.46, y_nm:44.30 },
  REGLI: { id:3028, name:"REGLI", x_nm:42.27, y_nm:65.95 },
  AMTEK: { id:3029, name:"AMTEK", x_nm:40.50, y_nm:66.89 },
  DESEN: { id:3030, name:"DESEN", x_nm:23.40, y_nm:50.66 },
  LAGAR: { id:3031, name:"LAGAR", x_nm:-58.07, y_nm:16.71 },
  TOMTI: { id:3032, name:"TOMTI", x_nm:-60.59, y_nm:6.95 },
  RASAN: { id:3033, name:"RASAN", x_nm:-68.56, y_nm:4.32 },
  OKX: { id:3034, name:"OKX", x_nm:-70.49, y_nm:9.46 },
  GOLOP: { id:3035, name:"GOLOP", x_nm:-92.69, y_nm:28.96 },
  PR532: { id:3036, name:"PR532", x_nm:-88.89, y_nm:50.12 },
  LKPR: { id:3037, name:"LKPR", x_nm:-102.88, y_nm:56.94 },
  EPWR: { id:3038, name:"EPWR", x_nm:-0.13, y_nm:-0.14 },
  WR603: { id:3039, name:"WR603", x_nm:15.13, y_nm:7.00 },
  LATAG: { id:3040, name:"LATAG", x_nm:-41.62, y_nm:-38.18 },
  AKAPI: { id:3041, name:"AKAPI", x_nm:-14.60, y_nm:-49.39 },
  CZE: { id:3042, name:"CZE", x_nm:-4.77, y_nm:-62.06 },
  OBOLA: { id:3043, name:"OBOLA", x_nm:-23.84, y_nm:-66.51 },
  KELOD: { id:3044, name:"KELOD", x_nm:-35.61, y_nm:-69.02 },
  BAREP: { id:3045, name:"BAREP", x_nm:-47.65, y_nm:-71.54 },
  JED: { id:3046, name:"JED", x_nm:128.24, y_nm:26.78 },
  EPPO: { id:3047, name:"EPPO", x_nm:-1.14, y_nm:-79.24 },
  KORUP: { id:3048, name:"KORUP", x_nm:-80.00, y_nm:-31.23 },
  GOVEN: { id:3049, name:"GOVEN", x_nm:-78.06, y_nm:-59.53 },
  SUI: { id:3050, name:"SUI", x_nm:-83.63, y_nm:-79.47 },
  PEVUM: { id:3051, name:"PEVUM", x_nm:67.08, y_nm:-71.92 },
  AMUTO: { id:3052, name:"AMUTO", x_nm:77.52, y_nm:-73.48 },
  DOSIX: { id:3053, name:"DOSIX", x_nm:87.68, y_nm:-74.78 },
  LDZ: { id:3054, name:"LDZ", x_nm:104.01, y_nm:-42.17 },
  ABAKU: { id:3055, name:"ABAKU", x_nm:82.42, y_nm:-34.17 },
  BAXIS: { id:3056, name:"BAXIS", x_nm:74.89, y_nm:-41.94 },
  UTOLU: { id:3057, name:"UTOLU", x_nm:74.78, y_nm:-47.22 },
  OKENO: { id:3058, name:"OKENO", x_nm:64.51, y_nm:-27.78 },
  BAGAP: { id:3059, name:"BAGAP", x_nm:108.41, y_nm:-30.09 },
  VALUD: { id:3060, name:"VALUD", x_nm:99.89, y_nm:-54.93 },
  EPWA: { id:3061, name:"EPWA", x_nm:161.31, y_nm:-65.25 },
  EPMO: { id:3062, name:"EPMO", x_nm:140.01, y_nm:-81.91 },
  EPKT: { id:3063, name:"EPKT", x_nm:83.47, y_nm:38.30 },
  EPKK: { id:3064, name:"EPKK", x_nm:111.24, y_nm:61.49 },
  UVIVI: { id:3065, name:"UVIVI", x_nm:38.23, y_nm:-28.62 },
  LUNUK: { id:3066, name:"LUNUK", x_nm:44.55, y_nm:-20.72 },
  VAGSA: { id:3067, name:"VAGSA", x_nm:25.82, y_nm:-13.52 },
  DEVEG: { id:3068, name:"DEVEG", x_nm:22.94, y_nm:14.50 },
  SABAB: { id:3069, name:"SABAB", x_nm:38.75, y_nm:20.42 },
  EPOPA: { id:3070, name:"EPOPA", x_nm:34.40, y_nm:44.50 },
  PEKOT: { id:3071, name:"PEKOT", x_nm:20.73, y_nm:43.60 },
  DINOV: { id:3072, name:"DINOV", x_nm:-30.14, y_nm:11.87 },
  EKSEK: { id:3073, name:"EKSEK", x_nm:-49.15, y_nm:-3.01 },
  NUPLU: { id:3074, name:"NUPLU", x_nm:-33.17, y_nm:-2.77 },
  LUXAR: { id:3075, name:"LUXAR", x_nm:144.83, y_nm:60.88 },
  NUDRO: { id:3076, name:"NUDRO", x_nm:17.22, y_nm:-2.88 },
  TRZ: { id:3077, name:"TRZ", x_nm:8.74, y_nm:-12.27 },
  VELAB: { id:3078, name:"VELAB", x_nm:-4.47, y_nm:-21.70 },
  ARMEX: { id:3079, name:"ARMEX", x_nm:9.49, y_nm:-23.37 },
  AGALU: { id:3080, name:"AGALU", x_nm:19.23, y_nm:-21.69 },
  RASUT: { id:3081, name:"RASUT", x_nm:-23.55, y_nm:-2.72 },
  ROTOL: { id:3082, name:"ROTOL", x_nm:-22.67, y_nm:7.72 },
  ETNEL: { id:3083, name:"ETNEL", x_nm:10.33, y_nm:15.77 },
  GOBAX: { id:3084, name:"GOBAX", x_nm:-113.88, y_nm:-27.51 },
  OKG: { id:3085, name:"OKG", x_nm:-127.39, y_nm:33.49 },
  MIKOV: { id:3086, name:"MIKOV", x_nm:0.58, y_nm:105.43 },
  VALPI: { id:3087, name:"VALPI", x_nm:51.82, y_nm:95.57 },
  GRU: { id:3088, name:"GRU", x_nm:72.85, y_nm:-130.19 },
  ETUBO: { id:3089, name:"ETUBO", x_nm:195.19, y_nm:-68.21 },
  CHO: { id:3090, name:"CHO", x_nm:-42.82, y_nm:-108.62 },
  LEGNO: { id:3091, name:"LEGNO", x_nm:200.88, y_nm:-12.01 },
  EPLL: { id:3092, name:"EPLL", x_nm:94.91, y_nm:-37.48 },
  MISKA: { id:3093, name:"MISKA", x_nm:2.20, y_nm:-4.86 },
});

// Rebuild WP_ALL and edge-gate list
const WP_ALL = Object.values(WP);




// helper
function getWPById(id){
  // prefer dynamic wpts the user added, then static catalog
  return wpts.find(w=>w.id===id) || WP_ALL.find(w=>w.id===id) || null;
}

function setEditing(field){
  const sel = getSelected();
  state.editing = sel ? { id: sel.id, field } : null;
  layoutTags(); drawLeaders(); // quick visual refresh
}
function clearEditing(field){
  if (!state.editing) return;
  if (!field || state.editing.field === field) {
    state.editing = null;
    layoutTags(); drawLeaders();
  }
}

// lookup by name (static + dynamic), case-insensitive
function findFixByName(name){
  const nm = String(name||"").trim().toUpperCase();
  if (!nm) return null;
  return wpts.find(w=>w.name.toUpperCase()===nm)
      || WP_ALL.find(w=>w.name.toUpperCase()===nm)
      || null;
}

// === HARD-CODED ROUTES (parsed from human-friendly list) ===================
// Paste your list verbatim in ROUTE_TEXT. Parser will do the rest.
const ROUTE_TEXT = `
EPWA dep: (climbing fl240)
WAR LOLSI INDIG MASIV BADUP CZE OBOLA KELOD BAREP SUI
WAR SOXER BAXIS UVIVI AGALU NUPLU TOMTI OKX OKG

EPWA arr:
SUI BAREP KELOD OBOLA CZE DIPKI TENVO OBOKU PEVUM AMUTO DOSIX BIMPA GODIL WAR
GOBAX KORUP LATAG AKAPI CZE DIPKI TENVO OBOKU PEVUM AMUTO DOSIX BIMPA GODIL WAR
LAGAR VAGSA LUNUK OKENO AGAVA WAR

EPMO dep: (climbing fl240)
GODIL LOLSI INDIG MASIV BADUP CZE OBOLA KELOD BAREP SUI
GODIL SOXER BAXIS UVIVI AGALU NUPLU TOMTI OKX OKG

EPMO arr:
SUI BAREP KELOD OBOLA CZE DIPKI TENVO OBOKU PEVUM AMUTO DOSIX BIMPA GODIL
GOBAX KORUP LATAG AKAPI CZE DIPKI TENVO OBOKU PEVUM AMUTO DOSIX BIMPA GODIL

EPKK dep: (climbing fl280)
NUMBA DINOV EKSEK LASIS GOBAX
JED NUBLI BAGAP VALUD PENEX VAVEK GRU

EPKK arr:
GOBAX LASIS NUPLU ETNEL MAPIK
GRU VAVEK PENEX VALUD LDZ BAGAP NUBLI JED

EPKT dep: (climbing fl240)
NUMBA DINOV EKSEK LASIS GOBAX
JED NUBLI BAGAP VALUD PENEX VAVEK GRU

EPKT arr:
GOBAX LASIS NUPLU ETNEL MAPIK
GRU VAVEK PENEX VALUD LDZ BAGAP NUBLI JED

EPWR dep: (climbing f100)
RASUT NUPLU EKSEK NAROX GOBAX
RASUT NUPLU TOMTI OKX OKG
DEVEG SABAB SUDOL LUXAR
ETNEL PEKOT DESEN MIKOV
DEVEG EPOPA AMTEK
VAGSA LUNUK OKENO AGAVA WAR (to EPWA)

EPWR arr:
LAGAR ROTOL WR603
GOBAX NAROX EKSEK NUPLU WR603
LUXAR SUDOL SABAB DEVEG WR603

EPLL dep: (climbing fl100)
UTOLU INDIG MASIV BADUP CZE OBOLA KELOD BAREP SUI
BAXIS UVIVI AGALU NUPLU TOMTI OKX OKG

EPLL arr:
SUI BAREP KELOD OBOLA CZE BADUP MASIV INDIG UTOLU
LAGAR DINOV MISKA VAGSA LUNUK ABAKU

EPPO dep: (climbing fl190)
OBOLA LATAG RASAN OKX OKG
CZE XIDNA ARMEX NUDRO DEVEG EPOPA AMTEK VALPI

EPPO arr:
JED BAREX BESTO CZE
VALPI REGLI EPOPA DEVEG NUDRO ARMEX XIDNA CZE
TOMTI DIMEX AKAPI CZE

LKPR dep: (climbing fl270)
PR532 GOLOP LAGAR VAGSA LUNUK OKENO ABAKU LDZ ETUBO
PR532 GOLOP TOMTI DIMEX AKAPI CZE

LKPR arr:
WAR SOXER BAXIS UVIVI AGALU NUPLU TOMTI OKX GOLOP PR532
OBOLA LATAG RASAN OKX GOLOP PR532

now for the transits:
MIKOV DESEN PEKOT ETNEL VELAB AKAPI OBOLA CHO
MIKOV DESEN PEKOT ETNEL VELAB DIMEX LATAG GOVEN
VALPI REGLI EPOPA DEVEG NUDRO TRZ DIMEX GOVEN
VALPI REGLI EPOPA DEVEG NUDRO ARMEX XIDNA CZE
LUXAR SUDOL SABAB NUDRO ARMEX XIDNA CZE
LUXAR SUDOL SABAB NUDRO TRZ DIMEX GOVEN
LUXAR NUMBA DINOV EKSEK LASIS GOBAX
LUXAR JED NUBLI LDZ VALUD PENEX VAVEK
LUXAR JED MAKOV BADNO CZE CHO
LEGNO LDZ UTOLU INDIG MASIV BADUP CZE OBOLA KELOD BAREP SUI
LEGNO LDZ BAXIS UVIVI AGALU NUPLU TOMTI OKX OKG
WAR UTOLU INDIG MASIV BADUP CZE OBOLA KELOD BAREP SUI
WAR UTOLU INDIG MASIV BADUP CZE CHO
WAR INDIG LATAG KORUP
GRU VAVEK PENEX VALUD LDZ BAGAP NUBLI JED LUXAR
GRU ERPAB OBOKU INDIG UVIVI SABAB DESEN MIKOV
GRU ERPAB OBOKU INDIG UVIVI SABAB DESEN VALPI
GRU OBOLA LATAG RASAN OKX OKG
SUI BAREP KELOD OBOLA CZE BADUP MASIV INDIG LDZ LEGNO
SUI BAREP KELOD OBOLA CZE BADNO UVIVI LUNUK BAREX JED
SUI BAREP KELOD OBOLA CZE BADNO UVIVI LUNUK BAREX LUXAR
GOVEN LATAG DIMEX VELAB TRZ BAREX JED
GOVEN LATAG DIMEX VELAB TRZ NUDRO SUDOL LUXAR
GOVEN LATAG DIMEX VELAB TRZ PEKOT DESEN VALPI
GOVEN LATAG DIMEX VELAB TRZ PEKOT DESEN MIKOV
GOBAX LASIS RASUT DEVEG SABAB SUDOL LUXAR
GOBAX LASIS RASUT DEVEG SABAB SUDOL JED
GOBAX LASIS NUPLU ETNEL PEKOT DESEN VALPI
GOBAX LASIS NUPLU ETNEL PEKOT DESEN MIKOV
OKG LAGAR VAGSA LUNUK OKENO ABAKU LDZ ETUBO
OKG TOMTI DIMEX AKAPI CZE CHO
OKG TOMTI DIMEX AKAPI CZE
CHO CZE BESTO VAGSA EPOPA AMTEK VALPI
`;

// Parse headers + rows → { dep:{ICAO:[...names]}, arr:{ICAO:[...names]}, transit:[...names] }
function parseRouteTemplates(text){
  const dep={}, arr={}, transit=[];
  let mode=null, apt=null;
  for(const raw of text.split(/\r?\n/)){
    const line = raw.trim();
    if(!line) continue;
    const m = line.match(/^([A-Z]{4})\s+(dep|arr)\s*:?/i);
    if(m){ apt=m[1].toUpperCase(); mode=m[2].toLowerCase(); continue; }
    if(/^now for the transits/i.test(line) || /^all of .*transit/i.test(line)){ mode='transit'; apt=null; continue; }
    const cleaned = line.replace(/\([^)]*\)/g,'').trim();
    if(!cleaned) continue;
    const names = cleaned.split(/\s+/).map(s=>s.toUpperCase());
    if(!names.length) continue;
    if(mode==='dep' && apt){ (dep[apt]??=[]).push([apt, ...names]); }
    else if(mode==='arr' && apt){ (arr[apt]??=[]).push([...names, apt]); }
    else if(mode==='transit'){ transit.push(names); }
  }
  return {dep, arr, transit};
}
const ROUTE_TEMPLATES = parseRouteTemplates(ROUTE_TEXT);

// Convert names → IDs (drop routes with unknown fixes)
function namesToIds(names){
  const ids=[], missing=[];
  for(const nm of names){
    const w = findFixByName(nm); // uses your static WP + any dynamic wpts
    if(!w) missing.push(nm); else ids.push(w.id);
  }
  if(missing.length){
    console.warn('[Routes] Skipping (missing fixes):', missing.join(', '), 'in', names.join(' → '));
    return null;
  }
  return ids;
}

const DEP_ROUTES_ID = {};
for(const [apt, list] of Object.entries(ROUTE_TEMPLATES.dep)){
  const ok = list.map(namesToIds).filter(Boolean);
  if(ok.length) DEP_ROUTES_ID[apt] = ok;
}
const ARR_ROUTES_ID = {};
for(const [apt, list] of Object.entries(ROUTE_TEMPLATES.arr)){
  const ok = list.map(namesToIds).filter(Boolean);
  if(ok.length) ARR_ROUTES_ID[apt] = ok;
}
const TRANSIT_ROUTES_ID = ROUTE_TEMPLATES.transit.map(namesToIds).filter(Boolean);

const pickRand = arr => arr[Math.random()*arr.length|0];

// === Route builders: only use your templates ===============================
function buildDepartureRoute(fp){
  const keys = Object.keys(DEP_ROUTES_ID);
  if(!keys.length) return [];
  const apt = (fp && DEP_ROUTES_ID[fp.dep]) ? fp.dep : pickRand(keys);
  return pickRand(DEP_ROUTES_ID[apt]).slice();
}
function buildArrivalRoute(fp){
  const keys = Object.keys(ARR_ROUTES_ID);
  if(!keys.length) return [];
  const apt = (fp && ARR_ROUTES_ID[fp.dest]) ? fp.dest : pickRand(keys);
  return pickRand(ARR_ROUTES_ID[apt]).slice();
}
function buildTransitRoute(/*fp*/){
  return TRANSIT_ROUTES_ID.length ? pickRand(TRANSIT_ROUTES_ID).slice() : [];
}

// === Optional: override makeSFP() so spawns use airports we have ===========
function makeSFP({dep=null, dest=null, cruiseFL=360, tasKt=450, type=null}={}){
  const depKeys = Object.keys(DEP_ROUTES_ID);
  const arrKeys = Object.keys(ARR_ROUTES_ID);
  const pick = a => a[Math.random()*a.length|0];
  const depApt = dep && DEP_ROUTES_ID[dep] ? dep : (depKeys.length ? pick(depKeys) : null);
  // try not to pick the same code for dest if avoidable
  let destApt = dest && ARR_ROUTES_ID[dest] ? dest : (arrKeys.length ? pick(arrKeys) : null);
  if(destApt && depApt && arrKeys.length>1 && destApt===depApt){
    do{ destApt = pick(arrKeys); } while(destApt===depApt);
  }
  return { dep:depApt, dest:destApt, cruiseFL, tasKt, type: type ?? pick(TYPES) };
}

console.info('[Routes] Loaded:',
  Object.keys(DEP_ROUTES_ID).length, 'dep apts,',
  Object.keys(ARR_ROUTES_ID).length, 'arr apts,',
  TRANSIT_ROUTES_ID.length, 'transit options');





// Put this near your other globals (above spawnAircraft)
const SPAWN = {
  flMin: 330,      // inclusive
  flMax: 400,      // inclusive
  marginNM: 25,     // how far outside the sector to spawn
  jitterDeg: 45    // ± jitter to avoid perfectly cardinal inbounds
};

// --- Auto spawner (cooldown-based; guarantees ≤1 spawn per tick) ---
const AutoSpawn = {
  enabled: false,
  cooldownSec: Infinity,   // counts down while enabled; Infinity when disabled
  minGap: 65,
  maxGap: 85,
  conflictChance: 0.00
};
function randGap(){
  return AutoSpawn.minGap + Math.random()*(AutoSpawn.maxGap - AutoSpawn.minGap);
}
function armCooldown(){ AutoSpawn.cooldownSec = randGap(); }
function disarmCooldown(){ AutoSpawn.cooldownSec = Infinity; }

// routeMode can be 'arrival' | 'departure' | 'transit' | null
function spawnWithParams({x_nm,y_nm,hdg,alt_ft,spd_kt, jitterDeg=0, routeMode=null, routeOverride=null}, fp=null){
  const a = new Aircraft({ x_nm, y_nm, hdg, alt_ft, spd_kt, fp });

  if (jitterDeg) hdg = mod360(hdg + rand(-jitterDeg, +jitterDeg));
  a.setHeading(hdg);
  a.inSector = env.inRect(a.x_nm, a.y_nm);

  if (fp) {
  // Decide routing mode if caller didn't force one
  let mode = routeMode ?? (!env.inRect(x_nm, y_nm) ? 'arrival' : 'departure');

  // 1) Build from templates only
  let route;
  if (mode === 'transit')      route = buildTransitRoute(fp);
  else if (mode === 'arrival') route = buildArrivalRoute(fp);
  else                         route = buildDepartureRoute(fp);

  // 2) Use exactly what was picked (no align/sanitize/CTR)
  if (Array.isArray(route) && route.length){
    a.setRoute(route);
  }
}
// Decide routing mode if caller didn't force one
let mode = routeMode ?? (!env.inRect(x_nm, y_nm) ? 'arrival' : 'departure');

// Use provided route if given; otherwise build from templates
let route = routeOverride ? routeOverride.slice() :
    (mode === 'transit' ? buildTransitRoute(fp) :
        (mode === 'arrival' ? buildArrivalRoute(fp) : buildDepartureRoute(fp)));
        
if (Array.isArray(route) && route.length){
    a.setRoute(route);
}


  state.ac.push(a);

  // Fallback: no route? nudge toward the nearest known fix (static or dynamic)
if (!a.route.length){
  const allFixes = [...WP_ALL, ...wpts];
  if (allFixes.length){
    let bestId = null, bestD = Infinity;
    for (const w of allFixes){
      const d = Math.hypot(w.x_nm - a.x_nm, w.y_nm - a.y_nm);
      if (d < bestD){ bestD = d; bestId = w.id; }
    }
    if (bestId != null) a.directTo(bestId);
  }
}


  state.selectedId = a.id;
  flashSelected(); updateSelectedPanel(); drawAll();
  return a;
}

// Spawn ≤10 NM *outside* the first fix (i.e., farther from sector center),
// and point the aircraft back to that fix.
function spawnPointForTransitFirstFix(firstFixId){
  const fix = getWPById(firstFixId);
  if (!fix) return null;

  // vector from sector center (0,0) to the fix
  const vx = fix.x_nm, vy = fix.y_nm;
  const len = Math.hypot(vx, vy) || 1;
  const ux = vx / len, uy = vy / len;

  // place 8–10 NM further *away* from the center along that ray
  const dist = 8 + Math.random()*2; // 8..10 NM
  const x = fix.x_nm + ux*dist;
  const y = fix.y_nm + uy*dist;

  // heading back toward the fix
  const hdg = mod360(toDeg(Math.atan2(fix.x_nm - x, -(fix.y_nm - y))));

  return { x_nm:x, y_nm:y, hdg };
}


function spawnPlannedAircraft(){
  const halfW = env.rectW/2, halfH = env.rectH/2, m = SPAWN.marginNM;

  // --- choose mode (weights) ---
  const wTransit=0.80, wArrival=0.10, wDepart=0.10; // tweak to taste
  const r = Math.random();
  let mode = 'transit';
  if (r < wTransit) mode = 'transit';
  else if (r < wTransit + wArrival) mode = 'arrival';
  else mode = 'departure';

  // Choose alt/speed & SFP
  const tMin = Math.floor(SPAWN.flMin/10);
  const tMax = Math.floor(SPAWN.flMax/10);
  const FL   = (tMin + randi(0, tMax - tMin))*10;
  const alt  = FL*100;
  const spd  = 420 + Math.random()*70;
  const fp   = makeSFP({ cruiseFL: FL, tasKt: Math.round(spd) });

  if (mode === 'departure'){
    // spawn near center pointing out
    const ang = Math.random()*Math.PI*2;
    const r   = rand(0, Math.min(halfW, halfH)*0.25);
    const x   = Math.sin(ang)*r;
    const y   = -Math.cos(ang)*r;
    const hdg = mod360(toDeg(Math.atan2(x, -y)));
    return spawnWithParams({x_nm:x,y_nm:y,hdg,alt_ft:alt,spd_kt:spd, routeMode:'departure'}, fp);
  }

  // edge spawns share similar logic
  const side = randi(0,3);
  let x=0,y=0,baseHdg=0;
  if (side===0){ y=-(halfH+m); x=rand(-halfW*0.9, halfW*0.9); baseHdg=180; }
  else if(side===1){ x=(halfW+m); y=rand(-halfH*0.9, halfH*0.9); baseHdg=270; }
  else if(side===2){ y=(halfH+m); x=rand(-halfW*0.9, halfW*0.9); baseHdg=0; }
  else { x=-(halfW+m); y=rand(-halfH*0.9, halfH*0.9); baseHdg=90; }

  // small jitter to avoid perfect lines
  const hdg = mod360(baseHdg + rand(-SPAWN.jitterDeg, SPAWN.jitterDeg));

  if (mode === 'arrival'){
    // treat as arrival route (could still avoid CTR per your ROUTE_CFG)
    return spawnWithParams({x_nm:x,y_nm:y,hdg,alt_ft:alt,spd_kt:spd, routeMode:'arrival'}, fp);
  } else {
    // TRANSIT: build route first so we can spawn near its first fix
    const route = buildTransitRoute(fp);
    if (route && route.length){
      const anchor = spawnPointForTransitFirstFix(route[0]);
      if (anchor){
        return spawnWithParams(
          {
            x_nm:anchor.x_nm, y_nm:anchor.y_nm, hdg:anchor.hdg,
            alt_ft:alt, spd_kt:spd,
            routeMode:'transit', routeOverride:route, jitterDeg:5
          },
          fp
        );
      }
    }
    // Fallback: generic edge spawn if anything failed
    return spawnWithParams({x_nm:x,y_nm:y,hdg,alt_ft:alt,spd_kt:spd, routeMode:'transit'}, fp);
  }
}


// Spawn a conflict pack (pair or triple) that will converge near center
function spawnConflictPack(useRoutes=false){
  const halfW = env.rectW/2, halfH = env.rectH/2, m = SPAWN.marginNM;

  // Same level for all units in the pack
  const tMin = Math.floor(SPAWN.flMin/10);
  const tMax = Math.floor(SPAWN.flMax/10);
  const FL   = (tMin + randi(0, tMax - tMin))*10;
  const alt  = FL*100;
  const spd1 = 430 + Math.random()*60;
  const spd2 = 430 + Math.random()*60;

  // Choose axis pair (E↔W or N↔S) so they cross the middle
  const EW = Math.random() < 0.5;
  
    const fpArg = useRoutes ? makeSFP({cruiseFL:FL}) : null;


  if (EW){
    // One from West → East, one from East → West, slight vertical offset
    const y = rand(-halfH*0.6, halfH*0.6);
    spawnWithParams({ x_nm:-(halfW+m), y_nm:y+rand(-4, +4), hdg:90+rand(-10,10), alt_ft:alt, spd_kt:spd1 }, fpArg);
    spawnWithParams({ x_nm:(halfW+m),  y_nm:y+rand(-4, +4), hdg:270+rand(-10,10),alt_ft:alt, spd_kt:spd2 }, fpArg);


  } else {
    // One from North → South, one from South → North
    const x = rand(-halfW*0.6, halfW*0.6);
    spawnWithParams({ x_nm:x+rand(-4,+4), y_nm:-(halfH+m), hdg:180+rand(-10,10), alt_ft:alt, spd_kt:spd1 }, fpArg);
    spawnWithParams({ x_nm:x+rand(-4,+4), y_nm:(halfH+m),  hdg:0+rand(-10,10),   alt_ft:alt, spd_kt:spd2 }, fpArg);

  }

  // 30% chance add a third crosser to spice it up
  if (Math.random() < 0.30){
    const hdg = randi(0,3)*90 + rand(-20,20);
    const side = randi(0,3);
    let x=0,y=0;
    if (side===0){ y=-(halfH+m); x=rand(-halfW*0.9, halfW*0.9); }
    else if(side===1){ x=(halfW+m); y=rand(-halfH*0.9, halfH*0.9); }
    else if(side===2){ y=(halfH+m); x=rand(-halfW*0.9, halfW*0.9); }
    else { x=-(halfW+m); y=rand(-halfH*0.9, halfH*0.9); }
    spawnWithParams({ x_nm:x, y_nm:y, hdg, alt_ft:alt, spd_kt: 430+Math.random()*60 }, fpArg);
  }
}


 function spawnAircraft(){
  // Choose a sector edge to spawn from: 0=N, 1=E, 2=S, 3=W
  const side = Math.floor(Math.random()*4);
  const halfW = env.rectW/2, halfH = env.rectH/2;
  const m = SPAWN.marginNM;

  let x=0, y=0, hdg=0;

  switch(side){
    case 0: // from North → heading South
      y = -(halfH + m);
      x = (Math.random()*2 - 1) * (halfW * 0.9);
      hdg = 180;
      break;
    case 1: // from East → heading West
      x =  (halfW + m);
      y = (Math.random()*2 - 1) * (halfH * 0.9);
      hdg = 270;
      break;
    case 2: // from South → heading North
      y =  (halfH + m);
      x = (Math.random()*2 - 1) * (halfW * 0.9);
      hdg = 0;
      break;
    default: // from West → heading East
      x = -(halfW + m);
      y = (Math.random()*2 - 1) * (halfH * 0.9);
      hdg = 90;
      break;
  }



  // Add a little randomization so they’re not laser-straight
  hdg = mod360(hdg + (Math.random()*SPAWN.jitterDeg*2 - SPAWN.jitterDeg));

  // Pick FL in tens within [flMin, flMax]
  const tMin = Math.floor(SPAWN.flMin/10);
  const tMax = Math.floor(SPAWN.flMax/10);
  const tens = tMin + Math.floor(Math.random()*(tMax - tMin + 1)); // integer step of 10 FLs
  const FL = tens * 10;
  const alt = FL * 100; // your sim uses FL * 100 = feet

  // Cruise-y speed; you can also switch to Mach if you prefer
  const spd = 430 + Math.random()*60;

  const a = new Aircraft({ x_nm:x, y_nm:y, hdg:hdg, alt_ft:alt, spd_kt:spd });
  a.setHeading(hdg);                   // ensure initial vector is inbound
  a.inSector = env.inRect(a.x_nm, a.y_nm);

  state.ac.push(a);
  state.selectedId = a.id;
  flashSelected();
  updateSelectedPanel();
  drawAll();
}

  function clearAll(){
    state.ac.length=0; state.selectedId=null; updateSelectedPanel();
    // remove leftover tags
    for(const el of tagMap.values()) el.remove(); tagMap.clear();
    drawAll();
  }

  // ---------- Conflict detection ----------
  const sepNM=5, sepFT=1000;
  function project(ac,tSec){
    const dist_nm=ac.spd_kt*nmPerKtPerSec*tSec;
    const x=ac.x_nm+Math.sin(toRad(ac.hdg))*dist_nm;
    const y=ac.y_nm-Math.cos(toRad(ac.hdg))*dist_nm;
    let alt=ac.alt_ft;
    if(ac.alt_ft!==ac.tgtAlt){
      const vs_fps=clamp(ac.vs_fpm*ftPerMinToFtPerSec, -ac.maxVS_fps, ac.maxVS_fps);
      const delta=vs_fps*tSec; const rem=ac.tgtAlt-ac.alt_ft;
      if(Math.sign(rem)===Math.sign(delta)&&Math.abs(delta)<=Math.abs(rem)) alt=ac.alt_ft+delta; else alt=ac.tgtAlt;
    }
    return {x,y,alt};
  }
  function detectConflicts(){
    state.conflictsNow.length=0; state.conflictsPred.length=0;
    for(let i=0;i<state.ac.length;i++){
      for(let j=i+1;j<state.ac.length;j++){
        const a=state.ac[i], b=state.ac[j];
        const dnm=Math.hypot(a.x_nm-b.x_nm,a.y_nm-b.y_nm);
        const dft=Math.abs(a.alt_ft-b.alt_ft);
        if(dnm<sepNM && dft<sepFT){ state.conflictsNow.push([a.id,b.id]); continue; }
        const t=state.lookaheadMin*60; if(t>0){
          const pa=project(a,t), pb=project(b,t);
          const dnmP=Math.hypot(pa.x-pb.x,pa.y-pb.y);
          const dftP=Math.abs(pa.alt-pb.alt);
          if(dnmP<sepNM && dftP<sepFT) state.conflictsPred.push([a.id,b.id]);
        }
      }
    }
  }

  // ---------- Drawing (split: canvas vs DOM) ----------
  const tagMap = new Map(); // id -> element
  let wptElems=[];

  function layoutWptLabels(){
  for(const e of wptElems) e.remove(); wptElems.length=0;
  const all = [...WP_ALL, ...wpts];
  for(const w of all){
    const x=cx+nmToPx(w.x_nm), y=cy+nmToPx(w.y_nm);
    const lab=document.createElement('div');
    lab.className='waypointLabel';
    lab.textContent=w.name;
    lab.style.left=(x+8)+'px';
    lab.style.top =(y-10)+'px';
    wptElems.push(lab); wrap.appendChild(lab);
  }
}


  function layoutTags(){
    const presentIds = new Set();
    for(const a of state.ac){
      presentIds.add(a.id);
      const x=cx+nmToPx(a.x_nm), y=cy+nmToPx(a.y_nm);
      let tag = tagMap.get(a.id);
      if(!tag){
        tag=document.createElement('div');
        tag.className='tag';
        tag.dataset.trackId=String(a.id);
        // Drag/select handlers
        let dragging=false, startX=0,startY=0, startDx=0,startDy=0, moved=false;
        tag.addEventListener('pointerdown', ev=>{
  // NEW: Shift + Left Click on tag → use that aircraft position as a measure point
  if (ev.shiftKey && ev.button === 0) {
    const ax = cx + nmToPx(a.x_nm);
    const ay = cy + nmToPx(a.y_nm);
    handleMeasureSmartClick(ax, ay);
    ev.preventDefault();
    return;
  }

  if(ev.button!==0) return; // left only
  dragging=true; moved=false; tag.setPointerCapture(ev.pointerId);
  tag.classList.add('dragging');
  const aObj = state.ac.find(z=>z.id===a.id); if(!aObj) return;
  startX=ev.clientX; startY=ev.clientY; startDx=aObj.labelDx; startDy=aObj.labelDy; ev.preventDefault();
});

        tag.addEventListener('pointermove', ev=>{
  if(!dragging) return;
  if ((ev.buttons & 1) === 0) {  // LMB no longer held
    dragging=false; tag.classList.remove('dragging');
    try{ tag.releasePointerCapture(ev.pointerId);}catch{}
    return;
  }
  const aObj = state.ac.find(z=>z.id===a.id); if(!aObj) return;
  const dx=ev.clientX-startX, dy=ev.clientY-startY;
  if(Math.hypot(dx,dy)>3) moved=true;
  aObj.labelDx = startDx + dx; aObj.labelDy = startDy + dy;
  tag.style.left = (cx+nmToPx(aObj.x_nm) + aObj.labelDx) + 'px';
  tag.style.top  = (cy+nmToPx(aObj.y_nm) + aObj.labelDy) + 'px';
  drawCanvasOnly();
});

        tag.addEventListener('pointerup', ev=>{
  tag.classList.remove('dragging');
  if(dragging && !moved){ state.selectedId=a.id; flashSelected(); updateSelectedPanel(); layoutTags(); drawCanvasOnly(); }
  dragging=false;
  try{ tag.releasePointerCapture(ev.pointerId);}catch{}
});
tag.addEventListener('pointercancel', ()=>{
  dragging=false; tag.classList.remove('dragging');
});
tag.addEventListener('lostpointercapture', ()=>{
  dragging=false; tag.classList.remove('dragging');
});

        tag.addEventListener('click', ev=>{ ev.stopPropagation(); });
        wrap.appendChild(tag);
        tagMap.set(a.id, tag);
        
        // Bind once per tag: Shift+MMB toggles the green route preview;
// also block the browser’s autoscroll on Shift+MMB.
tag.addEventListener('auxclick', (ev)=>{
  if (ev.button === 1 && ev.shiftKey){
    state.routePreviewId = (state.routePreviewId === a.id) ? null : a.id;
    drawAll(); // or drawCanvasOnly();
    ev.preventDefault();
    ev.stopPropagation();
  }
});
tag.addEventListener('mousedown', (ev)=>{
  if (ev.button === 1 && ev.shiftKey){
    ev.preventDefault();
    ev.stopPropagation();
  }
});

      }
      // Update classes/content/position
      tag.classList.toggle('alert', state.conflictsNow.some(([p,q])=>p===a.id||q===a.id));
      tag.classList.toggle('warn', !tag.classList.contains('alert') && state.conflictsPred.some(([p,q])=>p===a.id||q===a.id));
      // apply state color class for text-only labels
const st = getTrackState(a);   // uses helpers from step 2.3
tag.classList.remove('st-controlled','st-inbound','st-intruder','st-outbound');
tag.classList.add('st-'+st);

// build 4 text lines (no box, no table)
const curFL = fmtFLshort(a.alt_ft);
const cfl   = fmtCFL(a.tgtAlt);
const type  = a.fp?.type || a.type;
const wpt   = nextWptName(a, env);
const vs100 = fmtVS100(a.vs_fpm);

tag.innerHTML = `
  <div class="l1"><span data-cs>${a.cs}</span><span class="ho" data-ho="1" title="Toggle H/O">H/O</span></div>
  <div class="l2"><span data-act="curfl">${curFL}</span>&nbsp;&nbsp;&nbsp;<span data-act="cfl">${cfl}</span>&nbsp;&nbsp;VS<span data-act="vs">${vs100}</span></div>
  <div class="l2"><span data-act="type">${type}</span>&nbsp;&nbsp;&nbsp;<span data-act="wpt">${wpt}</span></div>
  <div class="l2">H<span data-act="hdg">${formatHeading(a.hdg)}</span>&nbsp;&nbsp;&nbsp;S<span data-act="spd">${a.spd_kt|0}</span>/M<span data-act="mach">${a.mach.toFixed(2)}</span></div>
`;


// wire the tiny H/O toggle (marks a.hoMarked to drive "intruder" color)
const hoBtn = tag.querySelector('[data-ho]');
if (hoBtn){
  hoBtn.onclick = (ev)=>{
    ev.stopPropagation();
    a.hoMarked = !a.hoMarked;
    layoutTags(); drawCanvasOnly();
  };
}
// Middle-click on callsign => open SFP
const csBtn = tag.querySelector('[data-cs]');
if (csBtn){
  csBtn.addEventListener('mousedown', ev=>{
    if (ev.button === 1){ openSFP(a); ev.preventDefault(); }
  });
}

// ===== MMB-only editing for label values =====
const act = sel => tag.querySelector(`[data-act="${sel}"]`);

// clear previous highlight on this tag, then apply if this tag is being edited
tag.querySelectorAll('[data-act]').forEach(s=>s.classList.remove('editing'));
if (state.editing && state.editing.id === a.id){
  const hi = act(state.editing.field);
  if (hi) hi.classList.add('editing');
}

// prevent autoscroll on middle mouse and stop it bubbling into drag
function blockMMB(el){
  if(!el) return;
  el.addEventListener('mousedown', ev=>{
    if (ev.button === 1){ ev.preventDefault(); ev.stopPropagation(); }
  });
}

// run an action only on true MMB (auxclick)
function withMMB(el, fn){
  if(!el) return;
  el.addEventListener('auxclick', ev=>{
    if (ev.button !== 1 || ev.shiftKey) return;  // plain-MMB only
    ev.preventDefault();
    ev.stopPropagation();
    fn();
  });
}


// H
const hdgEl = act('hdg'); blockMMB(hdgEl);
withMMB(hdgEl, ()=>{
  state.selectedId=a.id; updateSelectedPanel();
  const inp = document.getElementById('hdg');
  setEditing('hdg');
  inp.focus(); inp.select();
});

// S (kt)
const spdEl = act('spd'); blockMMB(spdEl);
withMMB(spdEl, ()=>{
  state.selectedId=a.id; updateSelectedPanel();
  const inp = document.getElementById('spd');
  setEditing('spd');
  inp.focus(); inp.select();
});

// M
const machEl = act('mach'); blockMMB(machEl);
withMMB(machEl, ()=>{
  state.selectedId=a.id; updateSelectedPanel();
  const inp = document.getElementById('mach');
  setEditing('mach');
  inp.focus(); inp.select();
});

// VS (×100)
const vsEl = act('vs'); blockMMB(vsEl);
withMMB(vsEl, ()=>{
  state.selectedId=a.id; updateSelectedPanel();
  const inp = document.getElementById('vs');
  inp.value = Math.round(Math.abs(a.vs_fpm)/100);
  setEditing('vs');
  inp.focus(); inp.select();
});

// Waypoint direct-to via MMB prompt
const wptEl = act('wpt'); blockMMB(wptEl);
withMMB(wptEl, ()=>{
  const name = prompt("Direct-to waypoint (e.g. CTR, ENE, any dynamic name):", "");
  if (!name) return;
  const w = findFixByName(name);
  if (w) { a.directTo(w.id); updateSelectedPanel(); drawAll(); }
  else { alert("No waypoint with that name."); }
  



});



      tag.style.left=(x+a.labelDx)+'px'; tag.style.top=(y+a.labelDy)+'px';
    }
    

    // Remove tags for AC that no longer exist
    for(const [id,el] of tagMap.entries()){
      if(!presentIds.has(Number(id))){ el.remove(); tagMap.delete(id); }
    }
  }

  function drawScope(){
  ctx.save();
  ctx.setTransform(1,0,0,1,0,0);
  ctx.globalAlpha = 1;

  // clean background
  ctx.fillStyle = "#060707";
  ctx.fillRect(0,0,W,H);

  // sector polygon outline (no rings/grid/airways)
  ctx.strokeStyle = "#3a3a3a";
  ctx.lineWidth = 1.6;
  ctx.setLineDash([6,6]);
  ctx.beginPath();
  for (let i=0;i<SECTOR_POLY.length;i++){
    const [xn,yn] = SECTOR_POLY[i];
    const x = cx + nmToPx(xn), y = cy + nmToPx(yn);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.closePath();
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();
}



  function formatAltitude(ft){ return ft>=18000?("FL"+String(Math.round(ft/100)).padStart(3,'0')):((ft|0)+" ft"); }
  function inFilter(ft){ return ft>=state.filterMin && ft<=state.filterMax; }

  function drawPredictLines(ac){
  const wants=[ state.pred1?60:0, state.pred3?180:0, state.pred5?300:0 ].filter(Boolean);
  if(!wants.length) return;
  if(!Number.isFinite(ac.x_nm) || !Number.isFinite(ac.y_nm) || !Number.isFinite(ac.hdg) || !Number.isFinite(ac.spd_kt)) return;

  const x0=cx+nmToPx(ac.x_nm), y0=cy+nmToPx(ac.y_nm);
  ctx.lineWidth=1.5; ctx.setLineDash([]); ctx.strokeStyle = "#ffffff";
  for(const t of wants){
    const dist_nm=ac.spd_kt*nmPerKtPerSec*t;
    if(!Number.isFinite(dist_nm)) continue;
    const x=x0+nmToPx(Math.sin(toRad(ac.hdg))*dist_nm);
    const y=y0+nmToPx(-Math.cos(toRad(ac.hdg))*dist_nm);
    ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x,y); ctx.stroke();
  }
}


  


  



  function drawConflicts(){
    for(const [aId,bId] of state.conflictsPred){
      const a=state.ac.find(x=>x.id===aId), b=state.ac.find(x=>x.id===bId); if(!a||!b) continue;
      ctx.strokeStyle="#ffcc66"; ctx.lineWidth=1.5; ctx.setLineDash([4,6]);
      ctx.beginPath(); ctx.moveTo(cx+nmToPx(a.x_nm), cy+nmToPx(a.y_nm)); ctx.lineTo(cx+nmToPx(b.x_nm), cy+nmToPx(b.y_nm)); ctx.stroke();
    }
    for(const [aId,bId] of state.conflictsNow){
      const a=state.ac.find(x=>x.id===aId), b=state.ac.find(x=>x.id===bId); if(!a||!b) continue;
      ctx.strokeStyle="#ff6a6a"; ctx.lineWidth=2.2; ctx.setLineDash([]);
      ctx.beginPath(); ctx.moveTo(cx+nmToPx(a.x_nm), cy+nmToPx(a.y_nm)); ctx.lineTo(cx+nmToPx(b.x_nm), cy+nmToPx(b.y_nm)); ctx.stroke();
    }
    ctx.setLineDash([]);
  }

// --- Measuring (refactored) ---
// Measures now support endpoints that can be either:
//  - {type:'ac', id:<trackId>}  -> follows that aircraft live
//  - {x_nm:<num>, y_nm:<num>}   -> fixed point in space
// Backward compatibility: we still render old {fromX_nm, toX_nm, ...} shapes.

function drawMeasureSegment(m){
  ctx.save();

  // Resolve endpoints (support both new and legacy shapes)
  const p1 = m.from ? resolveEndpoint(m.from) : {x_nm:m.fromX_nm, y_nm:m.fromY_nm};
  const p2 = m.to   ? resolveEndpoint(m.to)   : {x_nm:m.toX_nm,   y_nm:m.toY_nm};
  if(!p1 || !p2){ ctx.restore(); return; }

  const x1 = cx + nmToPx(p1.x_nm), y1 = cy + nmToPx(p1.y_nm);
  const x2 = cx + nmToPx(p2.x_nm), y2 = cy + nmToPx(p2.y_nm);

  // line
  ctx.strokeStyle="#9ad6ff";
  ctx.lineWidth=1.8;
  ctx.setLineDash([8,6]);
  ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  ctx.setLineDash([]);

  // endpoints
  ctx.fillStyle="#e6f0f7";
  ctx.beginPath(); ctx.arc(x1,y1,3,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x2,y2,3,0,Math.PI*2); ctx.fill();

  // label text (no box): place slightly "above" the segment midpoint
  const dnm = Math.hypot(p2.x_nm-p1.x_nm, p2.y_nm-p1.y_nm);
  const brg = bearingFromTo(p1.x_nm,p1.y_nm,p2.x_nm,p2.y_nm);
  const text = `${dnm.toFixed(1)} NM • HDG ${formatHeading(brg)}`;

  const midx = (x1+x2)/2, midy = (y1+y2)/2;
  // screen-space normal (perpendicular) for offset
  const nx = (y2 - y1), ny = -(x2 - x1);
  const nlen = Math.hypot(nx, ny) || 1;
  const off = 14; // how far above the line (px)
  const tx = midx + (nx / nlen) * off;
  const ty = midy + (ny / nlen) * off;

  // halo + fill for readability
  ctx.font = "12px ui-monospace";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.lineWidth = 4;
  ctx.strokeStyle = "rgba(7,16,24,0.9)"; // dark halo
  ctx.strokeText(text, tx, ty);
  ctx.fillStyle = "#cfe8f7";
  ctx.fillText(text, tx, ty);

  ctx.restore();
}


function drawActiveMeasure(){
  if(!state.measure) return;
  ctx.save();
  ctx.globalAlpha = 1;      // don’t inherit any dimming
  ctx.setLineDash([]);      // don’t inherit dashes
  drawMeasureSegment(state.measure);
  ctx.restore();
}
function drawRulers(){
  ctx.save();
  ctx.globalAlpha = 1;
  ctx.setLineDash([]);
  for(const m of state.measures) drawMeasureSegment(m);
  ctx.restore();
}

// ===== Bright-green route preview =========================================
function drawRoutePreview(){
  const id = state.routePreviewId;
  if (id == null) return;

  const a = state.ac.find(t => t.id === id);
  if (!a || !a.route.length) return;

  ctx.save();
  ctx.strokeStyle = "#00ff6b";   // neon green
  ctx.lineWidth   = 2.4;
  ctx.setLineDash([3,6]);        // dashed; delete line for solid

  // start at the aircraft's current position
  let px = cx + nmToPx(a.x_nm);
  let py = cy + nmToPx(a.y_nm);

  for (let i = Math.max(a.routeIdx, 0); i < a.route.length; i++){
    const w = env.getWaypoint(a.route[i]);
    if (!w) continue;
    const wx = cx + nmToPx(w.x_nm);
    const wy = cy + nmToPx(w.y_nm);

    ctx.beginPath();
    ctx.moveTo(px, py);
    ctx.lineTo(wx, wy);
    ctx.stroke();

    px = wx; py = wy;   // next leg starts here
  }
  ctx.restore();
}


// NEW: Shift+Left click handler — snaps to aircraft (live) or uses free point.
function handleMeasureSmartClick(xPx, yPx){
  const ac = findNearestAcPx(xPx, yPx, 16);
  const ep = ac ? { type:'ac', id: ac.id }
                : pxToNm(xPx, yPx); // {x_nm, y_nm}

  if(!state.measure){
    // Start: from = ep, to = cursor (temporary same ep)
    state.measure = { from: ep, to: ep };
  }else{
    // Finish: set 'to' endpoint and commit
    state.measure.to = ep;
    state.measures.push({ ...state.measure }); // store by reference
    state.measure = null;
  }
  drawAll();
}



  function drawCanvasBase(){
  drawScope();
  detectConflicts();

  for(const a of state.ac){
    if (!Number.isFinite(a.x_nm) || !Number.isFinite(a.y_nm) ||
        !Number.isFinite(a.hdg)  || !Number.isFinite(a.spd_kt)) {
      continue; // skip broken track this frame
    }
    const selected = a.id===state.selectedId;
    const dim = !inFilter(a.alt_ft); ctx.globalAlpha = dim?0.35:1.0;

    // dotted trail
    ctx.fillStyle = "#ffffff";
    for(const p of a.trail){
      if(!Number.isFinite(p.x) || !Number.isFinite(p.y)) continue;
      const tx = cx+nmToPx(p.x), ty = cy+nmToPx(p.y);
      ctx.beginPath(); ctx.arc(tx,ty,2.4,0,Math.PI*2); ctx.fill();
    }

    // vectors
    const showPred = state.predFor==="all" || (state.predFor==="sel" && selected);
    if(showPred) drawPredictLines(a);

    // symbol
    const x = cx + nmToPx(a.x_nm), y = cy + nmToPx(a.y_nm);
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    const s = 5;
    ctx.moveTo(x, y - s);
    ctx.lineTo(x + s, y);
    ctx.lineTo(x, y + s);
    ctx.lineTo(x - s, y);
    ctx.closePath(); ctx.fill();
  }

  drawConflicts();
  ctx.globalAlpha=1.0;
}


  function drawLeaders(){
    for(const a of state.ac){
      const dotX=cx+nmToPx(a.x_nm), dotY=cy+nmToPx(a.y_nm);
      const tag = tagMap.get(a.id); if(!tag) continue;
      const rect = tag.getBoundingClientRect(), wrapRect = wrap.getBoundingClientRect();
      const left = rect.left - wrapRect.left, top = rect.top - wrapRect.top;
      const right = left + rect.width, bottom = top + rect.height;
      const ex = clamp(dotX, left, right), ey = clamp(dotY, top, bottom);
      ctx.strokeStyle = "#ffffff";

      ctx.beginPath(); ctx.moveTo(dotX, dotY); ctx.lineTo(ex, ey); ctx.stroke();
    }
  }

  function drawCanvasOnly(){ // fast path during drags
    drawCanvasBase();
    drawLeaders();
    drawRoutePreview();
    drawRulers();     // NEW: draw committed rulers
    drawActiveMeasure();
  }

  function drawAll(){
  drawCanvasBase();
  layoutWptLabels();
  layoutTags();
  drawLeaders();
  drawRoutePreview();   // ← only ONE call here
  drawRulers();
  drawActiveMeasure();
}


// ---------- Simulation (3s refresh) ----------
function stepOnce(){
  if(state.paused){ 
    drawCanvasOnly(); 
    return; 
  }

  // advance sim clock
  simNowSec += state.refreshSec * state.simSpeed;
  const dt = state.refreshSec * state.simSpeed;

  // move all aircraft
  for(const a of state.ac) a.update(dt, env);
  // Mark seen-once and cull only after they actually appeared
for (const a of state.ac) {
  if (acInScopeNm(a, 0)) a.seenOnScreenOnce = true;
}

const TTL_NEVER_SEEN_SEC = 280; // safety: if something never appears in 3 min, drop it
state.ac = state.ac.filter(a => {
  if (!a.seenOnScreenOnce) {
    // Keep until it appears, unless TTL expires (or it has already entered)
    return (simNowSec - a.spawnSec) < TTL_NEVER_SEEN_SEC || acInScopeNm(a, 0);
  }
  // Once seen at least once, despawn after it leaves the scope by 8 NM
  return acInScopeNm(a, 8);
});

if (state.selectedId && !state.ac.some(a => a.id === state.selectedId)) {
  state.selectedId = null;
}


// auto-spawn (cooldown)
if (AutoSpawn.enabled && Number.isFinite(AutoSpawn.cooldownSec)) {
  AutoSpawn.cooldownSec -= dt;        // dt = state.refreshSec * state.simSpeed
  if (AutoSpawn.cooldownSec <= 0) {
    if (Math.random() < AutoSpawn.conflictChance) {
  spawnConflictPack(true);   // routed conflicts for autos
} else {
  spawnPlannedAircraft();    // routed singles for autos
}

    armCooldown();                    // reset for next randomized gap
  }
}


  drawAll();
}
let timer = setInterval(stepOnce, 3000);


  // ---------- UI ----------
  const altInput=document.getElementById('alt'); const useFL=document.getElementById('useFL'); const altHint=document.getElementById('altModeHint');
  function updateAltPlaceholder(){
    if(useFL.checked){ altInput.placeholder="e.g. 150 (FL150)"; altHint.textContent="Input interpreted as Flight Level (hundreds of feet)"; }
    else{ altInput.placeholder="e.g. 15000 (ft)"; altHint.textContent="Input interpreted as feet (type FL120 to use FL)"; }
  }
  useFL.addEventListener('change', ()=>{
    const a=getSelected();
    if(a){ altInput.value = useFL.checked ? Math.round(a.tgtAlt/100) : Math.round(a.tgtAlt); }
    updateAltPlaceholder();
  });
  updateAltPlaceholder();

  // Canvas interactions
  canvas.addEventListener('click', e=>{
    if(state.addingWpt){
      const rect=canvas.getBoundingClientRect();
      const xPx=e.clientX-rect.left, yPx=e.clientY-rect.top;
      const {x_nm,y_nm}=pxToNm(xPx,yPx);
      addWaypointAt(x_nm,y_nm); state.addingWpt=false;
      document.getElementById('addWpt').textContent="Add waypoint"; return;
    }
    state.selectedId=null; updateSelectedPanel(); layoutTags(); drawCanvasOnly();
  });

// Measuring: Shift+MMB start/update, RMB now DROPS (commits) instead of clearing.
//           NEW: Shift+Left Click = start/finish with snapping
canvas.addEventListener('pointerdown', e=>{
  const rect = canvas.getBoundingClientRect();
  const xPx = e.clientX - rect.left, yPx = e.clientY - rect.top;

  // Shift + Left Click = smart start/finish (snaps to aircraft if close)
  if (e.shiftKey && e.button === 0) {
    handleMeasureSmartClick(xPx, yPx);
    e.preventDefault();
    return;
  }

  // Plain Left Click = if already measuring, drop/commit immediately
  if (!e.shiftKey && e.button === 0 && state.measure) {
    state.measures.push({ ...state.measure });
    state.measure = null;
    drawAll();
    e.preventDefault();
    return;
  }
});



canvas.addEventListener('pointermove', e=>{
  if(!state.measure) return;
  // If we're mid-placing the second endpoint and it's NOT an aircraft-linked endpoint,
  // update it to follow the cursor for a live preview.
  const rect=canvas.getBoundingClientRect();
  const xPx=e.clientX-rect.left, yPx=e.clientY-rect.top;

  // If 'to' is aircraft-linked, don't override it.
  if(state.measure.to && state.measure.to.type === 'ac') return;

  const {x_nm,y_nm}=pxToNm(xPx,yPx);
  // Ensure the new-style shape exists
  if(!state.measure.from && 'fromX_nm' in state.measure){
    state.measure = { from:{x_nm:state.measure.fromX_nm, y_nm:state.measure.fromY_nm},
                      to:{x_nm, y_nm} };
  }else{
    state.measure.to = {x_nm, y_nm};
  }
  drawCanvasOnly();
});


canvas.addEventListener('pointerup', e=>{
  // keep the ruler until RMB/Esc clears or commits; release capture if we had it
  try { canvas.releasePointerCapture(e.pointerId); } catch {}
});

canvas.addEventListener('pointercancel', e=>{
  try { canvas.releasePointerCapture(e.pointerId); } catch {}
});

// Allow context menu unless we just handled a commit above
canvas.addEventListener('contextmenu', e=>{
  // If a ruler is active, let RMB commit handler above run and suppress menu; otherwise allow menu.
  if (state.measure) e.preventDefault();
});

  function flashSelected(){ const card=document.getElementById('selectedInfo'); card.classList.add('selected'); setTimeout(()=>card.classList.remove('selected'), 450); }

  function updateSelectedPanel(){
    const el=document.getElementById('selectedInfo'); const a=getSelected();
    if(!a){ state.editing = null; el.className='aircraftCard small'; el.innerHTML='Tap/click a tag to select; drag tags anywhere (works on mobile).'; return; }
    el.className='aircraftCard selected';
    const route = a.navMode==="DIRECT"&&a.directWptId ? ` • DIR ${env.getWaypoint(a.directWptId)?.name||""}` : "";
    el.innerHTML = `
  <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
    <div><strong>${a.cs}</strong> — H${formatHeading(a.hdg)} • S${a.spd_kt|0} kt/M${a.mach.toFixed(2)} • ${formatAltitude(a.alt_ft)}${route}</div>
    <button class="btnSfp small" style="white-space:nowrap;">SFP</button>
  </div>
  <div class="small">Targets: H${formatHeading(a.tgtHdg)} • ${
  a.tgtSpeedMode==='MACH'
    ? ('M'+(a.tgtMach?.toFixed(2) ?? (a.tgtSpd_kt/isaSpeedOfSoundKts(a.alt_ft)).toFixed(2)))
    : ('S'+((a.tgtSpd_kt|0))+' kt')
} • ALT ${formatAltitude(a.tgtAlt)} • VS${fmtVS100(a.vs_fpm)} • SEC ${a.inSector?'IN':'OUT'}

`;
const sfpBtn = el.querySelector('.btnSfp');
if(sfpBtn){
  sfpBtn.addEventListener('click', ()=>{
    openSFP(a);
  });
  // If SFP window is open, refresh it for the new selection (or close if none)
const openWin = document.querySelector('.sfpWin');
if(openWin){
  const sel = getSelected();
  if(sel) renderSFP(sel); else closeSFP();
}

}

    altInput.value = useFL.checked ? Math.round(a.tgtAlt/100) : Math.round(a.tgtAlt);
    document.getElementById('hdg').value = Math.round(a.tgtHdg)||0;
    document.getElementById('spd').value = a.tgtSpeedMode==='KT' ? a.tgtSpd_kt|0 : "";
    document.getElementById('mach').value = a.tgtSpeedMode==='MACH'&&a.tgtMach ? a.tgtMach.toFixed(2) : "";
    document.getElementById('vs').value = a.vs_fpm ? (Math.abs(a.vs_fpm)|0) : "";
  }

  document.getElementById('spawn').addEventListener('click', spawnAircraft);
  document.getElementById('autoSpawnToggle').addEventListener('change', e=>{
  AutoSpawn.enabled = e.target.checked;
  if (AutoSpawn.enabled){
    armCooldown();      // start a fresh randomized gap
  } else {
    disarmCooldown();   // stop any pending spawn
  }
});


document.getElementById('spawnConflict').addEventListener('click', ()=>{
  spawnConflictPack();
});

  document.getElementById('clear').addEventListener('click', clearAll);
  document.getElementById('pause').addEventListener('click', e=>{
    state.paused=!state.paused; e.target.textContent=state.paused?"Resume":"Pause";
  });
  document.getElementById('rangeSel').addEventListener('change', e=>{ rangeNM=parseInt(e.target.value,10); drawAll(); });
  document.getElementById('simSpeed').addEventListener('change', e=>{ state.simSpeed=parseFloat(e.target.value); });
  document.getElementById('labelSize').addEventListener('change', e=>{
  document.body.classList.remove('label-sm','label-lg'); // medium = default (no class)
  if (e.target.value==='sm') document.body.classList.add('label-sm');
  else if (e.target.value==='lg') document.body.classList.add('label-lg');
});


  for(const id of ["pred1","pred3","pred5"]) document.getElementById(id).addEventListener('change', e=>{ state[id]=e.target.checked; drawAll(); });
  document.getElementById('predFor').addEventListener('change', e=>{ state.predFor=e.target.value; drawAll(); });

  document.getElementById('lookahead').addEventListener('change', e=>{ state.lookaheadMin=parseInt(e.target.value,10); drawAll(); });

  document.getElementById('btnFilter').addEventListener('click', ()=>{
    state.filterMin=parseInt(document.getElementById('fltMin').value,10)||0;
    state.filterMax=parseInt(document.getElementById('fltMax').value,10)||60000;
    drawAll();
  });

  document.getElementById('spd250').addEventListener('change', e=>{ env.restrict250=e.target.checked; });

  document.getElementById('addWpt').addEventListener('click', ()=>{
  alert("Dynamic waypoints are disabled in this version.");
});
document.getElementById('clearWpt').addEventListener('click', ()=>{
  alert("Dynamic waypoints are disabled in this version.");
});


  document.getElementById('autoHandoff').addEventListener('change', e=>{ env.autoHandoff=e.target.checked; });
  document.getElementById('btnHandoff').addEventListener('click', ()=>{
    const a=getSelected(); if(!a){ alert("Select a track first."); return; }
    if(a.handoffPending){ a.inSector=a.pendingState; a.handoffPending=false; a.pendingState=null; }
    updateSelectedPanel(); drawAll();
  });
  document.getElementById('btnRect').addEventListener('click', ()=>{
    env.rectW=Math.max(5,parseFloat(document.getElementById('rectW').value)||env.rectW);
    env.rectH=Math.max(5,parseFloat(document.getElementById('rectH').value)||env.rectH);
    drawAll();
  });

  // NEW: Measure tool UI button
  document.getElementById('clearRulers').addEventListener('click', ()=>{ state.measures.length=0; drawAll(); });

  // Commands
  document.getElementById('btnHdg').addEventListener('click', ()=>{
    const a=getSelected(); if(!a) return;
    let hdg=parseInt(document.getElementById('hdg').value,10);
    if(!Number.isFinite(hdg)) return;
    if(hdg===360) hdg=0;
    a.setHeading(mod360(hdg));
    updateSelectedPanel(); drawAll();
  });

  document.getElementById('btnAlt').addEventListener('click', ()=>{
  const a=getSelected(); if(!a) return;
  const altFt = parseAltitudeInput(document.getElementById('alt').value, useFL.checked);
  const vs = parseVsHundreds(document.getElementById('vs').value);
  if(altFt!=null) a.setAltitude(altFt, vs);
  updateSelectedPanel(); drawAll();
});


  document.getElementById('btnHold').addEventListener('click', ()=>{ const a=getSelected(); if(!a) return; a.holdAltitude(); updateSelectedPanel(); drawAll(); });
  document.getElementById('btnSpd').addEventListener('click', ()=>{
    const a=getSelected(); if(!a) return; const spd=parseInt(document.getElementById('spd').value,10);
    if(Number.isFinite(spd)) a.setSpeedKt(spd); updateSelectedPanel(); drawAll();
  });
  document.getElementById('btnMach').addEventListener('click', ()=>{
    const a=getSelected(); if(!a) return; const m=parseFloat(document.getElementById('mach').value);
    if(Number.isFinite(m)) a.setMach(m); updateSelectedPanel(); drawAll();
  });
// --- Enter-to-confirm + highlight which field is being edited ---
function bindEnterAndHighlight(inputId, btnId, labelField){
  const inp = document.getElementById(inputId);
  if (!inp) return;
  inp.addEventListener('keydown', e=>{
    if(e.key === 'Enter'){
      const btn = document.getElementById(btnId);
      if (btn) btn.click();
      inp.blur();
    }
  });
  inp.addEventListener('focus', ()=> setEditing(labelField));
  inp.addEventListener('blur',  ()=> clearEditing(labelField));
}

// Map inputs → buttons → which label span to highlight
bindEnterAndHighlight('hdg',  'btnHdg',  'hdg');
bindEnterAndHighlight('spd',  'btnSpd',  'spd');
bindEnterAndHighlight('mach', 'btnMach', 'mach');
bindEnterAndHighlight('alt',  'btnAlt',  'cfl'); // editing ALT highlights CFL
bindEnterAndHighlight('vs',   'btnAlt',  'vs');  // VS shares the ALT apply


  // Shortcuts
  window.addEventListener('keydown', e=>{
    if (e.key === 'Escape') {
      if (state.measure) { state.measure = null; drawCanvasOnly(); return; }
      if (state.measures.length) { state.measures.pop(); drawAll(); return; }
    }
    const a=getSelected();
    if(e.code==='Space'){ e.preventDefault(); state.paused=!state.paused; document.getElementById('pause').textContent=state.paused?"Resume":"Pause"; }
    else if(e.key==='N'||e.key==='n'){ spawnAircraft(); }
    else if(a){
      if(e.key==='H'||e.key==='h'){
        const v=prompt("Vector: heading (1–360)", Math.min(360,Math.max(1, Math.round(a.tgtHdg)||1)));
        if(v!==null){ let h=parseInt(v,10); if(h===360) h=0; if(Number.isFinite(h)) a.setHeading(mod360(h)); updateSelectedPanel(); drawAll(); }
      }else if(e.key==='A'||e.key==='a'){
  const hint = useFL.checked ? "FL (e.g. 120), optional VS×100 like 120,18" : "ft (e.g. 12000), optional VS×100 like 12000,18";
  const v=prompt("Altitude — "+hint, useFL.checked? String(Math.round(a.tgtAlt/100)) : String(Math.round(a.tgtAlt)));
  if(v!==null){
    const parts=v.toUpperCase().split(',');
    const altFt = parseAltitudeInput(parts[0], useFL.checked);
    const vs = parts[1]? parseVsHundreds(parts[1]) : null;
    if(altFt!=null) a.setAltitude(altFt, vs);
    updateSelectedPanel(); drawAll();
  }

      }else if(e.key==='S'||e.key==='s'){
        const v=prompt("Speed (kt)", a.tgtSpeedMode==='KT'?(a.tgtSpd_kt|0):"");
        if(v!==null && v.trim()!==""){ a.setSpeedKt(parseInt(v,10)); updateSelectedPanel(); drawAll(); }
      }else if(e.key==='M'||e.key==='m'){
        const v=prompt("Mach (e.g. 0.78)", a.tgtSpeedMode==='MACH'&&a.tgtMach?a.tgtMach.toFixed(2):"");
        if(v!==null && v.trim()!==""){ a.setMach(parseFloat(v)); updateSelectedPanel(); drawAll(); }
      }
    }
  });

window.addEventListener('load', () => {
  resize();
  renderWptList();
  // NEW: sync the actual range to the selected option (160 by default)
  rangeNM = parseInt(document.getElementById('rangeSel').value, 9) || 120;

  spawnAircraft();
  spawnAircraft();
  booted = true;
  drawAll();
});


</script>
</body>
</html>
