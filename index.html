<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>ATC Radar Trainer — v8.1</title>
<style>
  :root{
  /* Near-black scope */
  --bg:#060707;
  --grid:#0c0c0c;         /* very faint grid (optional) */
  --ring:#141414;         /* very faint rings (optional) */

  /* UI text + panel remain readable */
  --text:#e8eef2;
  --accent:#8fd3ff;
  --panel:#0d1115;

  /* not used for labels anymore, but keep */
  --tag:#0d2230; --tagBorder:#1b3a4f;
  --sel:#9bf6a9; --warn:#ffcc66; --alert:#ff6a6a;
  --muted:#9fb3c1; --magenta:#ff7bff;

  /* leader/rect colors no longer blue; vectors & leaders will be white in JS */
  --leader:#ffffff; --rect:#3a3a3a;
}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:var(--bg); color:var(--text);
    font:15px/1.35 ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Courier New",monospace;
    display:grid; grid-template-columns:1fr 380px; grid-template-rows:56px 1fr;
    grid-template-areas:"top top" "radar panel";
    overflow:hidden auto;
  }
  header{grid-area:top; display:flex; align-items:center; gap:12px;
    padding:10px 14px; background:linear-gradient(180deg,#0d1921,#0a1117);
    border-bottom:1px solid #162737}
  header h1{margin:0; font-size:16px; font-weight:600; letter-spacing:.5px; color:var(--accent)}
  header .controls{display:flex; gap:8px; flex-wrap:wrap; margin-left:auto}
  button,input,select{background:#0d1a22; border:1px solid #1b3243; color:var(--text); padding:8px 10px; border-radius:8px; outline:none}
  button:hover{border-color:#24516e; cursor:pointer}
  input[type="number"],input[type="text"]{width:110px}
  #radarWrap{grid-area:radar; position:relative}
  canvas{display:block; width:100%; height:100%}
  aside{grid-area:panel; border-left:1px solid #162737; background:var(--panel); padding:12px; overflow:auto}
  .section{margin-bottom:14px; padding-bottom:12px; border-bottom:1px dashed #173243}
  .row{display:flex; gap:8px; align-items:center; margin:6px 0; flex-wrap:wrap}
  label{font-size:12px; color:var(--muted); min-width:86px}
  .small{font-size:12px; color:var(--muted)}
  .aircraftCard{border:1px solid #193246; background:#0b1620; border-radius:10px; padding:10px; margin:8px 0}
  .aircraftCard.selected{border-color:var(--sel)}
  .grid2{display:grid; grid-template-columns:1fr 1fr; gap:8px}
  .kbd{padding:2px 6px; border:1px solid #274b64; border-radius:6px; background:#0c1b25}

/* ===== Track labels (text only; no box) ===== */
.tag{
  position:absolute;
  background:transparent;        /* no box */
  border:none;                   /* no border */
  padding:0;                     /* tight */
  filter:none;
  touch-action:none; user-select:none; cursor:grab;
  opacity:1;                     /* solid text */
}
.tag:hover,.tag.dragging{opacity:1}

/* simple type ramp */
/* first line now flex so GS can sit on the far right */
.tag .l1{
  font-weight:700;
  font-size:14px;
  line-height:1.05;
  display:flex;
  align-items:center;
  gap:8px;
  white-space:nowrap;       /* keep the top line on one line */
}
/* GS sits right after H/O, small gap, same color as label */
.tag .l1 .gs{
  margin-left:6px;                 /* <-- was margin-left:auto */
  font-size:12px;
  letter-spacing:.2px;
  color:currentColor;              /* match the label’s state color */
  opacity:.95;
  font-variant-numeric:tabular-nums; /* no width wiggle when digits change */
}


.tag .l2{ font-size:12px; line-height:1.05; letter-spacing:.2px }
/* label size presets */
body.label-sm .tag .l1{ font-size:12px }
body.label-sm .tag .l2{ font-size:10px }
body.label-lg .tag .l1{ font-size:16px }
body.label-lg .tag .l2{ font-size:14px }



/* state-driven colors (freeze value into --tagColor) */
.tag.st-controlled { color:#69ff8a; --tagColor:#69ff8a; }  /* green */
.tag.st-inbound    { color:#ffffff; --tagColor:#ffffff; }  /* white */
.tag.st-intruder   { color:#ffd9b3; --tagColor:#ffd9b3; }  /* light orange */
.tag.st-outbound   { color:#9aa3aa; --tagColor:#9aa3aa; }  /* greyed out */

/* highlight the field currently being edited */
.tag [data-act].editing{
  outline:1px dashed currentColor;
  outline-offset:2px;
  border-radius:4px;
  padding:0 2px;
}

/* Reserve space so labels don't jump on hover */
.tag .ops{
  display:block;            /* always in flow */
  visibility:hidden;        /* hidden but taking space */
  opacity:0;
  transition: opacity .12s ease;
  white-space:nowrap;       /* prevent wrapping (VS stays on one line) */
}
.tag:hover .ops,
.tag.is-selected .ops,
.tag.show-ops .ops{
  visibility:visible;
  opacity:1;
}



/* tiny inline button to mark handoff (optional) */
.tag .ho{
  display:inline-block; margin-left:8px; padding:1px 6px;
  font-size:10px; border:1px solid currentColor; border-radius:999px;
  cursor:pointer;
}


/* keep your existing tiny pill styles */
.tag .ho{ transition: transform .06s ease, background .12s ease; }
.tag .ho:active{ transform: translateY(1px) scale(0.98); }

/* keep H/O / XFER pill width stable */
.tag .ho{ min-width:34px; text-align:center; }


/* ADD THIS BLOCK DIRECTLY BELOW */
.tag .ho[aria-pressed="true"]{
  background: var(--tagColor);      /* captured from .tag’s currentColor */
  border-color: var(--tagColor);
  color: var(--bg);                  /* readable text */
  box-shadow: 0 0 0 1px var(--bg);   /* thin outline so it never “vanishes” */
}

/* === Conflict badges above callsign === */
.tag .badges{ margin-bottom:2px; }
.tag .badge{
  display:inline-block; padding:1px 6px; border-radius:999px;
  font-size:10px; line-height:1; letter-spacing:.3px;
  border:1px solid currentColor; opacity:0.95;
}
.tag .badge.warn  { color:#ffcc66; border-color:#ffcc66; }
.tag .badge.alert { color:#ff6a6a; border-color:#ff6a6a; }




  .tag:hover,.tag.dragging{opacity:1}
  .tag .line1{font-weight:600}
  .tag .line2{font-size:12px; color:var(--muted)}
  .tag.alert{border-color:var(--alert)}
  .tag.warn{border-color:var(--warn)}
  .pill{padding:2px 6px; border:1px solid #2c4a5f; border-radius:999px; background:#0c1b25; font-size:11px; color:var(--muted)}
  .waypointLabel{
  position:absolute;
  background:transparent;
  border:0 solid #2c4a5f;
  border-radius:6px;
  padding:0 6px;
  font-size:11px;
  color:#9fb3c1;
  opacity:.55;
  user-select:none;
  pointer-events:none;
}

  /* --- SFP floating window --- */
.sfpWin{
  position:absolute; right:12px; top:64px; width:260px;
  background:#0b1620; border:1px solid #1b3a4f; border-radius:10px;
  box-shadow:0 6px 18px rgba(0,0,0,.35); z-index:20; user-select:auto;
}
.sfpWin .hdr{ cursor:grab; }
.sfpWin.is-dragging .hdr{ cursor:grabbing; }

.sfpWin .hdr{
  display:flex; align-items:center; justify-content:space-between;
  padding:8px 10px; border-bottom:1px solid #173243; color:#9fb3c1; font-size:12px;
  background:linear-gradient(180deg,#0e1820,#0b141a);
  border-top-left-radius:10px; border-top-right-radius:10px;
}
.sfpWin .hdr .title{ font-weight:600; color:#cfe8f7; font-size:12px; letter-spacing:.3px }
.sfpWin .hdr button{
  background:#0d1a22; border:1px solid #274b64; color:#cfe8f7; padding:4px 8px; border-radius:6px; cursor:pointer;
}
.sfpWin .body{ padding:10px }
.sfpWin table{ width:100%; border-collapse:collapse; font-size:12px; color:#cfe8f7 }
.sfpWin td{ padding:4px 0; vertical-align:top }
.sfpWin td.key{ color:#9fb3c1; width:88px }
.sfpWin .route{ margin-top:8px; font-size:12px; color:#9ad6ff; line-height:1.35 }

/* --- FL picker popover ----------------------------------------------- */
.levelPicker{
  position:absolute; z-index:50;
  background:#0b1620; border:1px solid #1b3a4f; border-radius:8px;
  box-shadow:0 10px 24px rgba(0,0,0,.45);
  max-height:260px; width:140px; overflow:auto; padding:0;
}
.levelPicker .hdr{
  position:sticky; top:0; background:#0b1620;
  padding:8px; border-bottom:1px solid #173243;
}
.levelPicker .hdr input{
  width:100%; padding:6px 8px;
  background:#0d1a22; border:1px solid #274b64; border-radius:6px;
  color:#e8eef2; font:12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
  outline:none;
}
.levelPicker .item{
  font:12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
  color:#cfe8f7; padding:6px 10px; cursor:pointer; white-space:nowrap;
}
.levelPicker .item:hover, .levelPicker .item[aria-selected="true"]{
  background:#0d2230; color:#8fd3ff;
}
.levelPicker .tip{
  padding:6px 10px; color:#9fb3c1; font-size:11px; border-top:1px solid #173243;
}


</style>
</head>
<body>
<header>
  <h1>ATC Radar Trainer — v8.1</h1>
  <div class="controls">
    <button id="spawn">Spawn traffic</button>
    <label class="small">
  <input id="autoSpawnToggle" type="checkbox"> Auto-spawn
</label>
<button id="spawnConflict">Spawn conflict</button>

    <button id="clear">Clear all</button>
    <button id="pause">Pause</button>
    <label class="small">Range (NM)
      <select id="rangeSel">
  <option>20</option>
  <option>40</option>
  <option>60</option>
  <option>80</option>
  <option selected>120</option>
  <option>160</option>
  <option>200</option>
  <option>240</option>
  <option>320</option>
  <option>400</option>
  <option>600</option>
  <option>800</option>
</select>

    </label>
    <label class="small">Sim speed
      <select id="simSpeed"><option value="0.5">0.5×</option><option value="1" selected>1×</option><option value="2">2×</option><option value="4">4×</option></select>
    </label>
    <label class="small">Labels
  <select id="labelSize">
    <option value="sm">Small</option>
    <option value="md" selected>Medium</option>
    <option value="lg">Large</option>
  </select>
</label>

  </div>
</header>

<div id="radarWrap">
  <canvas id="radar"></canvas>
</div>

<aside>
  <div class="section">
    <div class="row"><strong>Selected track</strong></div>
    <div id="selectedInfo" class="aircraftCard small">Tap/click a tag to select; drag tags anywhere (works on mobile).</div>
  </div>

  <div class="section">
    <div class="row"><strong>Vectors</strong></div>
    <div class="row">
      <label for="hdg">Heading</label>
      <input id="hdg" type="number" min="1" max="360" placeholder="1–360">
      <button id="btnHdg">Issue vector</button>
    </div>
    <div class="row small">Standard-rate ≈3°/s, shortest way. (Displays 360, not 000.)</div>
  </div>

  <div class="section">
    <div class="row"><strong>Altitude</strong></div>
    <div class="row">
      <label for="alt">Altitude</label>
      <input id="alt" type="number" step="1" min="0" placeholder="e.g. 150">
      <button id="btnAlt">Climb/Descent</button>
    </div>
    <div class="row">
      <label for="vs">Vertical speed</label>
      <input id="vs" type="number" step="100" placeholder="×100 fpm (default 18)">
      <button id="btnHold">Altitude hold</button>
    </div>
    <div class="row small">
      <label><input id="useFL" type="checkbox" checked> Enter Flight Level (e.g., <b>150</b> for FL150)</label>
      <span id="altModeHint" class="small"></span>
    </div>
  </div>

  <div class="section">
    <div class="row"><strong>Speed</strong></div>
    <div class="row">
      <label for="spd">IAS (kt)</label>
      <input id="spd" type="number" step="5" min="60" placeholder="e.g. 250">
      <button id="btnSpd">Set kt</button>
    </div>
    <div class="row">
      <label for="mach">Mach</label>
      <input id="mach" type="number" step="0.01" min="0.30" max="0.99" placeholder="e.g. 0.78">
      <button id="btnMach">Set M</button>
    </div>
    <div class="row small">Mach converts using ISA a(alt).</div>
  </div>

  <div class="section">
    <div class="row"><strong>Predict vectors</strong></div>
    <div class="row small">
      <label><input type="checkbox" id="pred1" checked> 1 min</label>
      <label><input type="checkbox" id="pred3" checked> 3 min</label>
      <label><input type="checkbox" id="pred5" checked> 5 min</label>
      <label style="margin-left:auto;">Show for
        <select id="predFor"><option value="sel">selected</option><option value="all" selected>all tracks</option></select>
      </label>
    </div>
    <div class="row small">Solid lines only; no labels on scope.</div>
  </div>

  <div class="section">
    <div class="row"><strong>Conflict alerts</strong></div>
    <div class="row small">Minima: <span class="pill">5 NM</span> / <span class="pill">1000 ft</span></div>
    <div class="row">
      <label for="lookahead">Lookahead</label>
      <select id="lookahead"><option value="0">0 min (current)</option><option value="1">1 min</option><option value="2" selected>2 min</option><option value="3">3 min</option></select>
    </div>
    <div class="row small">Red = actual, Amber = predicted within lookahead.</div>
  </div>

  <!-- NEW: Measure tool controls -->
  <div class="section">
    <div class="row"><strong>Measure tool</strong></div>
    <div class="row">
      <button id="clearRulers">Clear rulers</button>
    </div>
    <div class="row small">Shift+LMB = start/finish (snaps to nearest a/c) •
Plain Left Click = place ruler •
Esc = delete last ruler</div>
  </div>

  <div class="section">
    <div class="row"><strong>Altitude filter</strong></div>
    <div class="row">
      <label for="fltMin">Min (ft)</label><input id="fltMin" type="number" step="100" value="0">
      <label for="fltMax">Max (ft)</label><input id="fltMax" type="number" step="100" value="60000">
      <button id="btnFilter">Apply</button>
    </div>
    <div class="row small">Off-band tracks dimmed.</div>
  </div>

  <div class="section">
    <div class="row"><strong>Waypoints & Direct-to</strong></div>
    <div class="row">
      <button id="addWpt">Add waypoint</button>
      <button id="clearWpt">Clear wpts</button>
    </div>
    <div id="wptList" class="small"></div>
  </div>

  <div class="section">
    <div class="row"><strong>Sector (rectangular)</strong></div>
    <div class="row small">Rect centered on scope. Handoff triggers when crossing the rectangle boundary.</div>
    <div class="row">
      <label for="rectW">Width (NM)</label><input id="rectW" type="number" value="160">
      <label for="rectH">Height (NM)</label><input id="rectH" type="number" value="120">
      <button id="btnRect">Apply</button>
    </div>
    <div class="row small">
      <label><input id="autoHandoff" type="checkbox" checked> Auto-handoff</label>
      <button id="btnHandoff">Handoff selected</button>
    </div>
  </div>

  <div class="section small">
    <div class="row"><strong>Shortcuts</strong></div>
    <div class="grid2">
      <div><span class="kbd">H</span> vector • <span class="kbd">A</span> altitude • <span class="kbd">S</span> speed • <span class="kbd">M</span> Mach</div>
      <div><span class="kbd">Space</span> pause • <span class="kbd">N</span> spawn • Click scope to add waypoint (when enabled)</div>
    </div>
  </div>
</aside>

<script>
  // ---------- Utilities ----------
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const toRad=d=>d*Math.PI/180; const toDeg=r=>r*180/Math.PI;
  const mod360=d=>(d%360+360)%360;
  const nmPerKtPerSec = 1/3600; const ftPerMinToFtPerSec = 1/60;
  // --- fix pass logic (buffer + trend) ---
const FIX_PASS_NM = 1.2;       // consider a fix 'made' when within this many NM
const FIX_PASS_TREND_NM = 2.0; // or, if we've been closer than this and range starts increasing, also 'made'

function managedSpeedTargetKt(a){
  const alt = a.alt_ft;

  // Base schedule in IAS
  let tgtIAS = (alt <  5000) ? 220 :
               (alt < 10000) ? 240 :
               (alt < 24000) ? 300 :
               // High level: prefer planned TAS but convert to IAS at current ISA
               tasToIas(a.fp?.tasKt || 450, alt);

  // Descents / arrivals: progressive slows (still IAS)
  if (a.vs_fpm < -200 || a.role === 'arrival'){
    if (alt < 12000) tgtIAS = Math.min(tgtIAS, 280);
    if (alt < 10000) tgtIAS = Math.min(tgtIAS, 240);
    if (alt <  6000) tgtIAS = Math.min(tgtIAS, 220);
    if (alt <  3000) tgtIAS = Math.min(tgtIAS, 200);
  }
  return tgtIAS;
}


  function isaSpeedOfSoundKts(alt_ft){
    const h = Math.max(0, Math.min(86000, alt_ft)) * 0.3048;
    let T; if(h<=11000) T=288.15-0.0065*h; else if(h<=20000) T=216.65; else T=216.65+0.001*(h-20000);
    const a_ms = Math.sqrt(1.4*287.05287*T); return a_ms*1.943844;
  }
  
  // === ISA state (pressure/temp/density) + IAS↔TAS ===
function isaState(alt_ft){
  const h = Math.max(0, Math.min(86000, alt_ft)) * 0.3048; // ft→m (cap 86 km)
  const T0 = 288.15, p0 = 101325, g = 9.80665, R = 287.05287;

  // Layer bases
  const h11 = 11000, T11 = 216.65;
  const L_tropo = -0.0065;   // K/m
  const L_strat1 = +0.001;   // K/m (20–32 km)

  if (h <= h11){
    const T = T0 + L_tropo*h;
    const theta = T / T0;
    const delta = Math.pow(theta, -g/(L_tropo*R));
    const sigma = delta / theta;
    return { theta, delta, sigma };
  }

  // 11–20 km: isothermal at 216.65 K
  const theta11 = T11 / T0;
  const delta11 = Math.pow(theta11, -g/(L_tropo*R)); // carry-over from 0–11 km
  if (h <= 20000){
    const T = T11;
    const theta = T / T0;
    const delta = delta11 * Math.exp(-g*(h - h11)/(R*T));
    const sigma = delta / theta;
    return { theta, delta, sigma };
  }

  // 20–32 km: +0.001 K/m
  const T20 = T11;
  const delta20 = delta11 * Math.exp(-g*(20000 - h11)/(R*T11));
  const T = T20 + L_strat1*(h - 20000);
  const theta = T / T0;
  const delta = delta20 * Math.pow(T / T20, -g/(L_strat1*R));
  const sigma = delta / theta;
  return { theta, delta, sigma };
}

function isaSigma(alt_ft){ return isaState(alt_ft).sigma; }
function iasToTas(ias_kt, alt_ft){
  const s = Math.max(1e-6, isaSigma(alt_ft));
  return ias_kt / Math.sqrt(s);
}
function tasToIas(tas_kt, alt_ft){
  const s = Math.max(1e-6, isaSigma(alt_ft));
  return tas_kt * Math.sqrt(s);
}

  function formatHeading(h){
    let n = Math.round(mod360(h));
    n = n===0 ? 360 : n;
    return String(n).padStart(3,'0');
  }
  function parseAltitudeInput(val, useFL){
    if(val===""||val==null) return null;
    let txt = String(val).trim().toUpperCase();
    if(useFL){
      if(txt.startsWith("FL")) txt = txt.slice(2);
      const fl = parseInt(txt,10);
      if(Number.isFinite(fl)) return fl*100;
      return null;
    }else{
      if(txt.startsWith("FL")){
        const fl=parseInt(txt.slice(2),10); return Number.isFinite(fl)? fl*100:null;
      }
      const ft = parseInt(txt,10); return Number.isFinite(ft)? ft:null;
    }
  }
  function bearingFromTo(x1,y1,x2,y2){
    return mod360(toDeg(Math.atan2(x2-x1, -(y2-y1))));
  }

// signed angle (deg) between two vectors originating at the *same* point
function turnAngleDeg(ax, ay, bx, by){
  const dot  = ax*bx + ay*by;
  const det  = ax*by - ay*bx;          // cross-product z-component
  const ang  = Math.atan2(det, dot);   // −π … +π
  return Math.abs(ang * 180 / Math.PI);
}

// --- Lead-turn helpers (fly-by) ---
function angleDiffDeg(a, b){
  let d = mod360(a - b);
  return d > 180 ? 360 - d : d;
}
function turnRadiusNmFor(ac){
  // R = v/ω ; v in NM/s, ω in rad/s
  const v_nms = ac.spd_kt * nmPerKtPerSec;
  const omega = toRad(Math.max(0.1, ac.turnRateDps)); // deg/s -> rad/s
  return v_nms / omega; // NM
}
function leadTurnDistanceNm(ac, curFix, nextFix){
  if (!curFix || !nextFix) return 0;
  const inbound  = bearingFromTo(ac.x_nm, ac.y_nm, curFix.x_nm, curFix.y_nm);
  const outbound = bearingFromTo(curFix.x_nm, curFix.y_nm, nextFix.x_nm, nextFix.y_nm);
  const delta = angleDiffDeg(outbound, inbound);
  if (delta < 3) return 0;                 // essentially straight
  const R = turnRadiusNmFor(ac);
  const lead = R * Math.tan(toRad(delta/2));
  return clamp(lead, 0.2, 12);             // keep it sane
}


  function nextWptName(a, env){
  if(a.navMode==="DIRECT" && a.directWptId) return env.getWaypoint(a.directWptId)?.name || "—";
  if(a.navMode==="ROUTE" && a.routeIdx < a.route.length) return env.getWaypoint(a.route[a.routeIdx])?.name || "—";
  return "—";
}
function fmtFLshort(ft){ return 'FL' + String(Math.round(ft/100)).padStart(3,'0'); }
function fmtCFL(ft){ return 'CFL' + String(Math.round(ft/100)).padStart(3,'0'); }
function fmtVS100(vs_fpm){
  const h = Math.round(vs_fpm/100);
  if (h===0) return "0";
  return (h>0?"+":"−") + Math.abs(h);
}
function parseVsHundreds(txt){
  if (txt==null) return null;
  const n = parseInt(String(txt).trim(),10);
  return Number.isFinite(n) ? n*100 : null;  // “18” -> 1800 fpm
}
function fmtXFL(ft){
  return ft==null ? "XFL—" : ("XFL" + String(Math.round(ft/100)).padStart(3,'0'));
}


function getTrackState(a){
  if (a.inSector){
    // In our airspace: green if controlled; “intruder” color if already handed off
    return a.handedOff ? "intruder" : "controlled";
  } else {
    // Outside: inbound (never seen) vs outbound (has been ours)
    return a.everInRect ? "outbound" : "inbound";
  }
}


  // --- Short Flight Plan (SFP) & helpers ---
const DEP_PORTS = ["EPWA","EPMO","EPLL","EPWR","EPPO","EPKK","EPKT","LKPR"];
const ARR_PORTS = ["EPWA","EPMO","EPLL","EPWR","EPPO","EPKK","EPKT","LKPR"];
const TYPES     = ["A320","B738","E190","B744","B789"];

const rand = (a,b)=> a + Math.random()*(b-a);
const randi = (a,b)=> Math.floor(rand(a,b+1));
const pick = arr => arr[Math.floor(Math.random()*arr.length)];

// Departures: climb targets per airport (Flight Levels)
const DEPART_CLIMB_FL = {
  EPWA: 240,
  EPMO: 240,
  EPLL: 100,
  EPWR: 100,
  EPPO: 190,
  EPKK: 280,  
  EPKT: 180,
  LKPR: 270
};

// Helper: pick a random valid departure airport that exists in WP
function pickDepartureAirport(){
  const names = Object.keys(DEPART_CLIMB_FL);
  const fixes = names.map(n => WP[n]).filter(Boolean);
  return fixes.length ? fixes[Math.floor(Math.random()*fixes.length)] : null;
}


function forceMidBetween(entryId, exitId){
  // Try the gentle picker first
  let mid = pickGentleMidFix(entryId, exitId, 40, 50);
  if (mid) return mid;

  // Fallback 1: closest-to-segment dynamic waypoint (keeps it reasonable)
  const A = getWPById(entryId), B = getWPById(exitId);
  if (A && B && wpts.length){
    const dx = B.x_nm - A.x_nm, dy = B.y_nm - A.y_nm, len2 = dx*dx + dy*dy;
    if (len2 > 1e-6){
      let best=null, bestOff=Infinity;
      for (const w of wpts){
        const t = ((w.x_nm - A.x_nm)*dx + (w.y_nm - A.y_nm)*dy) / len2;
        if (t <= 0 || t >= 1) continue; // avoid extremes
        const px = A.x_nm + t*dx, py = A.y_nm + t*dy;
        const off = Math.hypot(w.x_nm - px, w.y_nm - py);
        if (off < bestOff){ bestOff = off; best = w.id; }
      }
      if (best != null) return best;
    }
  }

  


  // Fallback 2: nearest-to-center dynamic waypoint
  if (wpts.length){
    return wpts.reduce((b,w)=>{
      const d = Math.hypot(w.x_nm,w.y_nm);
      return d < b.d ? {id:w.id,d} : b;
    }, {id:null,d:Infinity}).id;
  }
  return null;
}


 function findNearestAcPx(xPx, yPx, tolPx=16){
  let best=null, bestD=Infinity;
  for(const a of state.ac){
    const ax = cx + nmToPx(a.x_nm);
    const ay = cy + nmToPx(a.y_nm);
    const d = Math.hypot(ax - xPx, ay - yPx);
    if(d < bestD){ bestD = d; best = a; }
  }
  return bestD <= tolPx ? best : null;
}

function resolveEndpoint(ep){
  if(!ep) return null;
  if(ep.type === 'ac'){
    const ac = state.ac.find(a=>a.id===ep.id);
    if(!ac) return null; // a/c may have been cleared
    return { x_nm: ac.x_nm, y_nm: ac.y_nm };
  }
  // point endpoint
  if('x_nm' in ep && 'y_nm' in ep) return { x_nm: ep.x_nm, y_nm: ep.y_nm };
  return null;
}


  // ---------- Aircraft ----------
  let nextId=1;
  function genCallsign(){
    const ops=["LOT","DLH","BAW","RYR","WZZ","KLM","AFR","AUA","SAS","UAE","QTR","IBE"];
    return ops[Math.floor(Math.random()*ops.length)]+String(Math.floor(100+Math.random()*899));
  }

  class Aircraft{
    constructor(opts){
      this.id=nextId++; this.cs=opts.cs||genCallsign();
      this.x_nm=opts.x_nm??0; this.y_nm=opts.y_nm??0;
      this.hdg=opts.hdg??Math.floor(Math.random()*360);
      this.alt_ft=opts.alt_ft??(30000);
      this.spd_kt=opts.spd_kt??(this.alt_ft>24000?450:250);
      // Canonical speed: keep IAS as the commanded/editable state
      this.ias_kt = tasToIas(this.spd_kt, this.alt_ft); // derive IAS from initial TAS
      this.fp = opts.fp ?? null;   // Short Flight Plan (dep, dest, cruiseFL, tasKt, type)
      this.type = opts.type ?? pick(TYPES);   // <-- new: default a random type
      this.route = [];         // array of waypoint ids
      this.routeIdx = 0;       // current active leg target index
      this.role = opts.role ?? null;     // 'arrival' | 'departure' | 'transit'
      this.finishedAtSec = null;         // when last fix passed
      this.xfl_ft = null;   // expected final level (feet)
      this.managedSpd = true;            // auto schedule until pilot sets speed




      // Dotted trail: last 5 positions max
      this.trail=[]; this.trailMax=5;

      // Targets
      this.tgtHdg=this.hdg; this.tgtAlt=this.alt_ft;
      this.vs_fpm=0; this.defaultVS=2000;

    // Speed targets (IAS primary). 'KT' here = IAS.
      this.tgtSpeedMode="KT";
      this.tgtIAS_kt = this.ias_kt;
      this.tgtSpd_kt = this.tgtIAS_kt; // legacy field for UI
      this.tgtMach=null;


      // Dynamics
      this.turnRateDps=3; this.accel_ktps=1.0; this.maxVS_fps=4000*ftPerMinToFtPerSec;

      // Nav
      this.navMode=null; this.directWptId=null;
          this.route = [];        // array of waypoint ids
    this.routeIdx = 0;      // which fix we’re heading to now
    // pass logic helpers
this.prevDistToTarget = null; // last range to active fix
this.lastNavTargetId   = null; // which fix that range belonged to



      // Label offsets
      this.labelDx=12; this.labelDy=-16;
      // Visibility/despawn bookkeeping
this.seenOnScreenOnce = false;
this.spawnSec = (typeof simNowSec !== 'undefined') ? simNowSec : 0;


      // Rect/sector state
this.inSector  = true;
this.handedOff = false;   // true = we’ve transferred control (no longer ours)
this.hoArmed   = false;   // true = user tapped H/O (armed for auto/next handoff)

// coloring / state bookkeeping
this.everInRect = env.inRect(this.x_nm, this.y_nm, this.alt_ft); // ever been in sector (3D)


    }
    setHeading(h){ this.navMode=null; this.directWptId=null; this.tgtHdg=mod360(h); }
    setAltitude(alt_ft, vs = null){
  this.tgtAlt = Math.max(0, Math.round(alt_ft));
  const goingUp = this.tgtAlt > this.alt_ft;

  // Requested magnitude (default 2000 fpm if none given)
  const reqMag = vs == null ? 2000 : Math.max(0, Math.abs(vs));
  let mag = reqMag;

  // If we are already at/above FL250 and commanding a CLIMB, force +500 fpm now.
  if (goingUp && this.alt_ft >= 25000) mag = Math.min(mag, 500);

  this.vs_fpm = (goingUp ? +1 : -1) * mag;
}


    holdAltitude(){ this.tgtAlt=this.alt_ft; this.vs_fpm=0; }
    setSpeedKt(kt){ // interpreted as IAS
  this.tgtSpeedMode = "KT";
  this.tgtIAS_kt    = Math.max(60, kt|0);
  this.tgtSpd_kt    = this.tgtIAS_kt; // keep UI compatible
  this.tgtMach      = null;
  this.managedSpd   = false;
}
setMach(m){
  this.tgtSpeedMode = "MACH";
  this.tgtMach      = clamp(m,0.3,0.99);
  this.managedSpd   = false;
}


    directTo(id){ this.navMode="DIRECT"; this.directWptId=id; }
    get mach(){ return this.spd_kt/isaSpeedOfSoundKts(this.alt_ft); }
      setRoute(ids){
    this.route = Array.isArray(ids) ? ids.slice() : [];
    this.routeIdx = 0;
    this.navMode = this.route.length ? "ROUTE" : null;
    this.directWptId = null; // clear direct if switching
  }


    update(dt, env){
        

// --- DIRECT-to nav (with fly-by lead turn) ---
if (this.navMode==="DIRECT" && this.directWptId!=null){
  const cur = env.getWaypoint(this.directWptId);
  if (cur){
    // Default: steer to the current fix
    const hdgTo = bearingFromTo(this.x_nm, this.y_nm, cur.x_nm, cur.y_nm);
    this.tgtHdg = hdgTo;
    const dist  = Math.hypot(cur.x_nm - this.x_nm, cur.y_nm - this.y_nm);

    // If this DIRECT target is in our route and there’s a next fix, start a fly-by turn early
    const idxInRoute = Array.isArray(this.route) ? this.route.indexOf(this.directWptId) : -1;
    if (idxInRoute >= 0 && idxInRoute + 1 < this.route.length){
      const nxt = env.getWaypoint(this.route[idxInRoute + 1]);
      const leadNm = leadTurnDistanceNm(this, cur, nxt);

      if (dist <= Math.max(leadNm, FIX_PASS_NM * 0.5)){ // don’t be absurdly early
        // Advance immediately to next leg
        this.directWptId = null;
        this.navMode  = "ROUTE";
        this.routeIdx = idxInRoute + 1;

        // Steer into outbound course right away
        const outHdg = bearingFromTo(cur.x_nm, cur.y_nm, nxt.x_nm, nxt.y_nm);
        this.tgtHdg = outHdg;

        this.prevDistToTarget = null;
        this.lastNavTargetId  = null;
      }
    }

    // Standard pass/trend logic if we’re still on the current DIRECT
    if (this.navMode === "DIRECT"){
      if (this.lastNavTargetId !== this.directWptId) this.prevDistToTarget = null;

      const passed =
        dist < FIX_PASS_NM ||
        (this.prevDistToTarget != null &&
         this.prevDistToTarget < FIX_PASS_TREND_NM &&
         dist > this.prevDistToTarget);

      if (passed){
        const idx = Array.isArray(this.route) ? this.route.indexOf(this.directWptId) : -1;
        this.directWptId = null;

        if (idx >= 0 && idx + 1 < this.route.length){
          this.routeIdx = idx + 1;
          this.navMode  = "ROUTE";
        } else {
          this.navMode = null;
          this.tgtHdg  = this.hdg;
          if (idx >= 0 && idx === (this.route?.length || 0) - 1){
            if (this.finishedAtSec == null) this.finishedAtSec = simNowSec;
          }
        }
        this.prevDistToTarget = null;
        this.lastNavTargetId  = null;
      } else {
        this.lastNavTargetId  = this.directWptId;
        this.prevDistToTarget = dist;
      }
    }
  } else {
    // Waypoint missing → cancel DIR and hold current
    this.directWptId = null;
    this.navMode     = null;
    this.tgtHdg      = this.hdg;
    this.prevDistToTarget = null;
    this.lastNavTargetId  = null;
  }
}


// --- ROUTE nav: fly-by turns with lead distance ---
if (this.navMode==="ROUTE" && this.routeIdx < this.route.length){
  const curId = this.route[this.routeIdx];
  const cur   = env.getWaypoint(curId);
  if (cur){
    // Steer to current fix by default
    const hdgTo = bearingFromTo(this.x_nm, this.y_nm, cur.x_nm, cur.y_nm);
    this.tgtHdg = hdgTo;
    const dist  = Math.hypot(cur.x_nm - this.x_nm, cur.y_nm - this.y_nm);

    if (this.lastNavTargetId !== curId) this.prevDistToTarget = null;

    // If there is a next leg, start the turn early based on geometry
    const nxtId = this.route[this.routeIdx + 1] ?? null;
    if (nxtId != null){
      const nxt    = env.getWaypoint(nxtId);
      const leadNm = leadTurnDistanceNm(this, cur, nxt);

      if (dist <= Math.max(leadNm, FIX_PASS_NM * 0.5)){
        // Early advance (fly-by)
        this.routeIdx++;
        this.prevDistToTarget = null;
        this.lastNavTargetId  = null;

        // If route ended right here, fall through to completion block below on next tick
        if (this.routeIdx < this.route.length){
          // Immediately steer to outbound
          const outHdg = bearingFromTo(cur.x_nm, cur.y_nm, nxt.x_nm, nxt.y_nm);
          this.tgtHdg = outHdg;
        }
      }
    }

    // Standard pass/trend fallback if we didn’t early-advance this tick
    if (this.lastNavTargetId === curId || this.prevDistToTarget !== null){
      const passed =
        dist < FIX_PASS_NM ||
        (this.prevDistToTarget != null &&
         this.prevDistToTarget < FIX_PASS_TREND_NM &&
         dist > this.prevDistToTarget);

      if (passed){
        this.routeIdx++;
        this.prevDistToTarget = null;
        this.lastNavTargetId  = null;
      } else {
        this.lastNavTargetId  = curId;
        this.prevDistToTarget = dist;
      }
    }

    // Completion: if we just consumed the last fix, continue present heading
    if (this.routeIdx >= this.route.length){
      this.navMode = null;
      this.tgtHdg  = this.hdg;
      if (this.finishedAtSec == null) this.finishedAtSec = simNowSec;
    }
  } else {
    this.navMode = null;
    this.tgtHdg  = this.hdg;
    this.prevDistToTarget = null;
    this.lastNavTargetId  = null;
  }
}




      let diff = mod360(this.tgtHdg-this.hdg); if(diff>180) diff-=360;
      const maxTurn=this.turnRateDps*dt; if(Math.abs(diff)<maxTurn) this.hdg=this.tgtHdg; else this.hdg=mod360(this.hdg+Math.sign(diff)*maxTurn);

    /* === SPEED MODEL (IAS ↔ TAS ↔ Mach) ================================ */
// Managed schedule → IAS target
if (this.managedSpd){
  this.tgtSpeedMode = "KT";                 // IAS mode
  this.tgtIAS_kt    = managedSpeedTargetKt(this);
  this.tgtMach      = null;
}

// Mach target → IAS (via TAS)
if (this.tgtSpeedMode === "MACH" && this.tgtMach){
  const a_kts  = isaSpeedOfSoundKts(this.alt_ft);
  const tasTgt = this.tgtMach * a_kts;
  this.tgtIAS_kt = tasToIas(tasTgt, this.alt_ft);
}



// Accelerate in IAS space
{
  const dIAS = this.tgtIAS_kt - this.ias_kt;
  const maxAccIAS = this.accel_ktps * dt;
  if (Math.abs(dIAS) < maxAccIAS) this.ias_kt = this.tgtIAS_kt;
  else this.ias_kt += Math.sign(dIAS) * maxAccIAS;
}

// Convert IAS→TAS; physics uses TAS; GS = TAS (no wind)
{
  const tasNow = iasToTas(this.ias_kt, this.alt_ft);
  this.spd_kt  = tasNow;
  // keep legacy target field for any UI still reading it
  this.tgtSpd_kt = this.tgtIAS_kt;
}
/* =================================================================== */


      if (this.alt_ft !== this.tgtAlt){
  const climbing = this.tgtAlt > this.alt_ft;

  // Start from the current commanded VS (pilot or default)
  let vs_fpm = this.vs_fpm;

  // While CLIMBING at/above FL250, hard-cap to +500 fpm (auto-hop when we reach it).
  if (climbing && this.alt_ft >= 25000){
    vs_fpm = Math.min(vs_fpm, 500);
  }

  // Convert to fps & soften near level-off
  let vs_fps = vs_fpm * ftPerMinToFtPerSec;
  const delta = this.tgtAlt - this.alt_ft;
  if (Math.abs(delta) < 600){
    const s = Math.sign(delta);
    vs_fps = s * Math.min(Math.abs(vs_fps), 800 * ftPerMinToFtPerSec);
  }

  vs_fps = clamp(vs_fps, -this.maxVS_fps, this.maxVS_fps);
  const step = vs_fps * dt;
  if (Math.sign(delta) !== Math.sign(step) || Math.abs(step) > Math.abs(delta)){
    this.alt_ft = this.tgtAlt;
    this.vs_fpm = 0;
  } else {
    this.alt_ft += step;
  }
}


      const dist_nm=this.spd_kt*nmPerKtPerSec*dt;
      this.x_nm += Math.sin(toRad(this.hdg))*dist_nm;
      this.y_nm += -Math.cos(toRad(this.hdg))*dist_nm;

      // Sector (rectangle)
const inside = env.inRect(this.x_nm, this.y_nm, this.alt_ft);
if (inside) this.everInRect = true;

// crossing flags
const leftSector    = this.inSector && !inside;
const enteredSector = !this.inSector && inside;

// update geometry state
this.inSector = inside;

// Reacquire on entry: once inside, we control again
if (enteredSector){
  this.handedOff = false;
}

// On exit: optional auto-handoff + your existing behaviour
if (leftSector) {
  // Complete handoff if auto is on, or if user armed H/O
  if (env.autoHandoff || this.hoArmed){
    this.handedOff = true;
    this.hoArmed   = false; // disarm after use
  }

  // Your existing exit logic
  const hasRoute = Array.isArray(this.route) && this.route.length > 0;
  if (hasRoute) {
    const lastId = this.route[this.route.length - 1];
    this.directTo(lastId);
    this.navMode = "DIRECT";
  } else {
    this.navMode = null;
    this.directWptId = null;
    this.tgtHdg = this.hdg;
  }

  // Arrivals keep descending after leaving our sector to reach FL0.
  if (this.role === 'arrival') {
    this.setAltitude(0, 2000);
  }
}



      // Dotted trail (every step call adds one); keep only last 5
      this.trail.push({x:this.x_nm,y:this.y_nm});
      if(this.trail.length>this.trailMax) this.trail.shift();
    }
  }

 // ---------- World / Sim ----------
const canvas=document.getElementById('radar'); const ctx=canvas.getContext('2d');
const wrap=document.getElementById('radarWrap');
let W=0,H=0,cx=0,cy=0;
// Center shift in **pixels** ( +x = push content right, -y = push content up )
const CENTER_SHIFT = { x: -90, y: 60 };  // tweak to taste
// Runtime pan offset in pixels (updated by RMB drag)
let PAN = { x: 0, y: 0 };

// Input state for panning
let isPanning = false;
let panStartClient = { x: 0, y: 0 };
let panStartPx = { x: 0, y: 0 };


let booted = false;

function resize(){
  const r=wrap.getBoundingClientRect();
  canvas.width=r.width; canvas.height=r.height;
  W=canvas.width; H=canvas.height;
cx = W/2 + CENTER_SHIFT.x + PAN.x;
cy = H/2 + CENTER_SHIFT.y + PAN.y;


  if (booted) drawAll(); // only redraw after full boot
  repositionLevelPicker();

}
window.addEventListener('resize', resize);

  let rangeNM=80; function nmToPx(nm){ return nm*(Math.min(W,H)/2)/rangeNM; }
  function pxToNm(xPx,yPx){ return { x_nm:(xPx-cx)*rangeNM/(Math.min(W,H)/2), y_nm:(yPx-cy)*rangeNM/(Math.min(W,H)/2) }; }
  function isOnScreenPx(x_px, y_px, marginPx=24){
  return x_px >= -marginPx && x_px <= W + marginPx &&
         y_px >= -marginPx && y_px <= H + marginPx;
}
function acIsOnScreen(a, marginPx=24){
  const x = cx + nmToPx(a.x_nm);
  const y = cy + nmToPx(a.y_nm);
  return isOnScreenPx(x, y, marginPx);
}

function acInScopeNm(a, marginNm=0){
  // inside the circular scope radius + margin
  return Math.hypot(a.x_nm, a.y_nm) <= (rangeNM + marginNm);
}

// ===== NEW sector polygon (nm, centered at 0,0) =====
const SECTOR_POLY = [
  [-75.42, -26.46],
  [30.31, -38.83],
  [29.17, -96.40],
  [108.72, -81.29],
  [128.23, -60.85],
  [125.98, -24.29],
  [84.27, -2.74],
  [46.48, 41.59],
  [46.07, 64.62],
  [41.86, 66.49],
  [39.82, 67.02],
  [26.74, 57.32],
  [33.13, 53.43],
  [31.66, 50.17],
  [19.74, 51.18],
  [-1.33, 40.22],
  [5.12, 49.33],
  [-7.41, 60.37],
  [-27.20, 39.93],
  [-17.12, 30.91],
  [-25.49, 25.85],
  [-33.91, 29.46],
  [-41.71, 20.33],
  [-58.07, 16.85],
  [-60.59, 7.22],
  [-68.56, 4.46],
  [-71.54, 3.90],
  [-72.00, 12.43],
  [-78.09, 11.85],
  [-69.54, -12.75],
  [-71.55, -16.96],
  [-72.05, -24.28],
];
// Vertical sector limits (feet)
const SECTOR_FLOOR_FT =  9500;   // FL95
const SECTOR_CEILING_FT = 66000; // FL660

// === Level picker (CFL/XFL) ===============================================
const FL_MAX_SELECT = Math.round(SECTOR_CEILING_FT/100);         // e.g. 660
const FL_OPTIONS = Array.from({length: Math.floor(FL_MAX_SELECT/10)+1}, (_,i)=> i*10);

function closeLevelPicker(){
  const inst = window._levelPicker;
  if (inst?.el && inst.el.parentNode) inst.el.parentNode.removeChild(inst.el);
  if (inst?.meta?.trackId){
    const t = tagMap.get(inst.meta.trackId);
    if (t) t.classList.remove('show-ops');
  }
  window._levelPicker = null;
}


function openLevelPicker(anchorEl, currentFL, onSelect){
  closeLevelPicker(); // single-instance

  const picker = document.createElement('div');
  picker.className = 'levelPicker';
  picker.id = 'levelPicker';

  const hdr = document.createElement('div');
  hdr.className = 'hdr';
  hdr.innerHTML = `<input id="lpInput" type="text" inputmode="numeric" placeholder="FL e.g. 220">`;
  picker.appendChild(hdr);
  const input = hdr.querySelector('#lpInput');
  if (Number.isFinite(currentFL)) input.value = String(currentFL);

  input.addEventListener('keydown', (ev)=>{
    if (ev.key === 'Enter'){
      const n = parseInt(String(input.value).toUpperCase().replace(/[^\d]/g,''), 10);
      if (Number.isFinite(n)){
        const fl = clamp(n, 0, FL_MAX_SELECT);
        onSelect(fl);
        closeLevelPicker();
      }
    } else if (ev.key === 'Escape'){
      closeLevelPicker();
    }
  });

  for (const fl of FL_OPTIONS){
    const it = document.createElement('div');
    it.className = 'item';
    it.dataset.fl = String(fl);
    it.textContent = 'FL' + String(fl).padStart(3,'0');
    if (fl === currentFL) it.setAttribute('aria-selected','true');
    it.addEventListener('click', (ev)=>{
      ev.stopPropagation(); ev.preventDefault();
      onSelect(fl);
      closeLevelPicker();
    });
    picker.appendChild(it);
  }

  const tip = document.createElement('div');
  tip.className = 'tip';
  tip.textContent = 'Type a level + Enter, or pick.';
  picker.appendChild(tip);

  // attach + remember anchor (track + field) so we can re-position later
  wrap.appendChild(picker);
  const tagEl = anchorEl.closest('.tag');
  const trackId = tagEl ? parseInt(tagEl.dataset.trackId, 10) : null;
  const field = anchorEl.getAttribute('data-act') || null;
  if (tagEl) tagEl.classList.add('show-ops');
  window._levelPicker = { el: picker, meta: { trackId, field } };

  // initial position
  repositionLevelPicker();

  // center current selection
  const cur = picker.querySelector(`.item[data-fl="${currentFL}"]`);
  if (cur) cur.scrollIntoView({block:'center'});

  // outside click / Esc closes
  const onDocDown = (ev)=>{ if (!picker.contains(ev.target)) closeLevelPicker(); };
  const onKey = (ev)=>{ if (ev.key === 'Escape') closeLevelPicker(); };
  document.addEventListener('pointerdown', onDocDown, {capture:true, once:true});
  document.addEventListener('keydown', onKey, {once:true});

  input.focus(); input.select();
}


function openWptPicker(anchorEl, ac){
  closeLevelPicker?.(); // single instance (reuse your level picker closer)

  const picker = document.createElement('div');
  picker.className = 'levelPicker';      // reuse same CSS
  picker.id = 'wptPicker';

  // Header with input filter
  const hdr = document.createElement('div');
  hdr.className = 'hdr';
  hdr.innerHTML = `<input id="wpInput" type="text" placeholder="Type to filter…">`;
  picker.appendChild(hdr);
  const input = hdr.querySelector('#wpInput');

  // List all remaining fixes in FPL
  const items = routeRemainingFixes(ac);
  if (!items.length){
    const empty = document.createElement('div');
    empty.className = 'item';
    empty.textContent = '— No remaining fixes —';
    empty.style.opacity = 0.6;
    picker.appendChild(empty);
  } else {
    for (const it of items){
      const row = document.createElement('div');
      row.className = 'item';
      row.dataset.id = String(it.id);
      row.textContent = it.name;
      row.addEventListener('click', (ev)=>{
        ev.stopPropagation(); ev.preventDefault();
        if (shortcutToFix(ac, it.id)){
          updateSelectedPanel(); drawAll();
        }
        closeLevelPicker?.();
      });
      picker.appendChild(row);
    }
  }

  // Tiny hint footer
  const tip = document.createElement('div');
  tip.className = 'tip';
  tip.textContent = 'Scroll or type to filter. Enter = first match.';
  picker.appendChild(tip);

  // Attach + remember where to stick it during relayouts
  wrap.appendChild(picker);
  const tagEl   = anchorEl.closest('.tag');
  const trackId = tagEl ? parseInt(tagEl.dataset.trackId, 10) : null;
  const field   = anchorEl.getAttribute('data-act') || 'wpt';
  if (tagEl) tagEl.classList.add('show-ops');
  window._levelPicker = { el: picker, meta: { trackId, field } };

  // Initial position + keep glued on refresh/drag/resize
  repositionLevelPicker?.();

  // Filter-as-you-type (only among items shown)
  function applyFilter(){
    const q = input.value.trim().toUpperCase();
    const all = picker.querySelectorAll('.item[data-id]');
    let firstVisible = null;
    all.forEach(row=>{
      const name = row.textContent.toUpperCase();
      const show = !q || name.includes(q);
      row.style.display = show ? '' : 'none';
      if (show && !firstVisible) firstVisible = row;
    });
    return firstVisible;
  }

  input.addEventListener('input', applyFilter);

  input.addEventListener('keydown', (ev)=>{
    if (ev.key === 'Enter'){
      const first = applyFilter();
      if (first){
        first.click(); // selects the first visible (still within FPL)
      }
    } else if (ev.key === 'Escape'){
      closeLevelPicker?.();
    }
  });

  // Close on outside click
  const onDocDown = (ev)=>{ if (!picker.contains(ev.target)) closeLevelPicker?.(); };
  const onKey = (ev)=>{ if (ev.key === 'Escape') closeLevelPicker?.(); };
  document.addEventListener('pointerdown', onDocDown, {capture:true, once:true});
  document.addEventListener('keydown', onKey, {once:true});

  input.focus(); input.select();
}

function openHeadingPicker(anchorEl, ac){
  closeLevelPicker?.();

  const picker = document.createElement('div');
  picker.className = 'levelPicker';
  picker.id = 'hdgPicker';

  const hdr = document.createElement('div');
  hdr.className = 'hdr';
  hdr.innerHTML = `<input id="hdgInput" type="text" inputmode="numeric" placeholder="HDG (1–360)">`;
  picker.appendChild(hdr);
  const input = hdr.querySelector('#hdgInput');
  input.value = String(Math.round(mod360(ac.tgtHdg)) || 360).padStart(3,'0');

  const cur = Math.round(mod360(ac.tgtHdg));

  function addRow(hShown){
    // We store 0 for 360 internally.
    const hApply = (hShown === 360 ? 0 : hShown);
    const row = document.createElement('div');
    row.className = 'item';
    row.textContent = 'HDG ' + String(hShown).padStart(3,'0');
    if ((cur === 0 && hShown === 360) || cur === hShown) {
      row.setAttribute('aria-selected','true');
    }
    row.addEventListener('click', (ev)=>{
      ev.stopPropagation(); ev.preventDefault();
      ac.setHeading(hApply);
      state.selectedId = ac.id;
      updateSelectedPanel(); drawAll();
      closeLevelPicker?.();
    });
    picker.appendChild(row);
  }

  // 005…355, 360 (→ 0)
  for (let h=5; h<=355; h+=5) addRow(h);
  addRow(360);

  const tip = document.createElement('div');
  tip.className = 'tip';
  tip.textContent = 'Type a heading and press Enter. 360 = 000.';
  picker.appendChild(tip);

  wrap.appendChild(picker);
  const tagEl   = anchorEl.closest('.tag');
  const trackId = tagEl ? parseInt(tagEl.dataset.trackId,10) : null;
  if (tagEl) tagEl.classList.add('show-ops');
  window._levelPicker = { el: picker, meta: { trackId, field: 'hdg' } };
  repositionLevelPicker?.();

  input.addEventListener('keydown', (ev)=>{
    if (ev.key === 'Enter'){
      let n = parseInt(String(input.value).replace(/[^\d]/g,''),10);
      if (Number.isFinite(n)){
        n = mod360(n);
        ac.setHeading(n===0?0:n);
        state.selectedId = ac.id;
        updateSelectedPanel(); drawAll();
        closeLevelPicker?.();
      }
    } else if (ev.key === 'Escape'){
      closeLevelPicker?.();
    }
  });

  const onDocDown = (ev)=>{ if (!picker.contains(ev.target)) closeLevelPicker?.(); };
  const onKey     = (ev)=>{ if (ev.key==='Escape') closeLevelPicker?.(); };
  document.addEventListener('pointerdown', onDocDown, {capture:true, once:true});
  document.addEventListener('keydown', onKey, {once:true});

  input.focus(); input.select();
}
function openIASPicker(anchorEl, ac){
  closeLevelPicker?.(); // single instance

  const picker = document.createElement('div');
  picker.className = 'levelPicker';
  picker.id = 'iasPicker';

  // Header with type-to-set
  const hdr = document.createElement('div');
  hdr.className = 'hdr';
  hdr.innerHTML = `<input id="iasInput" type="text" inputmode="numeric" placeholder="IAS kt (e.g. 250)">`;
  picker.appendChild(hdr);
  const input = hdr.querySelector('#iasInput');

  // Current / suggested
  const curIAS = Math.round(ac.tgtSpeedMode==='KT' ? ac.tgtIAS_kt : ac.ias_kt);
  input.value = String(curIAS);

  // Quick helper
  const applyIAS = (ias) => {
    let v = Math.max(60, Math.min(ias|0, 460));
    if (env.restrict250 && ac.alt_ft <= 10000) v = Math.min(v, 250); // 250kt rule
    ac.setSpeedKt(v);
    state.selectedId = ac.id;
    updateSelectedPanel(); drawAll();
    closeLevelPicker?.();
  };

  // Row helper
  function addRow(content, onPick, selected=false, muted=false){
    const row = document.createElement('div');
    row.className = 'item';
    if (selected) row.setAttribute('aria-selected','true');
    if (muted) row.style.opacity = .6;
    row.textContent = content;
    row.addEventListener('click', (ev)=>{
      ev.stopPropagation(); ev.preventDefault();
      onPick();
    });
    picker.appendChild(row);
  }

  // Top row: Managed (auto) — shows current target at this instant
  const managedNow = Math.round(managedSpeedTargetKt(ac));
  addRow(
    `Managed (auto) — now ≈ ${managedNow} kt`,
    ()=>{
      ac.managedSpd = true;                 // hand control back to schedule
      ac.tgtSpeedMode = "KT";               // stays IAS-driven
      state.selectedId = ac.id;
      updateSelectedPanel(); drawAll();
      closeLevelPicker?.();
    },
    ac.managedSpd === true
  );

  // Divider-ish hint
  const tip0 = document.createElement('div');
  tip0.className = 'tip';
  tip0.textContent = 'Fixed IAS (manual):';
  picker.appendChild(tip0);

  // Quick picks 200..320
const quick = Array.from({length: 13}, (_,i)=>200+i*10);
for (const v of quick){
  const tas  = iasToTas(v, ac.alt_ft) | 0;
  const mach = (tas / isaSpeedOfSoundKts(ac.alt_ft)).toFixed(2);
  addRow(`${v} kt  (≈TAS ${tas}, M${mach})`, ()=>applyIAS(v),
         (!ac.managedSpd && ac.tgtSpeedMode==='KT' && Math.abs(curIAS - v) < 3));
}


  // Footer hint
  const tip = document.createElement('div');
  tip.className = 'tip';
  tip.textContent = 'Type any IAS between 200-320kt and press Enter';
  picker.appendChild(tip);

  // Attach & remember anchor
  wrap.appendChild(picker);
  const tagEl   = anchorEl.closest('.tag');
  const trackId = tagEl ? parseInt(tagEl.dataset.trackId,10) : null;
  if (tagEl) tagEl.classList.add('show-ops');
  window._levelPicker = { el: picker, meta: { trackId, field: 'spd' } };
  repositionLevelPicker?.();

  // Enter to set
  input.addEventListener('keydown', (ev)=>{
    if (ev.key === 'Enter'){
      const n = parseInt(String(input.value).replace(/[^\d]/g,''),10);
      if (Number.isFinite(n)) applyIAS(n);
    } else if (ev.key === 'Escape'){
      closeLevelPicker?.();
    }
  });

  // Close on outside/Esc
  const onDocDown = (ev)=>{ if (!picker.contains(ev.target)) closeLevelPicker?.(); };
  const onKey     = (ev)=>{ if (ev.key==='Escape') closeLevelPicker?.(); };
  document.addEventListener('pointerdown', onDocDown, {capture:true, once:true});
  document.addEventListener('keydown', onKey, {once:true});

  input.focus(); input.select();
}


function openMachPicker(anchorEl, ac){
  closeLevelPicker?.();

  const picker = document.createElement('div');
  picker.className = 'levelPicker';
  picker.id = 'machPicker';

  const hdr = document.createElement('div');
  hdr.className = 'hdr';
  hdr.innerHTML = `<input id="machInput" type="text" inputmode="decimal" placeholder="Mach (e.g. 0.78)">`;
  picker.appendChild(hdr);
  const input = hdr.querySelector('#machInput');
  const curM  = (ac.tgtSpeedMode==='MACH' && ac.tgtMach) ? ac.tgtMach : ac.mach;
  input.value = curM.toFixed(2);

  function addRow(m){
    const row = document.createElement('div');
    row.className = 'item';
    row.textContent = 'M ' + m.toFixed(2);
    if (Math.abs(curM - m) < 0.005) row.setAttribute('aria-selected','true');
    row.addEventListener('click', (ev)=>{
      ev.stopPropagation(); ev.preventDefault();
      ac.setMach(m);
      state.selectedId = ac.id;
      updateSelectedPanel(); drawAll();
      closeLevelPicker?.();
    });
    picker.appendChild(row);
  }

  // Practical cruise range
  for (let m=0.60; m<=0.90+1e-9; m+=0.01) addRow(Number(m.toFixed(2)));

  const tip = document.createElement('div');
  tip.className = 'tip';
  tip.textContent = 'Type any Mach 0.30–0.99 and press Enter.';
  picker.appendChild(tip);

  wrap.appendChild(picker);
  const tagEl   = anchorEl.closest('.tag');
  const trackId = tagEl ? parseInt(tagEl.dataset.trackId,10) : null;
  if (tagEl) tagEl.classList.add('show-ops');
  window._levelPicker = { el: picker, meta: { trackId, field: 'mach' } };
  repositionLevelPicker?.();

  input.addEventListener('keydown', (ev)=>{
    if (ev.key === 'Enter'){
      let m = parseFloat(String(input.value).replace(/[^0-9.]/g,''));
      if (Number.isFinite(m)){
        m = clamp(m, 0.30, 0.99);
        ac.setMach(m);
        state.selectedId = ac.id;
        updateSelectedPanel(); drawAll();
        closeLevelPicker?.();
      }
    } else if (ev.key === 'Escape'){
      closeLevelPicker?.();
    }
  });

  const onDocDown = (ev)=>{ if (!picker.contains(ev.target)) closeLevelPicker?.(); };
  const onKey     = (ev)=>{ if (ev.key==='Escape') closeLevelPicker?.(); };
  document.addEventListener('pointerdown', onDocDown, {capture:true, once:true});
  document.addEventListener('keydown', onKey, {once:true});

  input.focus(); input.select();
}

function openVsPicker(anchorEl, ac){
  closeLevelPicker?.();

  const picker = document.createElement('div');
  picker.className = 'levelPicker';
  picker.id = 'vsPicker';

  const hdr = document.createElement('div');
  hdr.className = 'hdr';
  hdr.innerHTML = `<input id="vsInput" type="text" inputmode="numeric" placeholder="VS ×100 (e.g. +18)">`;
  picker.appendChild(hdr);
  const input = hdr.querySelector('#vsInput');
  const curH  = Math.round(ac.vs_fpm/100);
  input.value = (curH>=0?'+':'') + String(curH);

  function addRow(h){
    const row = document.createElement('div');
    row.className = 'item';
    const fpm = h*100;
    const sign = h>0?'+':(h<0?'-':'');
    row.textContent = `VS ${sign}${Math.abs(h)}  (${fpm} fpm)`;
    if (h === curH) row.setAttribute('aria-selected','true');
    row.addEventListener('click', (ev)=>{
      ev.stopPropagation(); ev.preventDefault();
      // change VS but keep current target altitude
      ac.setAltitude(ac.tgtAlt, fpm);
      state.selectedId = ac.id;
      updateSelectedPanel(); drawAll();
      closeLevelPicker?.();
    });
    picker.appendChild(row);
  }

  // −50…+50 in steps of 5 (±500 fpm), include 0
  for (let h=-50; h<=50; h+=5) addRow(h);

  const tip = document.createElement('div');
  tip.className = 'tip';
  tip.textContent = 'Type ±hundreds (e.g. -20, +25) then Enter.';
  picker.appendChild(tip);

  wrap.appendChild(picker);
  const tagEl   = anchorEl.closest('.tag');
  const trackId = tagEl ? parseInt(tagEl.dataset.trackId,10) : null;
  if (tagEl) tagEl.classList.add('show-ops');
  window._levelPicker = { el: picker, meta: { trackId, field: 'vs' } };
  repositionLevelPicker?.();

  input.addEventListener('keydown', (ev)=>{
    if (ev.key === 'Enter'){
      const raw = String(input.value).trim().replace(/[^\d+\-]/g,'');
      const h = parseInt(raw, 10);
      if (Number.isFinite(h)){
        const hh = clamp(h, -99, 99); // safety clamp, UI shows ±50
        ac.setAltitude(ac.tgtAlt, hh*100);
        state.selectedId = ac.id;
        updateSelectedPanel(); drawAll();
        closeLevelPicker?.();
      }
    } else if (ev.key === 'Escape'){
      closeLevelPicker?.();
    }
  });

  const onDocDown = (ev)=>{ if (!picker.contains(ev.target)) closeLevelPicker?.(); };
  const onKey     = (ev)=>{ if (ev.key==='Escape') closeLevelPicker?.(); };
  document.addEventListener('pointerdown', onDocDown, {capture:true, once:true});
  document.addEventListener('keydown', onKey, {once:true});

  input.focus(); input.select();
}


function repositionLevelPicker(){
  const lp = window._levelPicker?.el;
  const meta = window._levelPicker?.meta;
  if (!lp || !meta) return;

  // find the current anchor span inside the *current* tag node
  const tag = tagMap.get(meta.trackId);
  if (!tag) return; // a/c despawned? leave picker where it is
  const anchor = tag.querySelector(`[data-act="${meta.field}"]`);
  if (!anchor) return;

  const wrapRect = wrap.getBoundingClientRect();
  const r = anchor.getBoundingClientRect();
  lp.style.left = (r.left - wrapRect.left) + 'px';
  lp.style.top  = (r.bottom - wrapRect.top + 6) + 'px';
}

// Return [{id, name}] for the remaining FPL fixes from current routeIdx onward
function routeRemainingFixes(ac){
  const from = Math.max(0, ac.routeIdx|0);
  const ids = Array.isArray(ac.route) ? ac.route.slice(from) : [];
  const out = [];
  for (const id of ids){
    const w = env.getWaypoint(id);
    if (w) out.push({ id: w.id, name: w.name });
  }
  return out;
}

// Move lateral nav to a later fix *within the same FPL* (no DIRECT).
// This trims the "past legs" logically by advancing routeIdx, so the green
// preview starts at the chosen fix right away.
function shortcutToFix(ac, fixId){
  const idx = Array.isArray(ac.route) ? ac.route.indexOf(fixId) : -1;
  if (idx < 0) return false;         // not in FPL → reject

  ac.navMode = 'ROUTE';
  ac.directWptId = null;
  ac.routeIdx = idx;

  // reset pass-trend helpers so range-to-target logic is fresh
  ac.prevDistToTarget = null;
  ac.lastNavTargetId  = null;

  // (optional) snap the target heading immediately
  const w = env.getWaypoint(fixId);
  if (w){
    const hdgTo = mod360(Math.atan2(w.x_nm - ac.x_nm, -(w.y_nm - ac.y_nm)) * 180/Math.PI);
    ac.tgtHdg = hdgTo;
  }
  return true;
}



// ===== TMAs (floor/ceiling in feet) =========================================
const TMAS = [
  {
    name: "Poznań APP", floor_ft: 0, ceiling_ft: 20500,
    poly: [
      [-32.34, -31.56],[-49.29, -65.61],[-47.06, -102.56],[-31.38, -108.57],
      [24.33, -107.69],[42.62, -93.80],[42.49, -53.46],[30.17, -38.41],
    ]
  },
  {
    name: "Warszawa APP", floor_ft: 0, ceiling_ft: 24500,
    poly: [
      [115.89, -26.84],[115.92, -34.74],[119.33, -41.78],[113.32, -59.86],
      [103.68, -88.66],[108.50, -96.27],[155.49, -99.36],[168.79, -69.13],
      [167.66, -25.54],[149.27, -9.81],
    ]
  },
  {
    name: "Kraków APP", floor_ft: 0, ceiling_ft: 28500,
    poly: [
      [46.19, 64.61],[46.69, 43.88],[51.93, 35.29],[70.63, 13.07],[75.01, 9.84],
      [116.49, 4.90],[125.30, 29.75],[137.27, 34.59],[147.46, 69.46],[121.05, 76.85],
      [62.38, 75.10],[52.95, 70.42],[50.70, 66.89],
    ]
  },
  {
    name: "Wrocław TWR", floor_ft: 0, ceiling_ft: 13500,
    poly: [
      [-22.45,  8.11],[-23.67,  -7.69],[ 0.79, -24.54],[19.11, -22.08],
      [ 26.42, -12.61],[30.71,  11.81],[23.51,  13.90],[-0.62, 17.63],
    ]
  },
  {
    name: "Łódź TWR", floor_ft: 0, ceiling_ft: 11500,
    poly: [
      [115.75, -26.84],[112.23, -27.70],[101.67, -34.37],[ 91.22, -31.16],
      [ 76.15, -36.99],[ 74.61, -42.07],[ 74.91, -47.43],[ 99.62, -54.82],
      [105.13, -56.50],[107.11, -56.92],[113.04, -59.86],[119.47, -41.64],
      [115.92, -34.60],
    ]
  },
];


// point-in-polygon (ray casting)
function pointInPoly(x, y, poly){
  let inside = false;
  for (let i=0, j=poly.length-1; i<poly.length; j=i++){
    const [xi, yi] = poly[i], [xj, yj] = poly[j];
    const intersect = ((yi>y)!=(yj>y)) && (x < (xj-xi)*(y-yi)/(yj-yi) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}

// per-TMA label nudges (in **pixels**; negative x = left, negative y = up)
const LABEL_OFFSETS_PX = {
  'Wrocław TWR': [-28, -32],
  'Wroclaw TWR': [-18, -32], // in case your name has no diacritics
  'Łódź TWR': [-1, -12],
  'Lodz TWR': [-1, -12],
  'Poznań APP': [50, 95],
  'Warszawa APP': [17, 32],
  'Kraków APP': [37, -75],
};


function drawTMAs(){
  // tweak these 3 if you want slightly brighter/thicker/different dash later
  const TMA_LINE_WIDTH = 1;                         // hairline
  const TMA_STROKE     = 'rgba(143,211,255,0.36)';  // faint cyan
  const TMA_DASH       = [7,7];                     // uniform for all

  ctx.save();
  ctx.lineWidth = TMA_LINE_WIDTH;
  ctx.strokeStyle = TMA_STROKE;
  ctx.setLineDash(TMA_DASH);
  ctx.lineJoin = 'round';
  ctx.lineCap  = 'round';

  for (const t of TMAS){
    // path
    ctx.beginPath();
    for (let i=0;i<t.poly.length;i++){
      const [xn,yn] = t.poly[i];
      const x = cx + nmToPx(xn), y = cy + nmToPx(yn);
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.closePath();
    ctx.stroke();            // <-- outline only (no fill)

    // name-only label (no levels)
const ctr  = t.poly.reduce((s,p)=>({x:s.x+p[0], y:s.y+p[1]}), {x:0,y:0});
const xLab = cx + nmToPx(ctr.x / t.poly.length);
const yLab = cy + nmToPx(ctr.y / t.poly.length);

// apply optional per-TMA nudge
const [dx, dy] = LABEL_OFFSETS_PX[t.name] || [0,0];
const lx = xLab + dx, ly = yLab + dy;

const text = t.name;

ctx.font = "11px ui-monospace";
ctx.textAlign = "center";
ctx.textBaseline = "middle";

// halo
ctx.lineWidth = 3;
ctx.setLineDash([]);
ctx.strokeStyle = "rgba(6,7,7,0.85)";
ctx.strokeText(text, lx, ly);

// fill
ctx.fillStyle = "#8fd3ff";
ctx.fillText(text, lx, ly);

// restore dash etc.
ctx.setLineDash(TMA_DASH);
ctx.lineWidth = TMA_LINE_WIDTH;
ctx.strokeStyle = TMA_STROKE;

  }
  ctx.setLineDash([]);
  ctx.restore();
}



// bounding box (for legacy rect-based spawn math)
const SECTOR_BBOX = (() => {
  const xs = SECTOR_POLY.map(p=>p[0]), ys = SECTOR_POLY.map(p=>p[1]);
  const minX = Math.min(...xs), maxX = Math.max(...xs);
  const minY = Math.min(...ys), maxY = Math.max(...ys);
  return {minX,maxX,minY,maxY, width:maxX-minX, height:maxY-minY};
})();


  const env = {
  restrict250:false, autoHandoff:true,
  // keep rectW/H for legacy UI/spawn but derive from polygon bbox
  rectW: SECTOR_BBOX.width,
  rectH: SECTOR_BBOX.height,
  getWaypoint: id => getWPById(id),
  // 3D sector check: inside polygon AND within FL95–FL660 when alt is provided.
  // If alt_ft is omitted, this behaves like a 2D polygon check (for waypoint seeding, etc).
  inRect: (x_nm, y_nm, alt_ft = null) => {
    if (!pointInPoly(x_nm, y_nm, SECTOR_POLY)) return false;
    if (alt_ft == null) return true; // 2D callers
    return alt_ft >= SECTOR_FLOOR_FT && alt_ft <= SECTOR_CEILING_FT;
  },
};



  const state = {
    ac:[], selectedId:null, paused:false,
    simSpeed:1,
    filterMin:0, filterMax:60000,
    pred1:true, pred3:true, pred5:true, predFor:"all",
    lookaheadMin:2,
    conflictsNow:[], conflictsPred:[],
    conflictsPredDetail:[],  // ← geometry for continuous amber band
    addingWpt:false,
    refreshSec:3,
    measure:null,        // active ruler being drawn {fromX_nm,fromY_nm,toX_nm,toY_nm}
    measures:[],          // committed rulers
    editing:null,          // {id, field} e.g. {id: 3, field:'hdg'|'spd'|'mach'|'vs'|'cfl'}
    routePreviewId : null,    // ⇐ NEW – id of a/c to highlight
    

  };
  function getSelected(){ return state.ac.find(a=>a.id===state.selectedId)||null; }
  // --- Sim clock (seconds) ---
let simNowSec = 0;


  // Waypoints
  let wptNext=1; const wpts=[];
  // ---- Random waypoint naming + min-spacing placement ----
const WPT_MIN_SPACING_NM = 15;     // tweak to taste
const WPT_TRIES_PER_POINT = 350;  // how hard we try per waypoint

function randWptName(){
  const vowels = "AEIOU";
  const cons   = "BCDFGHJKLMNPQRSTVWXYZ";
  // Make it feel "airway-ish": CVCVC or CVCCV with a dash of weirdness
  const pat = Math.random() < 0.5 ? "CVCVC" : "CVCCV";
  const pick = (s)=> s[Math.floor(Math.random()*s.length)];
  let out = "";
  for (const c of pat){
    out += (c==="C") ? pick(cons) : pick(vowels);
  }
  // ~15% chance to flip one letter to make it quirky
  if (Math.random() < 0.15){
    const i = Math.floor(Math.random()*out.length);
    const pool = Math.random()<0.5?vowels:cons;
    out = out.slice(0,i) + pick(pool) + out.slice(i+1);
  }
  return out;
}

function addWaypointNamedAt(name, x_nm, y_nm){
  const id = wptNext++;
  const w = { id, name, x_nm, y_nm };
  wpts.push(w);
  return w;
}

/** Place N random waypoints inside the current rectangular sector
 *  with at least WPT_MIN_SPACING_NM separation.
 */
function seedRandomWaypoints(count){
  const halfW = env.rectW/2, halfH = env.rectH/2;
  for (let k=0; k<count; k++){
    let placed = false;
    let tries = 0;
    let spacing = WPT_MIN_SPACING_NM;

    while(!placed && tries < WPT_TRIES_PER_POINT){
      tries++;
      const x = (Math.random()*2 - 1) * (halfW * 0.95);
      const y = (Math.random()*2 - 1) * (halfH * 0.95);

      // inside rect (belt-and-suspenders)
      if (!env.inRect(x,y)) continue;

      // distance check vs all existing waypoints
      let ok = true;
      for (const w of wpts){
        const d = Math.hypot(x - w.x_nm, y - w.y_nm);
        if (d < spacing){ ok = false; break; }
      }
      if (!ok) {
        // After many misses, ease spacing a bit so we don’t stall
        if (tries % 50 === 0) spacing *= 0.9;
        continue;
      }

      addWaypointNamedAt(randWptName(), x, y);
      placed = true;
    }
  }
  renderWptList();
  drawAll();
}

  function addWaypointAt(x_nm,y_nm){ const id=wptNext++; const w={id,name:"WPT"+id,x_nm,y_nm}; wpts.push(w); renderWptList(); drawAll(); }
  function clearWaypoints(){ wpts.length=0; renderWptList(); drawAll(); }
  function renderWptList(){
    const box=document.getElementById('wptList');
    if(wpts.length===0){ box.innerHTML='<div class="small">No waypoints.</div>'; return; }
    box.innerHTML=wpts.map(w=>`
      <div style="display:flex;align-items:center;gap:8px;margin:4px 0;">
        <span class="pill">${w.name}</span>
        <button data-w="${w.id}" class="btnDirect small">Direct-to</button>
      </div>`).join("");
    for(const btn of box.querySelectorAll('.btnDirect')){
      btn.addEventListener('click', e=>{
        const id=parseInt(e.target.getAttribute('data-w'),10);
        const sel=getSelected(); if(!sel){ alert("Select a track first."); return; }
        sel.directTo(id); updateSelectedPanel(); drawAll();
      });
    }
  }
  function fmtFL(flFt){ return 'FL' + String(Math.round(flFt/100)).padStart(3,'0'); }
function fmtTas(kt){ return (kt|0) + " kt"; }

function ensureSfpWin(){
  let el = document.querySelector('.sfpWin');
  if(el) return el;

  el = document.createElement('div');
  el.className = 'sfpWin';
  el.innerHTML = `
    <div class="hdr">
      <div class="title">Short Flight Plan</div>
      <div><button class="btnSfpClose">Close</button></div>
    </div>
    <div class="body"></div>
  `;
  document.getElementById('radarWrap').appendChild(el);
  const closeBtn = el.querySelector('.btnSfpClose');
closeBtn.addEventListener('pointerdown', e=>{ e.stopPropagation(); });
closeBtn.addEventListener('click', closeSFP);


  // Dragging by header — LEFT BUTTON ONLY; capture on the SAME node we listen on
  const hdr = el.querySelector('.hdr');
  let dragging=false, sx=0, sy=0, startLeft=0, startTop=0;

  function endDrag(ev){
    if(!dragging) return;
    dragging=false;
    el.classList.remove('is-dragging');
    try{ hdr.releasePointerCapture(ev.pointerId);}catch{}
  }

  hdr.addEventListener('pointerdown', ev=>{
    if (ev.button !== 0) return;                 // left button only
    if (ev.target.closest('button')) return;
    dragging = true;
    hdr.setPointerCapture(ev.pointerId);         // <-- capture on hdr (not el)
    const r  = el.getBoundingClientRect();
    const wr = document.getElementById('radarWrap').getBoundingClientRect();
    startLeft = r.left - wr.left;
    startTop  = r.top  - wr.top;
    sx = ev.clientX; sy = ev.clientY;
    el.classList.add('is-dragging');
    ev.preventDefault();
    ev.stopPropagation();
  });

  hdr.addEventListener('pointermove', ev=>{
    if(!dragging) return;
    // If LMB is no longer down (missed pointerup), drop the drag.
    if ((ev.buttons & 1) === 0) { endDrag(ev); return; }
    const dx = ev.clientX - sx, dy = ev.clientY - sy;
    el.style.left = (startLeft + dx) + 'px';
    el.style.top  = (startTop  + dy) + 'px';
    el.style.right = 'auto';
  });

  hdr.addEventListener('pointerup', endDrag);
  hdr.addEventListener('pointercancel', endDrag);
  hdr.addEventListener('lostpointercapture', ()=>{ dragging=false; el.classList.remove('is-dragging'); });

  return el;
}




function renderSFP(ac){
  const el = ensureSfpWin();
  const body = el.querySelector('.body');
  if(!ac || !ac.fp){
    body.innerHTML = `<div class="small" style="color:#9fb3c1">No SFP for this aircraft.</div>`;
    return;
  }
  const fp = ac.fp;
  const routeNames = (ac.route||[]).map(id => (env.getWaypoint(id)?.name || String(id)));
  body.innerHTML = `
    <table>
      <tr><td class="key">Callsign</td><td>${ac.cs}</td></tr>
      <tr><td class="key">Type</td><td>${fp.type || ac.type || '—'}</td></tr>
      <tr><td class="key">From</td><td>${fp.dep || '—'}</td></tr>
      <tr><td class="key">To</td><td>${fp.dest || '—'}</td></tr>
      <tr><td class="key">Cruise</td><td>${fmtFL(fp.cruiseFL*100)}</td></tr>
      <tr><td class="key">TAS</td><td>${fmtTas(fp.tasKt||ac.spd_kt)}</td></tr>
    </table>
    <div class="route"><span style="color:#9fb3c1">Route:</span> ${
      routeNames.length ? routeNames.join(' → ') : '—'
    }</div>
  `;
  // keep it on-screen if window is small
  const r = el.getBoundingClientRect(), wrapR = document.getElementById('radarWrap').getBoundingClientRect();
  if(r.right > wrapR.right) el.style.right = '12px';
  if(r.top < wrapR.top) el.style.top = '64px';
}

function openSFP(ac){ renderSFP(ac); }
function closeSFP(){
  const el = document.querySelector('.sfpWin');
  if(el) el.remove();
}

  
  // ===== Random waypoints inside sector + faint airways =====
let airways = []; // pairs of waypoint ids to draw lines between

const FUN_FIXES = [
  "YEETR","BORKD","LOLNO","NOMMY","PIZZA","SAUCE","ZAPPY","FIZZY","BANJO","NINJA",
  "TANGO","NACHO","BAGEL","WAFFL","DONUT","BINGO","CHILL","HAPPY","GRUMP","ZORRO",
  "BEEFY","NOODS","SPICY","MUNCH","CRONK","GOOFY","SNEKD","WHAAA","YUMMY","BUBBL"
];
const VOWELS = ["A","E","I","O","U","Y"];
const CONS   = ["B","C","D","F","G","H","J","K","L","M","N","P","Q","R","S","T","V","W","X","Z"];
const usedFixNames = new Set();

function genFunnyFixName(){
  // prefer from list without reusing
  const candidates = FUN_FIXES.filter(n => !usedFixNames.has(n));
  if (candidates.length){
    const n = candidates[Math.floor(Math.random()*candidates.length)];
    usedFixNames.add(n);
    return n;
  }
  // fallback: make something pronounceable(ish) CCVCV
  const pick = arr => arr[Math.floor(Math.random()*arr.length)];
  const name = (pick(CONS)+pick(CONS)+pick(VOWELS)+pick(CONS)+pick(VOWELS)).toUpperCase();
  usedFixNames.add(name);
  return name;
}

// Seed N random waypoints inside current rectangular sector
function seedWaypointsInside(count=16, minSepNm=5){
  const halfW = env.rectW/2, halfH = env.rectH/2;
  const margin = 4; // keep a little away from the edge

  function tooClose(x_nm,y_nm){
    return wpts.some(w => Math.hypot(w.x_nm - x_nm, w.y_nm - y_nm) < minSepNm);
  }

  for(let i=0;i<count;i++){
    let tries=0, x=0, y=0;
    do{
      x = (Math.random()*2-1) * (halfW - margin);
      y = (Math.random()*2-1) * (halfH - margin);
      tries++;
    } while(tries<40 && tooClose(x,y));

    const id = wptNext++;
    const w = { id, name: genFunnyFixName(), x_nm:x, y_nm:y };
    wpts.push(w);
  }
  renderWptList();
}

// Build “airways” by connecting each waypoint to its k nearest neighbors
function buildAirways(k=2){
  const pts = [...WP_ALL, ...wpts];
  const uniq = new Set(); // "min-max" id keys
  for(const a of pts){
    const dists = [];
    for(const b of pts){
      if (a.id===b.id) continue;
      dists.push([b.id, Math.hypot(a.x_nm-b.x_nm, a.y_nm-b.y_nm)]);
    }
    dists.sort((p,q)=>p[1]-q[1]);
    for(let i=0;i<Math.min(k,dists.length);i++){
      const bId = dists[i][0];
      const key = a.id < bId ? `${a.id}-${bId}` : `${bId}-${a.id}`;
      uniq.add(key);
    }
  }
  airways = Array.from(uniq).map(s => s.split('-').map(n=>parseInt(n,10)));
}


  
  // ==== REPLACED: static waypoints (only new list; no CTR) ====
const WP = {};
Object.assign(WP, {
  NAROX: { id:3000, name:"NAROX", x_nm:-71.06, y_nm:-8.69 },
  LASIS: { id:3001, name:"LASIS", x_nm:-71.80, y_nm:-20.75 },
  DIMEX: { id:3002, name:"DIMEX", x_nm:-27.71, y_nm:-32.13 },
  XIDNA: { id:3003, name:"XIDNA", x_nm:5.23, y_nm:-36.00 },
  BESTO: { id:3004, name:"BESTO", x_nm:20.00, y_nm:-37.67 },
  BADNO: { id:3005, name:"BADNO", x_nm:30.17, y_nm:-38.83 },
  BADUP: { id:3006, name:"BADUP", x_nm:21.21, y_nm:-57.30 },
  DIPKI: { id:3007, name:"DIPKI", x_nm:22.48, y_nm:-65.83 },
  TENVO: { id:3008, name:"TENVO", x_nm:34.27, y_nm:-67.52 },
  MASIV: { id:3009, name:"MASIV", x_nm:37.17, y_nm:-54.50 },
  INDIG: { id:3010, name:"INDIG", x_nm:42.58, y_nm:-53.51 },
  OBOKU: { id:3011, name:"OBOKU", x_nm:42.68, y_nm:-68.68 },
  MOLIL: { id:3012, name:"MOLIL", x_nm:42.94, y_nm:-89.00 },
  ERPAB: { id:3013, name:"ERPAB", x_nm:54.47, y_nm:-91.77 },
  PENEX: { id:3014, name:"PENEX", x_nm:89.66, y_nm:-87.50 },
  VAVEK: { id:3015, name:"VAVEK", x_nm:86.86, y_nm:-95.37 },
  BIMPA: { id:3016, name:"BIMPA", x_nm:107.88, y_nm:-76.82 },
  GODIL: { id:3017, name:"GODIL", x_nm:124.42, y_nm:-79.70 },
  WAR: { id:3018, name:"WAR", x_nm:139.80, y_nm:-70.26 },
  LOLSI: { id:3019, name:"LOLSI", x_nm:111.60, y_nm:-65.56 },
  SOXER: { id:3020, name:"SOXER", x_nm:114.26, y_nm:-56.74 },
  AGAVA: { id:3021, name:"AGAVA", x_nm:115.99, y_nm:-29.23 },
  NUBLI: { id:3022, name:"NUBLI", x_nm:112.66, y_nm:-17.47 },
  MAKOV: { id:3023, name:"MAKOV", x_nm:84.27, y_nm:-2.74 },
  BAREX: { id:3024, name:"BAREX", x_nm:70.62, y_nm:13.43 },
  SUDOL: { id:3025, name:"SUDOL", x_nm:58.08, y_nm:27.58 },
  MAPIK: { id:3026, name:"MAPIK", x_nm:51.80, y_nm:35.26 },
  NUMBA: { id:3027, name:"NUMBA", x_nm:46.46, y_nm:44.30 },
  REGLI: { id:3028, name:"REGLI", x_nm:42.27, y_nm:65.95 },
  AMTEK: { id:3029, name:"AMTEK", x_nm:40.50, y_nm:66.89 },
  DESEN: { id:3030, name:"DESEN", x_nm:23.40, y_nm:50.66 },
  LAGAR: { id:3031, name:"LAGAR", x_nm:-58.07, y_nm:16.71 },
  TOMTI: { id:3032, name:"TOMTI", x_nm:-60.59, y_nm:6.95 },
  RASAN: { id:3033, name:"RASAN", x_nm:-68.56, y_nm:4.32 },
  OKX: { id:3034, name:"OKX", x_nm:-70.49, y_nm:9.46 },
  GOLOP: { id:3035, name:"GOLOP", x_nm:-92.69, y_nm:28.96 },
  PR532: { id:3036, name:"PR532", x_nm:-88.89, y_nm:50.12 },
  LKPR: { id:3037, name:"LKPR", x_nm:-102.88, y_nm:56.94 },
  EPWR: { id:3038, name:"EPWR", x_nm:-0.13, y_nm:-0.14 },
  WR603: { id:3039, name:"WR603", x_nm:15.13, y_nm:7.00 },
  LATAG: { id:3040, name:"LATAG", x_nm:-41.62, y_nm:-38.18 },
  AKAPI: { id:3041, name:"AKAPI", x_nm:-14.60, y_nm:-49.39 },
  CZE: { id:3042, name:"CZE", x_nm:-4.77, y_nm:-62.06 },
  OBOLA: { id:3043, name:"OBOLA", x_nm:-23.84, y_nm:-66.51 },
  KELOD: { id:3044, name:"KELOD", x_nm:-35.61, y_nm:-69.02 },
  BAREP: { id:3045, name:"BAREP", x_nm:-47.65, y_nm:-71.54 },
  JED: { id:3046, name:"JED", x_nm:128.24, y_nm:26.78 },
  EPPO: { id:3047, name:"EPPO", x_nm:-1.14, y_nm:-79.24 },
  KORUP: { id:3048, name:"KORUP", x_nm:-80.00, y_nm:-31.23 },
  GOVEN: { id:3049, name:"GOVEN", x_nm:-78.06, y_nm:-59.53 },
  SUI: { id:3050, name:"SUI", x_nm:-83.63, y_nm:-79.47 },
  PEVUM: { id:3051, name:"PEVUM", x_nm:67.08, y_nm:-71.92 },
  AMUTO: { id:3052, name:"AMUTO", x_nm:77.52, y_nm:-73.48 },
  DOSIX: { id:3053, name:"DOSIX", x_nm:87.68, y_nm:-74.78 },
  LDZ: { id:3054, name:"LDZ", x_nm:104.01, y_nm:-42.17 },
  ABAKU: { id:3055, name:"ABAKU", x_nm:82.42, y_nm:-34.17 },
  BAXIS: { id:3056, name:"BAXIS", x_nm:74.89, y_nm:-41.94 },
  UTOLU: { id:3057, name:"UTOLU", x_nm:74.78, y_nm:-47.22 },
  OKENO: { id:3058, name:"OKENO", x_nm:64.51, y_nm:-27.78 },
  BAGAP: { id:3059, name:"BAGAP", x_nm:108.41, y_nm:-30.09 },
  VALUD: { id:3060, name:"VALUD", x_nm:99.89, y_nm:-54.93 },
  EPWA: { id:3061, name:"EPWA", x_nm:161.31, y_nm:-65.25 },
  EPMO: { id:3062, name:"EPMO", x_nm:140.01, y_nm:-81.91 },
  EPKT: { id:3063, name:"EPKT", x_nm:83.47, y_nm:38.30 },
  EPKK: { id:3064, name:"EPKK", x_nm:111.24, y_nm:61.49 },
  UVIVI: { id:3065, name:"UVIVI", x_nm:38.23, y_nm:-28.62 },
  LUNUK: { id:3066, name:"LUNUK", x_nm:44.55, y_nm:-20.72 },
  VAGSA: { id:3067, name:"VAGSA", x_nm:25.82, y_nm:-13.52 },
  DEVEG: { id:3068, name:"DEVEG", x_nm:22.94, y_nm:14.50 },
  SABAB: { id:3069, name:"SABAB", x_nm:38.75, y_nm:20.42 },
  EPOPA: { id:3070, name:"EPOPA", x_nm:34.40, y_nm:44.50 },
  PEKOT: { id:3071, name:"PEKOT", x_nm:20.73, y_nm:43.60 },
  DINOV: { id:3072, name:"DINOV", x_nm:-30.14, y_nm:11.87 },
  EKSEK: { id:3073, name:"EKSEK", x_nm:-49.15, y_nm:-3.01 },
  NUPLU: { id:3074, name:"NUPLU", x_nm:-33.17, y_nm:-2.77 },
  LUXAR: { id:3075, name:"LUXAR", x_nm:144.83, y_nm:60.88 },
  NUDRO: { id:3076, name:"NUDRO", x_nm:17.22, y_nm:-2.88 },
  TRZ: { id:3077, name:"TRZ", x_nm:8.74, y_nm:-12.27 },
  VELAB: { id:3078, name:"VELAB", x_nm:-4.47, y_nm:-21.70 },
  ARMEX: { id:3079, name:"ARMEX", x_nm:9.49, y_nm:-23.37 },
  AGALU: { id:3080, name:"AGALU", x_nm:19.23, y_nm:-21.69 },
  RASUT: { id:3081, name:"RASUT", x_nm:-23.55, y_nm:-2.72 },
  ROTOL: { id:3082, name:"ROTOL", x_nm:-22.67, y_nm:7.72 },
  ETNEL: { id:3083, name:"ETNEL", x_nm:10.33, y_nm:15.77 },
  GOBAX: { id:3084, name:"GOBAX", x_nm:-113.88, y_nm:-27.51 },
  OKG: { id:3085, name:"OKG", x_nm:-127.39, y_nm:33.49 },
  MIKOV: { id:3086, name:"MIKOV", x_nm:0.58, y_nm:105.43 },
  VALPI: { id:3087, name:"VALPI", x_nm:51.82, y_nm:95.57 },
  GRU: { id:3088, name:"GRU", x_nm:72.85, y_nm:-130.19 },
  ETUBO: { id:3089, name:"ETUBO", x_nm:195.19, y_nm:-68.21 },
  CHO: { id:3090, name:"CHO", x_nm:-42.82, y_nm:-108.62 },
  LEGNO: { id:3091, name:"LEGNO", x_nm:200.88, y_nm:-12.01 },
  EPLL: { id:3092, name:"EPLL", x_nm:94.91, y_nm:-37.48 },
  MISKA: { id:3093, name:"MISKA", x_nm:2.20, y_nm:-4.86 },
});

// Rebuild WP_ALL and edge-gate list
const WP_ALL = Object.values(WP);




// helper
function getWPById(id){
  // prefer dynamic wpts the user added, then static catalog
  return wpts.find(w=>w.id===id) || WP_ALL.find(w=>w.id===id) || null;
}

function setEditing(field){
  const sel = getSelected();
  state.editing = sel ? { id: sel.id, field } : null;
  layoutTags(); drawLeaders(); // quick visual refresh
}
function clearEditing(field){
  if (!state.editing) return;
  if (!field || state.editing.field === field) {
    state.editing = null;
    layoutTags(); drawLeaders();
  }
}

// lookup by name (static + dynamic), case-insensitive
function findFixByName(name){
  const nm = String(name||"").trim().toUpperCase();
  if (!nm) return null;
  return wpts.find(w=>w.name.toUpperCase()===nm)
      || WP_ALL.find(w=>w.name.toUpperCase()===nm)
      || null;
}

// === HARD-CODED ROUTES (parsed from human-friendly list) ===================
// Paste your list verbatim in ROUTE_TEXT. Parser will do the rest.
const ROUTE_TEXT = `
EPWA dep: (climbing fl240)
WAR LOLSI INDIG MASIV BADUP CZE OBOLA KELOD BAREP SUI
WAR SOXER BAXIS UVIVI AGALU NUPLU TOMTI OKX OKG

EPWA arr:
SUI BAREP KELOD OBOLA CZE DIPKI TENVO OBOKU PEVUM AMUTO DOSIX BIMPA GODIL WAR
GOBAX KORUP LATAG AKAPI CZE DIPKI TENVO OBOKU PEVUM AMUTO DOSIX BIMPA GODIL WAR
LAGAR VAGSA LUNUK OKENO AGAVA WAR

EPMO dep: (climbing fl240)
GODIL LOLSI INDIG MASIV BADUP CZE OBOLA KELOD BAREP SUI
GODIL SOXER BAXIS UVIVI AGALU NUPLU TOMTI OKX OKG

EPMO arr:
SUI BAREP KELOD OBOLA CZE DIPKI TENVO OBOKU PEVUM AMUTO DOSIX BIMPA GODIL
GOBAX KORUP LATAG AKAPI CZE DIPKI TENVO OBOKU PEVUM AMUTO DOSIX BIMPA GODIL

EPKK dep: (climbing fl280)
NUMBA DINOV EKSEK LASIS GOBAX
JED NUBLI BAGAP VALUD PENEX VAVEK GRU

EPKK arr:
GOBAX LASIS NUPLU ETNEL MAPIK
GRU VAVEK PENEX VALUD LDZ BAGAP NUBLI JED

EPKT dep: (climbing fl240)
NUMBA DINOV EKSEK LASIS GOBAX
JED NUBLI BAGAP VALUD PENEX VAVEK GRU

EPKT arr:
GOBAX LASIS NUPLU ETNEL MAPIK
GRU VAVEK PENEX VALUD LDZ BAGAP NUBLI JED

EPWR dep: (climbing f100)
RASUT NUPLU EKSEK NAROX GOBAX
RASUT NUPLU TOMTI OKX OKG
DEVEG SABAB SUDOL LUXAR
ETNEL PEKOT DESEN MIKOV
DEVEG EPOPA AMTEK
VAGSA LUNUK OKENO AGAVA WAR (to EPWA)

EPWR arr:
LAGAR ROTOL WR603
GOBAX NAROX EKSEK NUPLU WR603
LUXAR SUDOL SABAB DEVEG WR603

EPLL dep: (climbing fl100)
UTOLU INDIG MASIV BADUP CZE OBOLA KELOD BAREP SUI
BAXIS UVIVI AGALU NUPLU TOMTI OKX OKG

EPLL arr:
SUI BAREP KELOD OBOLA CZE BADUP MASIV INDIG UTOLU
LAGAR DINOV MISKA VAGSA LUNUK ABAKU

EPPO dep: (climbing fl190)
OBOLA LATAG RASAN OKX OKG
CZE XIDNA ARMEX NUDRO DEVEG EPOPA AMTEK VALPI

EPPO arr:
JED BAREX BESTO CZE
VALPI REGLI EPOPA DEVEG NUDRO ARMEX XIDNA CZE
TOMTI DIMEX AKAPI CZE

LKPR dep: (climbing fl270)
PR532 GOLOP LAGAR VAGSA LUNUK OKENO ABAKU LDZ ETUBO
PR532 GOLOP TOMTI DIMEX AKAPI CZE

LKPR arr:
WAR SOXER BAXIS UVIVI AGALU NUPLU TOMTI OKX GOLOP PR532
OBOLA LATAG RASAN OKX GOLOP PR532

now for the transits:
MIKOV DESEN PEKOT ETNEL VELAB AKAPI OBOLA CHO
MIKOV DESEN PEKOT ETNEL VELAB DIMEX LATAG GOVEN
VALPI REGLI EPOPA DEVEG NUDRO TRZ DIMEX GOVEN
VALPI REGLI EPOPA DEVEG NUDRO ARMEX XIDNA CZE
LUXAR SUDOL SABAB NUDRO ARMEX XIDNA CZE
LUXAR SUDOL SABAB NUDRO TRZ DIMEX GOVEN
LUXAR NUMBA DINOV EKSEK LASIS GOBAX
LUXAR JED NUBLI LDZ VALUD PENEX VAVEK
LUXAR JED MAKOV BADNO CZE CHO
LEGNO LDZ UTOLU INDIG MASIV BADUP CZE OBOLA KELOD BAREP SUI
LEGNO LDZ BAXIS UVIVI AGALU NUPLU TOMTI OKX OKG
WAR UTOLU INDIG MASIV BADUP CZE OBOLA KELOD BAREP SUI
WAR UTOLU INDIG MASIV BADUP CZE CHO
WAR INDIG LATAG KORUP
GRU VAVEK PENEX VALUD LDZ BAGAP NUBLI JED LUXAR
GRU ERPAB OBOKU INDIG UVIVI SABAB DESEN MIKOV
GRU ERPAB OBOKU INDIG UVIVI SABAB DESEN VALPI
GRU OBOLA LATAG RASAN OKX OKG
SUI BAREP KELOD OBOLA CZE BADUP MASIV INDIG LDZ LEGNO
SUI BAREP KELOD OBOLA CZE BADNO UVIVI LUNUK BAREX JED
SUI BAREP KELOD OBOLA CZE BADNO UVIVI LUNUK BAREX LUXAR
GOVEN LATAG DIMEX VELAB TRZ BAREX JED
GOVEN LATAG DIMEX VELAB TRZ NUDRO SUDOL LUXAR
GOVEN LATAG DIMEX VELAB TRZ PEKOT DESEN VALPI
GOVEN LATAG DIMEX VELAB TRZ PEKOT DESEN MIKOV
GOBAX LASIS RASUT DEVEG SABAB SUDOL LUXAR
GOBAX LASIS RASUT DEVEG SABAB SUDOL JED
GOBAX LASIS NUPLU ETNEL PEKOT DESEN VALPI
GOBAX LASIS NUPLU ETNEL PEKOT DESEN MIKOV
OKG LAGAR VAGSA LUNUK OKENO ABAKU LDZ ETUBO
OKG TOMTI DIMEX AKAPI CZE CHO
OKG TOMTI DIMEX AKAPI CZE
CHO CZE BESTO VAGSA EPOPA AMTEK VALPI
`;

// Parse headers + rows → { dep:{ICAO:[...names]}, arr:{ICAO:[...names]}, transit:[...names] }
function parseRouteTemplates(text){
  const dep={}, arr={}, transit=[];
  let mode=null, apt=null;
  for(const raw of text.split(/\r?\n/)){
    const line = raw.trim();
    if(!line) continue;
    const m = line.match(/^([A-Z]{4})\s+(dep|arr)\s*:?/i);
    if(m){ apt=m[1].toUpperCase(); mode=m[2].toLowerCase(); continue; }
    if(/^now for the transits/i.test(line) || /^all of .*transit/i.test(line)){ mode='transit'; apt=null; continue; }
    const cleaned = line.replace(/\([^)]*\)/g,'').trim();
    if(!cleaned) continue;
    const names = cleaned.split(/\s+/).map(s=>s.toUpperCase());
    if(!names.length) continue;
    if(mode==='dep' && apt){ (dep[apt]??=[]).push([apt, ...names]); }
    else if(mode==='arr' && apt){ (arr[apt]??=[]).push([...names, apt]); }
    else if(mode==='transit'){ transit.push(names); }
  }
  return {dep, arr, transit};
}
const ROUTE_TEMPLATES = parseRouteTemplates(ROUTE_TEXT);

// Convert names → IDs (drop routes with unknown fixes)
function namesToIds(names){
  const ids=[], missing=[];
  for(const nm of names){
    const w = findFixByName(nm); // uses your static WP + any dynamic wpts
    if(!w) missing.push(nm); else ids.push(w.id);
  }
  if(missing.length){
    console.warn('[Routes] Skipping (missing fixes):', missing.join(', '), 'in', names.join(' → '));
    return null;
  }
  return ids;
}

const DEP_ROUTES_ID = {};
for(const [apt, list] of Object.entries(ROUTE_TEMPLATES.dep)){
  const ok = list.map(namesToIds).filter(Boolean);
  if(ok.length) DEP_ROUTES_ID[apt] = ok;
}
const ARR_ROUTES_ID = {};
for(const [apt, list] of Object.entries(ROUTE_TEMPLATES.arr)){
  const ok = list.map(namesToIds).filter(Boolean);
  if(ok.length) ARR_ROUTES_ID[apt] = ok;
}
const TRANSIT_ROUTES_ID = ROUTE_TEMPLATES.transit.map(namesToIds).filter(Boolean);

const pickRand = arr => arr[Math.random()*arr.length|0];

// === Route builders: only use your templates ===============================
function buildDepartureRoute(fp){
  const keys = Object.keys(DEP_ROUTES_ID);
  if(!keys.length) return [];
  const apt = (fp && DEP_ROUTES_ID[fp.dep]) ? fp.dep : pickRand(keys);
  return pickRand(DEP_ROUTES_ID[apt]).slice();
}
function buildArrivalRoute(fp){
  const keys = Object.keys(ARR_ROUTES_ID);
  if(!keys.length) return [];
  const apt = (fp && ARR_ROUTES_ID[fp.dest]) ? fp.dest : pickRand(keys);
  return pickRand(ARR_ROUTES_ID[apt]).slice();
}

// ===== XFL rules for arrivals by destination (+ via FIX where applicable) ===
const ARR_XFL_RULES = {
  LKPR: 220,
  EPPO: 200,
  EPWR: 120,
  EPLL: 110,
  EPWA: { BIMPA:150, AGAVA:170 },
  EPMO: { BIMPA:150, AGAVA:170 },
  EPKK: { MAPIK:210, NUBLI:250 },
  EPKT: { MAPIK:110, NUBLI:250 },
};

function determineArrivalXFL(ac){
  if (ac.role!=='arrival' || !ac.fp?.dest) return null;
  const dest = ac.fp.dest.toUpperCase();
  const rule = ARR_XFL_RULES[dest];
  if (!rule) return null;

  const hasFix = (name)=> (ac.route||[]).some(id => (env.getWaypoint(id)?.name||"")===name);

  if (typeof rule === 'number') return rule*100;
  for (const [fix, fl] of Object.entries(rule)){
    if (hasFix(fix)) return fl*100;
  }
  return null;
}

function buildTransitRoute(/*fp*/){
  return TRANSIT_ROUTES_ID.length ? pickRand(TRANSIT_ROUTES_ID).slice() : [];
}

// === Optional: override makeSFP() so spawns use airports we have ===========
function makeSFP({dep=null, dest=null, cruiseFL=360, tasKt=450, type=null}={}){
  const depKeys = Object.keys(DEP_ROUTES_ID);
  const arrKeys = Object.keys(ARR_ROUTES_ID);
  const pick = a => a[Math.random()*a.length|0];
  const depApt = dep && DEP_ROUTES_ID[dep] ? dep : (depKeys.length ? pick(depKeys) : null);
  // try not to pick the same code for dest if avoidable
  let destApt = dest && ARR_ROUTES_ID[dest] ? dest : (arrKeys.length ? pick(arrKeys) : null);
  if(destApt && depApt && arrKeys.length>1 && destApt===depApt){
    do{ destApt = pick(arrKeys); } while(destApt===depApt);
  }
  return { dep:depApt, dest:destApt, cruiseFL, tasKt, type: type ?? pick(TYPES) };
}

console.info('[Routes] Loaded:',
  Object.keys(DEP_ROUTES_ID).length, 'dep apts,',
  Object.keys(ARR_ROUTES_ID).length, 'arr apts,',
  TRANSIT_ROUTES_ID.length, 'transit options');





// Put this near your other globals (above spawnAircraft)
const SPAWN = {
  flMin: 330,      // inclusive
  flMax: 400,      // inclusive
  marginNM: 25,     // how far outside the sector to spawn
  jitterDeg: 45    // ± jitter to avoid perfectly cardinal inbounds
};

// === Despawn policy (last-fix / FL0) =========================
const DESPAWN_AFTER_LASTFIX_SEC = 25;  // X sec after passing final FPL fix
const DESPAWN_FL0_FT            = 50;  // arrivals despawn at/under ~FL0
const NEVER_SEEN_MAX_SEC        = 1200; // safety: 20 min if truly never visible

// --- Auto spawner (cooldown-based; guarantees ≤1 spawn per tick) ---
const AutoSpawn = {
  enabled: false,
  cooldownSec: Infinity,   // counts down while enabled; Infinity when disabled
  minGap: 65,
  maxGap: 85,
  conflictChance: 0.00
};
function randGap(){
  return AutoSpawn.minGap + Math.random()*(AutoSpawn.maxGap - AutoSpawn.minGap);
}
function armCooldown(){ AutoSpawn.cooldownSec = randGap(); }
function disarmCooldown(){ AutoSpawn.cooldownSec = Infinity; }

// routeMode can be 'arrival' | 'departure' | 'transit' | null
function spawnWithParams({x_nm,y_nm,hdg,alt_ft,spd_kt, jitterDeg=0, routeMode=null, routeOverride=null}, fp=null){
  const a = new Aircraft({ x_nm, y_nm, hdg, alt_ft, spd_kt, fp, role: routeMode });

  if (jitterDeg) hdg = mod360(hdg + rand(-jitterDeg, +jitterDeg));
  a.setHeading(hdg);
  a.inSector = env.inRect(a.x_nm, a.y_nm, a.alt_ft);

  if (fp) {
  // Decide routing mode if caller didn't force one
  let mode = routeMode ?? (!env.inRect(x_nm, y_nm) ? 'arrival' : 'departure');

  // 1) Build from templates only
  let route;
  if (mode === 'transit')      route = buildTransitRoute(fp);
  else if (mode === 'arrival') route = buildArrivalRoute(fp);
  else                         route = buildDepartureRoute(fp);

  // 2) Use exactly what was picked (no align/sanitize/CTR)
  if (Array.isArray(route) && route.length){
    a.setRoute(route);
  }
  // XFL by mode
if (mode === 'arrival'){
  a.xfl_ft = determineArrivalXFL(a) ?? 20000;
} else if (mode === 'departure'){
  const depFLtens = randi(Math.floor(SPAWN.flMin/10), Math.floor(SPAWN.flMax/10));
  a.xfl_ft = depFLtens*10*100;
} else {
  a.xfl_ft = (a.fp?.cruiseFL ? a.fp.cruiseFL*100 : 30000);
}

}
// Decide routing mode if caller didn't force one
let mode = routeMode ?? (!env.inRect(x_nm, y_nm) ? 'arrival' : 'departure');

// Use provided route if given; otherwise build from templates
let route = routeOverride ? routeOverride.slice() :
    (mode === 'transit' ? buildTransitRoute(fp) :
        (mode === 'arrival' ? buildArrivalRoute(fp) : buildDepartureRoute(fp)));
        
if (Array.isArray(route) && route.length){
    a.setRoute(route);
}


  state.ac.push(a);

  // Fallback: no route? nudge toward the nearest known fix (static or dynamic)
if (!a.route.length){
  const allFixes = [...WP_ALL, ...wpts];
  if (allFixes.length){
    let bestId = null, bestD = Infinity;
    for (const w of allFixes){
      const d = Math.hypot(w.x_nm - a.x_nm, w.y_nm - a.y_nm);
      if (d < bestD){ bestD = d; bestId = w.id; }
    }
    if (bestId != null) a.directTo(bestId);
  }
}


  
  drawAll();
  return a;
}

// Spawn just outside the sector bbox along the ray from (0,0) → firstFix,
// then point the nose back to the first fix. Always ends up near the boundary,
// not hundreds of miles away even if the fix itself is far.
function spawnPointNearSectorTowardsFix(firstFixId){
  const fix = getWPById(firstFixId);
  if (!fix) return null;

  const vx = fix.x_nm, vy = fix.y_nm;
  const halfW = env.rectW/2, halfH = env.rectH/2;
  const len = Math.hypot(vx, vy) || 1;
  const ux = vx/len, uy = vy/len;
  const push = 6 + Math.random()*4;                  // 6–10 NM outside
  const m = Math.max(6, Math.min(SPAWN.marginNM, 20));

  const cand = [];

  // Intersect ray with vertical bbox sides
  if (vx !== 0){
    const tx = (vx > 0 ?  halfW : -halfW) / vx;
    const y  = vy * tx;
    if (tx > 0 && Math.abs(y) <= halfH) cand.push({ t:tx, x:vx*tx, y });
  }

  // Intersect ray with horizontal bbox sides
  if (vy !== 0){
    const ty = (vy > 0 ?  halfH : -halfH) / vy;
    const x  = vx * ty;
    if (ty > 0 && Math.abs(x) <= halfW) cand.push({ t:ty, x, y:vy*ty });
  }

  if (!cand.length){
    // Fallback: go to the corner on this bearing
    const t = Math.min(halfW/Math.abs(vx||1e-6), halfH/Math.abs(vy||1e-6));
    cand.push({ t, x:vx*t, y:vy*t });
  }

  cand.sort((a,b)=>a.t-b.t);
  const edge = cand[0];

  const x = edge.x + ux * (m + push);
  const y = edge.y + uy * (m + push);
  const hdg = mod360(toDeg(Math.atan2(fix.x_nm - x, -(fix.y_nm - y))));
  return { x_nm:x, y_nm:y, hdg };
}



function spawnPlannedAircraft(){
  const halfW = env.rectW/2, halfH = env.rectH/2, m = SPAWN.marginNM;

  // --- mode split (weights) ---
  const wTransit=0.80, wArrival=0.10, wDepart=0.10;
  const r = Math.random();
  let mode = (r < wTransit) ? 'transit' : (r < wTransit + wArrival ? 'arrival' : 'departure');

  // Common cruise & speed for non-departures
  const tMin = Math.floor(SPAWN.flMin/10);
  const tMax = Math.floor(SPAWN.flMax/10);
  const FL   = (tMin + randi(0, tMax - tMin))*10;
  const alt  = FL*100;
  const spd1 = 430 + Math.random()*70;

  // ===== DEPARTURE: spawn AT APT, FL0, head to first fix =====
  if (mode === 'departure'){
    const apt = pickDepartureAirport();
    if (!apt){
      console.warn("No known departure airports; falling back to transit.");
      mode = 'transit';
    } else {
      const climbFL = DEPART_CLIMB_FL[apt.name] ?? 240;
      const fp      = makeSFP({ dep: apt.name, cruiseFL: climbFL, tasKt: Math.round(spd1) });

      // Build exact route from your templates; ensure it starts with the APT
      let route = buildDepartureRoute(fp);
      if (!route.length){
        console.warn("No dep route built; falling back to transit.");
        mode = 'transit';
      } else {
        if (route[0] !== apt.id) route.unshift(apt.id); // belt & suspenders
        const nextFix = (route.length >= 2) ? getWPById(route[1]) : null;
        const initHdg = nextFix ? bearingFromTo(apt.x_nm, apt.y_nm, nextFix.x_nm, nextFix.y_nm) : 0;

        const a = spawnWithParams(
          { x_nm: apt.x_nm, y_nm: apt.y_nm, hdg: initHdg, alt_ft: 0, spd_kt: 220,
            routeMode:'departure', routeOverride: route },
          fp
        );
        a.setAltitude(climbFL * 100);
        drawAll();
        return a;
      }
    }
  }

  // ===== ARRIVAL: spawn just outside bbox towards FIRST route fix =====
if (mode === 'arrival'){
  const fp  = makeSFP({ cruiseFL: FL, tasKt: Math.round(spd1) });
  const rte = buildArrivalRoute(fp);

  if (Array.isArray(rte) && rte.length){
    const p = spawnPointNearSectorTowardsFix(rte[0]);
    if (p){
      return spawnWithParams(
        { x_nm:p.x_nm, y_nm:p.y_nm, hdg:p.hdg, alt_ft:alt, spd_kt:spd1,
          routeMode:'arrival', routeOverride:rte },
        fp
      );
    }
  }

  // Fallback — legacy random edge if no route / couldn't place near first fix
  const side = randi(0,3);
  let x=0,y=0,baseHdg=0;
  if (side===0){ y=-(halfH+m); x=rand(-halfW*0.9, halfW*0.9); baseHdg=180; }
  else if(side===1){ x=(halfW+m); y=rand(-halfH*0.9, halfH*0.9); baseHdg=270; }
  else if(side===2){ y=(halfH+m); x=rand(-halfW*0.9, halfW*0.9); baseHdg=0; }
  else { x=-(halfW+m); y=rand(-halfH*0.9, halfH*0.9); baseHdg=90; }
  const hdg = mod360(baseHdg + rand(-SPAWN.jitterDeg, SPAWN.jitterDeg));
  return spawnWithParams({x_nm:x,y_nm:y,hdg,alt_ft:alt,spd_kt:spd1, routeMode:'arrival'}, fp);
}


  // ===== TRANSIT: start just outside bbox towards first fix =====
  {
    const fp    = makeSFP({ cruiseFL: FL, tasKt: Math.round(spd1) });
    const route = buildTransitRoute(fp);

    if (!route.length){
      // Fallback to legacy edge spawn if somehow no route available
      const side = randi(0,3);
      let x=0,y=0,baseHdg=0;
      if (side===0){ y=-(halfH+m); x=rand(-halfW*0.9, halfW*0.9); baseHdg=180; }
      else if(side===1){ x=(halfW+m); y=rand(-halfH*0.9, halfH*0.9); baseHdg=270; }
      else if(side===2){ y=(halfH+m); x=rand(-halfW*0.9, halfW*0.9); baseHdg=0; }
      else { x=-(halfW+m); y=rand(-halfH*0.9, halfH*0.9); baseHdg=90; }
      const hdg = mod360(baseHdg + rand(-SPAWN.jitterDeg, SPAWN.jitterDeg));
      return spawnWithParams({x_nm:x,y_nm:y,hdg,alt_ft:alt,spd_kt:spd1, routeMode:'transit'}, fp);
    }

    const p = spawnPointNearSectorTowardsFix(route[0]);
    if (!p){
      console.warn("Could not place near first fix; using legacy edge spawn.");
      const side = randi(0,3);
      let x=0,y=0,baseHdg=0;
      if (side===0){ y=-(halfH+m); x=rand(-halfW*0.9, halfW*0.9); baseHdg=180; }
      else if(side===1){ x=(halfW+m); y=rand(-halfH*0.9, halfH*0.9); baseHdg=270; }
      else if(side===2){ y=(halfH+m); x=rand(-halfW*0.9, halfW*0.9); baseHdg=0; }
      else { x=-(halfW+m); y=rand(-halfH*0.9, halfH*0.9); baseHdg=90; }
      const hdg = mod360(baseHdg + rand(-SPAWN.jitterDeg, SPAWN.jitterDeg));
      return spawnWithParams({x_nm:x,y_nm:y,hdg,alt_ft:alt,spd_kt:spd1, routeMode:'transit'}, fp);
    }

    // Perfect: spawn just outside bbox, fly to first fix, and use the exact route
    return spawnWithParams(
      { x_nm:p.x_nm, y_nm:p.y_nm, hdg:p.hdg, alt_ft:alt, spd_kt:spd1,
        routeMode:'transit', routeOverride: route },
      fp
    );
  }
}




// Spawn a conflict pack (pair or triple) that will converge near center
function spawnConflictPack(useRoutes=false){
  const halfW = env.rectW/2, halfH = env.rectH/2, m = SPAWN.marginNM;

  // Same level for all units in the pack
  const tMin = Math.floor(SPAWN.flMin/10);
  const tMax = Math.floor(SPAWN.flMax/10);
  const FL   = (tMin + randi(0, tMax - tMin))*10;
  const alt  = FL*100;
  const spd1 = 430 + Math.random()*60;
  const spd2 = 430 + Math.random()*60;

  // Choose axis pair (E↔W or N↔S) so they cross the middle
  const EW = Math.random() < 0.5;
  
    const fpArg = useRoutes ? makeSFP({cruiseFL:FL}) : null;


  if (EW){
    // One from West → East, one from East → West, slight vertical offset
    const y = rand(-halfH*0.6, halfH*0.6);
    spawnWithParams({ x_nm:-(halfW+m), y_nm:y+rand(-4, +4), hdg:90+rand(-10,10), alt_ft:alt, spd_kt:spd1 }, fpArg);
    spawnWithParams({ x_nm:(halfW+m),  y_nm:y+rand(-4, +4), hdg:270+rand(-10,10),alt_ft:alt, spd_kt:spd2 }, fpArg);


  } else {
    // One from North → South, one from South → North
    const x = rand(-halfW*0.6, halfW*0.6);
    spawnWithParams({ x_nm:x+rand(-4,+4), y_nm:-(halfH+m), hdg:180+rand(-10,10), alt_ft:alt, spd_kt:spd1 }, fpArg);
    spawnWithParams({ x_nm:x+rand(-4,+4), y_nm:(halfH+m),  hdg:0+rand(-10,10),   alt_ft:alt, spd_kt:spd2 }, fpArg);

  }

  // 30% chance add a third crosser to spice it up
  if (Math.random() < 0.30){
    const hdg = randi(0,3)*90 + rand(-20,20);
    const side = randi(0,3);
    let x=0,y=0;
    if (side===0){ y=-(halfH+m); x=rand(-halfW*0.9, halfW*0.9); }
    else if(side===1){ x=(halfW+m); y=rand(-halfH*0.9, halfH*0.9); }
    else if(side===2){ y=(halfH+m); x=rand(-halfW*0.9, halfW*0.9); }
    else { x=-(halfW+m); y=rand(-halfH*0.9, halfH*0.9); }
    spawnWithParams({ x_nm:x, y_nm:y, hdg, alt_ft:alt, spd_kt: 430+Math.random()*60 }, fpArg);
  }
}


 function spawnAircraft(){
  // Choose a sector edge to spawn from: 0=N, 1=E, 2=S, 3=W
  const side = Math.floor(Math.random()*4);
  const halfW = env.rectW/2, halfH = env.rectH/2;
  const m = SPAWN.marginNM;

  let x=0, y=0, hdg=0;

  switch(side){
    case 0: // from North → heading South
      y = -(halfH + m);
      x = (Math.random()*2 - 1) * (halfW * 0.9);
      hdg = 180;
      break;
    case 1: // from East → heading West
      x =  (halfW + m);
      y = (Math.random()*2 - 1) * (halfH * 0.9);
      hdg = 270;
      break;
    case 2: // from South → heading North
      y =  (halfH + m);
      x = (Math.random()*2 - 1) * (halfW * 0.9);
      hdg = 0;
      break;
    default: // from West → heading East
      x = -(halfW + m);
      y = (Math.random()*2 - 1) * (halfH * 0.9);
      hdg = 90;
      break;
  }



  // Add a little randomization so they’re not laser-straight
  hdg = mod360(hdg + (Math.random()*SPAWN.jitterDeg*2 - SPAWN.jitterDeg));

  // Pick FL in tens within [flMin, flMax]
  const tMin = Math.floor(SPAWN.flMin/10);
  const tMax = Math.floor(SPAWN.flMax/10);
  const tens = tMin + Math.floor(Math.random()*(tMax - tMin + 1)); // integer step of 10 FLs
  const FL = tens * 10;
  const alt = FL * 100; // your sim uses FL * 100 = feet

  // Cruise-y speed; you can also switch to Mach if you prefer
  const spd = 430 + Math.random()*60;

  const a = new Aircraft({ x_nm:x, y_nm:y, hdg:hdg, alt_ft:alt, spd_kt:spd });
  a.setHeading(hdg);                   // ensure initial vector is inbound
  a.inSector = env.inRect(a.x_nm, a.y_nm);

  state.ac.push(a);
  drawAll();
}

  function clearAll(){
    state.ac.length=0; state.selectedId=null; updateSelectedPanel();
    // remove leftover tags
    for(const el of tagMap.values()) el.remove(); tagMap.clear();
    drawAll();
  }

  // ---------- Conflict detection ----------
  const sepNM=5, sepFT=1000;
  // Predicted band config (draw amber segments from lookahead → impact)
const PREDICT_SCAN_STEP_SEC = 10;  // draw a segment every 10 s
const PREDICT_MAX_EXTRA_SEC = 360; // scan up to +6 min beyond lookahead

// Store rich geometry per predicted pair for drawing the continuous band
// Each entry: { aId, bId, tStart, tImpact, segments:[{ax,ay,bx,by}] }

  function project(ac,tSec){
    const dist_nm=ac.spd_kt*nmPerKtPerSec*tSec;
    const x=ac.x_nm+Math.sin(toRad(ac.hdg))*dist_nm;
    const y=ac.y_nm-Math.cos(toRad(ac.hdg))*dist_nm;
    let alt=ac.alt_ft;
    if(ac.alt_ft!==ac.tgtAlt){
      const vs_fps=clamp(ac.vs_fpm*ftPerMinToFtPerSec, -ac.maxVS_fps, ac.maxVS_fps);
      const delta=vs_fps*tSec; const rem=ac.tgtAlt-ac.alt_ft;
      if(Math.sign(rem)===Math.sign(delta)&&Math.abs(delta)<=Math.abs(rem)) alt=ac.alt_ft+delta; else alt=ac.tgtAlt;
    }
    return {x,y,alt};
  }
  function projectAt(ac, tSec){
  // reuse your existing 'project' logic
  return project(ac, tSec);
}

// true if track takes part in an active conflict NOW
function hasActiveConflict(id){
  return state.conflictsNow.some(pair => Array.isArray(pair) ? (pair[0]===id || pair[1]===id)
                                                             : (pair.aId===id || pair.bId===id));
}

// true if track takes part in a predicted conflict (within lookahead window)
function hasPredConflict(id){
  return state.conflictsPred.some(pair => Array.isArray(pair) ? (pair[0]===id || pair[1]===id)
                                                              : (pair.aId===id || pair.bId===id));
}

/**
 * Build the "continuous" predicted band between two aircraft:
 * from tStart (= lookahead) stepping every dt until the first
 * loss of separation; returns geometry and impact time.
 */
function buildPredictedConflictBand(a, b, tStartSec, extraMaxSec=PREDICT_MAX_EXTRA_SEC, dt=PREDICT_SCAN_STEP_SEC){
  const segments = [];
  const sepN = sepNM, sepF = sepFT;
  const tEnd = tStartSec + extraMaxSec;

  let tImpact = null;
  let lastOK = null;

  // coarse sweep; keep each segment (ax,ay)–(bx,by) we draw
  for(let t=tStartSec; t<=tEnd; t+=dt){
    const pa = projectAt(a, t);
    const pb = projectAt(b, t);
    const dnm = Math.hypot(pa.x - pb.x, pa.y - pb.y);
    const dft = Math.abs(pa.alt - pb.alt);

    // store this time step segment to draw a continuous band
    const ax = cx + nmToPx(pa.x), ay = cy + nmToPx(pa.y);
    const bx = cx + nmToPx(pb.x), by = cy + nmToPx(pb.y);
    segments.push({ ax, ay, bx, by, t });

    if (dnm < sepN && dft < sepF){
      tImpact = t;
      break;
    }
    lastOK = t;
  }

  // (Optional) tiny refine back from tImpact for nicer end-cap
  if (tImpact != null && dt > 1){
    let lo = Math.max(tStartSec, (lastOK ?? tStartSec));
    let hi = tImpact, mid;
    for(let k=0;k<8;k++){
      mid = (lo+hi)/2;
      const pa = projectAt(a, mid);
      const pb = projectAt(b, mid);
      const dnm = Math.hypot(pa.x - pb.x, pa.y - pb.y);
      const dft = Math.abs(pa.alt - pb.alt);
      if (dnm < sepN && dft < sepF) hi = mid; else lo = mid;
    }
    tImpact = hi;
  }

  return { segments, tImpact };
}

  function detectConflicts(){
  state.conflictsNow.length = 0;
  state.conflictsPred.length = 0;
  state.conflictsPredDetail.length = 0;

  const tStart = state.lookaheadMin * 60;   // lookahead start (s)
  const scan   = PREDICT_MAX_EXTRA_SEC;

  for(let i=0;i<state.ac.length;i++){
    for(let j=i+1;j<state.ac.length;j++){
      const a = state.ac[i], b = state.ac[j];

      // --- Current (t=0) check
      const dnm0 = Math.hypot(a.x_nm - b.x_nm, a.y_nm - b.y_nm);
      const dft0 = Math.abs(a.alt_ft - b.alt_ft);
      const nowHit = (dnm0 < sepNM && dft0 < sepFT);
      if (nowHit){
        state.conflictsNow.push([a.id, b.id]);
        continue; // red takes precedence, no need to also mark predicted
      }

      if (tStart <= 0) continue;

      // --- Predicted band from lookahead → first impact (if any)
      const band = buildPredictedConflictBand(a, b, tStart, scan, PREDICT_SCAN_STEP_SEC);
      if (band.tImpact != null){
        state.conflictsPred.push([a.id, b.id]); // for quick lookups
        state.conflictsPredDetail.push({
          aId:a.id, bId:b.id, tStart, tImpact:band.tImpact, segments:band.segments
        });
      }
    }
  }
}


  // ---------- Drawing (split: canvas vs DOM) ----------
  const tagMap = new Map(); // id -> element
  let wptElems=[];

  function layoutWptLabels(){
  for(const e of wptElems) e.remove(); wptElems.length=0;
  const all = [...WP_ALL, ...wpts];
  for(const w of all){
    const x=cx+nmToPx(w.x_nm), y=cy+nmToPx(w.y_nm);
    const lab=document.createElement('div');
    lab.className='waypointLabel';
    lab.textContent=w.name;
    lab.style.left=(x+8)+'px';
    lab.style.top =(y-10)+'px';
    wptElems.push(lab); wrap.appendChild(lab);
  }
}


  function layoutTags(){
    const presentIds = new Set();
    for(const a of state.ac){
      presentIds.add(a.id);
      const x=cx+nmToPx(a.x_nm), y=cy+nmToPx(a.y_nm);
      let tag = tagMap.get(a.id);
      if(!tag){
        tag=document.createElement('div');
        tag.className='tag';
        tag.dataset.trackId=String(a.id);
        // Drag/select handlers
        let dragging=false, startX=0,startY=0, startDx=0,startDy=0, moved=false;
        tag.addEventListener('pointerdown', ev=>{
  // NEW: Shift + Left Click on tag → use that aircraft position as a measure point
  if (ev.shiftKey && ev.button === 0) {
    const ax = cx + nmToPx(a.x_nm);
    const ay = cy + nmToPx(a.y_nm);
    handleMeasureSmartClick(ax, ay);
    ev.preventDefault();
    return;
  }

  if(ev.button!==0) return; // left only
  dragging=true; moved=false; tag.setPointerCapture(ev.pointerId);
  tag.classList.add('dragging');
  const aObj = state.ac.find(z=>z.id===a.id); if(!aObj) return;
  startX=ev.clientX; startY=ev.clientY; startDx=aObj.labelDx; startDy=aObj.labelDy; ev.preventDefault();
});

        tag.addEventListener('pointermove', ev=>{
  if(!dragging) return;
  if ((ev.buttons & 1) === 0) {  // LMB no longer held
    dragging=false; tag.classList.remove('dragging');
    try{ tag.releasePointerCapture(ev.pointerId);}catch{}
    return;
  }
  const aObj = state.ac.find(z=>z.id===a.id); if(!aObj) return;
  const dx=ev.clientX-startX, dy=ev.clientY-startY;
  if(Math.hypot(dx,dy)>3) moved=true;
  aObj.labelDx = startDx + dx; aObj.labelDy = startDy + dy;
  tag.style.left = (cx+nmToPx(aObj.x_nm) + aObj.labelDx) + 'px';
  tag.style.top  = (cy+nmToPx(aObj.y_nm) + aObj.labelDy) + 'px';
  drawCanvasOnly();
  repositionLevelPicker();

});

        tag.addEventListener('pointerup', ev=>{
  tag.classList.remove('dragging');
  if(dragging && !moved){ state.selectedId=a.id; flashSelected(); updateSelectedPanel(); layoutTags(); drawCanvasOnly(); }
  dragging=false;
  try{ tag.releasePointerCapture(ev.pointerId);}catch{}
});
tag.addEventListener('pointercancel', ()=>{
  dragging=false; tag.classList.remove('dragging');
});
tag.addEventListener('lostpointercapture', ()=>{
  dragging=false; tag.classList.remove('dragging');
});

        tag.addEventListener('click', ev=>{ ev.stopPropagation(); });
        wrap.appendChild(tag);
        tagMap.set(a.id, tag);
        
        // Bind once per tag: Shift+MMB toggles the green route preview;
// also block the browser’s autoscroll on Shift+MMB.
tag.addEventListener('auxclick', (ev)=>{
  if (ev.button === 1 && ev.shiftKey){
    state.routePreviewId = (state.routePreviewId === a.id) ? null : a.id;
    drawAll(); // or drawCanvasOnly();
    ev.preventDefault();
    ev.stopPropagation();
  }
});
tag.addEventListener('mousedown', (ev)=>{
  if (ev.button === 1 && ev.shiftKey){
    ev.preventDefault();
    ev.stopPropagation();
  }
});

      }
      // Update classes/content/position
      const nowConflict  = hasActiveConflict(a.id);
    const predConflict = !nowConflict && hasPredConflict(a.id);
    tag.classList.toggle('alert', nowConflict);
    tag.classList.toggle('warn',  predConflict);

      // apply state color class for text-only labels
const st = getTrackState(a);   // uses helpers from step 2.3
tag.classList.remove('st-controlled','st-inbound','st-intruder','st-outbound');
tag.classList.add('st-'+st);
tag.classList.toggle('is-selected', a.id === state.selectedId);


// build 4 text lines (no box, no table)
const curFL = fmtFLshort(a.alt_ft);
const cfl   = fmtCFL(a.tgtAlt);
const type  = a.fp?.type || a.type;
const wpt   = nextWptName(a, env);
const vs100 = fmtVS100(a.vs_fpm);
const gs    = a.spd_kt | 0;  // <-- NEW (TAS ≈ GS)

const badgeHTML = nowConflict
  ? `<span class="badge alert">CA</span>`
  : (predConflict ? `<span class="badge warn">MD</span>` : ``);

tag.innerHTML = `
  ${badgeHTML ? `<div class="badges">${badgeHTML}</div>` : ``}
  <div class="l1">
    <span data-cs>${a.cs}</span>
    <span class="ho" data-ho="1" title="Toggle H/O">H/O</span>
    <span class="gs">GS${gs}</span>        <!-- NEW: GS on the top-right -->
  </div>
  <div class="l2">
    <span data-act="curfl">${curFL}</span>&nbsp;
    <span data-act="cfl">${cfl}</span>&nbsp;
    <span data-act="xfl">${fmtXFL(a.xfl_ft)}</span>
  </div>
  <div class="l2">
    <span data-act="type">${type}</span>&nbsp;&nbsp;
    <span data-act="wpt">${wpt}</span>
  </div>
  <div class="l2 ops">
    H<span data-act="hdg">${formatHeading(a.hdg)}</span>&nbsp;
    S<span data-act="spd">${a.ias_kt|0}</span> /                   <!-- IAS here -->
    M<span data-act="mach">${a.mach.toFixed(2)}</span>&nbsp;
    VS<span data-act="vs">${vs100}</span>
  </div>
`;



repositionLevelPicker();


// H/O toggle — MMB (immediate transfer, no arming)
const hoBtn = tag.querySelector('[data-ho]');
if (hoBtn){
  const updateHO = ()=>{
    hoBtn.setAttribute('aria-pressed', a.handedOff ? 'true' : 'false');
    hoBtn.textContent = a.handedOff ? 'XFER' : 'H/O';
    hoBtn.title = a.handedOff ? "Transferred (MMB to take back)" : "MMB to transfer now";
  };

  const redraw = ()=>{ layoutTags(); drawCanvasOnly(); updateSelectedPanel(); };

  // block browser autoscroll on MMB
  hoBtn.addEventListener('mousedown', (ev)=>{
    if (ev.button === 1){ ev.preventDefault(); ev.stopPropagation(); }
  }, true);

  // MMB = toggle transfer immediately (no arming)
  hoBtn.addEventListener('auxclick', (ev)=>{
    if (ev.button !== 1) return;
    ev.preventDefault(); ev.stopPropagation();
    a.handedOff = !a.handedOff;
    a.hoArmed = false; // ensure no lingering "armed" flag anywhere
    updateHO(); redraw();
  });

  // Optional fallback for trackpads: Alt+Click
  hoBtn.addEventListener('click', (ev)=>{
    if (!ev.altKey) return;
    ev.preventDefault(); ev.stopPropagation();
    a.handedOff = !a.handedOff;
    a.hoArmed = false;
    updateHO(); redraw();
  });

  updateHO();
}





// Middle-click on callsign => open SFP
const csBtn = tag.querySelector('[data-cs]');
if (csBtn){
  csBtn.addEventListener('mousedown', ev=>{
    if (ev.button === 1){ openSFP(a); ev.preventDefault(); }
  });
}

// ===== MMB-only editing for label values =====
const act = sel => tag.querySelector(`[data-act="${sel}"]`);

// clear previous highlight on this tag, then apply if this tag is being edited
tag.querySelectorAll('[data-act]').forEach(s=>s.classList.remove('editing'));
if (state.editing && state.editing.id === a.id){
  const hi = act(state.editing.field);
  if (hi) hi.classList.add('editing');
}
tag.classList.toggle('show-ops', !!(state.editing && state.editing.id === a.id));

// prevent autoscroll on middle mouse and stop it bubbling into drag
function blockMMB(el){
  if(!el) return;
  el.addEventListener('mousedown', ev=>{
    if (ev.button === 1){ ev.preventDefault(); ev.stopPropagation(); }
  });
}

// run an action only on true MMB (auxclick)
function withMMB(el, fn){
  if(!el) return;
  el.addEventListener('auxclick', ev=>{
    if (ev.button !== 1 || ev.shiftKey) return;  // plain-MMB only
    ev.preventDefault();
    ev.stopPropagation();
    fn();
  });
}


// H
const hdgEl = act('hdg'); blockMMB(hdgEl);
withMMB(hdgEl, ()=>{
  state.selectedId = a.id; updateSelectedPanel();
  openHeadingPicker(hdgEl, a);
});

// S (IAS)
const spdEl = act('spd'); blockMMB(spdEl);
withMMB(spdEl, ()=>{
  state.selectedId = a.id; updateSelectedPanel();
  openIASPicker(spdEl, a);
});

// M
const machEl = act('mach'); blockMMB(machEl);
withMMB(machEl, ()=>{
  state.selectedId = a.id; updateSelectedPanel();
  openMachPicker(machEl, a);
});

const vsEl = act('vs'); blockMMB(vsEl);
withMMB(vsEl, ()=>{
  state.selectedId = a.id; updateSelectedPanel();
  openVsPicker(vsEl, a);
});

// CFL: MMB opens scrollable level picker
const cflEl = act('cfl');
blockMMB(cflEl);
withMMB(cflEl, ()=>{
  const curFL = Math.round(a.tgtAlt/100);
  openLevelPicker(cflEl, curFL, (flSel)=>{
    a.setAltitude(flSel*100, null);       // keeps your ≥FL250 climb cap
    state.selectedId = a.id;
    updateSelectedPanel(); drawAll();
  });
});


// XFL: MMB opens scrollable level picker
const xflEl = act('xfl');
blockMMB(xflEl);
withMMB(xflEl, ()=>{
  const curFL = a.xfl_ft ? Math.round(a.xfl_ft/100) : 0;
  openLevelPicker(xflEl, curFL, (flSel)=>{
    a.xfl_ft = flSel*100;
    layoutTags(); drawCanvasOnly();
  });
});



// WPT picker (MMB) — only remaining FPL fixes; selecting short-cuts the route
const wptEl = act('wpt'); blockMMB(wptEl);
withMMB(wptEl, ()=>{
  const list = routeRemainingFixes(a);
  if (!list.length){
    alert("No remaining fixes in the flight plan.");
    return;
  }
  openWptPicker(wptEl, a);
});




      tag.style.left=(x+a.labelDx)+'px'; tag.style.top=(y+a.labelDy)+'px';
    }
    

    // Remove tags for AC that no longer exist
    for(const [id,el] of tagMap.entries()){
      if(!presentIds.has(Number(id))){ el.remove(); tagMap.delete(id); }
    }
  }

  function drawScope(){
  ctx.save();
  ctx.setTransform(1,0,0,1,0,0);
  ctx.globalAlpha = 1;

  // clean background
  ctx.fillStyle = "#060707";
  ctx.fillRect(0,0,W,H);
  
  drawTMAs();
  
  

  // sector polygon outline (no rings/grid/airways)
  ctx.strokeStyle = "#3a3a3a";
  ctx.lineWidth = 1.6;
  ctx.setLineDash([6,6]);
  ctx.beginPath();
  for (let i=0;i<SECTOR_POLY.length;i++){
    const [xn,yn] = SECTOR_POLY[i];
    const x = cx + nmToPx(xn), y = cy + nmToPx(yn);
    if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.closePath();
  ctx.stroke();
  ctx.setLineDash([]);
  ctx.restore();
}



  function formatAltitude(ft){ return ft>=18000?("FL"+String(Math.round(ft/100)).padStart(3,'0')):((ft|0)+" ft"); }
  function inFilter(ft){ return ft>=state.filterMin && ft<=state.filterMax; }

  function drawPredictLines(ac){
  const wants=[ state.pred1?60:0, state.pred3?180:0, state.pred5?300:0 ].filter(Boolean);
  if(!wants.length) return;
  if(!Number.isFinite(ac.x_nm) || !Number.isFinite(ac.y_nm) || !Number.isFinite(ac.hdg) || !Number.isFinite(ac.spd_kt)) return;

  const x0=cx+nmToPx(ac.x_nm), y0=cy+nmToPx(ac.y_nm);
  ctx.lineWidth=1.5; ctx.setLineDash([]); ctx.strokeStyle = "#ffffff";
  for(const t of wants){
    const dist_nm=ac.spd_kt*nmPerKtPerSec*t;
    if(!Number.isFinite(dist_nm)) continue;
    const x=x0+nmToPx(Math.sin(toRad(ac.hdg))*dist_nm);
    const y=y0+nmToPx(-Math.cos(toRad(ac.hdg))*dist_nm);
    ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x,y); ctx.stroke();
  }
}


  


  



  function drawConflicts(){
    for(const [aId,bId] of state.conflictsPred){
      const a=state.ac.find(x=>x.id===aId), b=state.ac.find(x=>x.id===bId); if(!a||!b) continue;
      ctx.strokeStyle="#ffcc66"; ctx.lineWidth=1.5; ctx.setLineDash([4,6]);
      ctx.beginPath(); ctx.moveTo(cx+nmToPx(a.x_nm), cy+nmToPx(a.y_nm)); ctx.lineTo(cx+nmToPx(b.x_nm), cy+nmToPx(b.y_nm)); ctx.stroke();
    }
    for(const [aId,bId] of state.conflictsNow){
      const a=state.ac.find(x=>x.id===aId), b=state.ac.find(x=>x.id===bId); if(!a||!b) continue;
      ctx.strokeStyle="#ff6a6a"; ctx.lineWidth=2.2; ctx.setLineDash([]);
      ctx.beginPath(); ctx.moveTo(cx+nmToPx(a.x_nm), cy+nmToPx(a.y_nm)); ctx.lineTo(cx+nmToPx(b.x_nm), cy+nmToPx(b.y_nm)); ctx.stroke();
    }
    ctx.setLineDash([]);
  }

// --- Measuring (refactored) ---
// Measures now support endpoints that can be either:
//  - {type:'ac', id:<trackId>}  -> follows that aircraft live
//  - {x_nm:<num>, y_nm:<num>}   -> fixed point in space
// Backward compatibility: we still render old {fromX_nm, toX_nm, ...} shapes.

function drawMeasureSegment(m){
  ctx.save();

  // Resolve endpoints (support both new and legacy shapes)
  const p1 = m.from ? resolveEndpoint(m.from) : {x_nm:m.fromX_nm, y_nm:m.fromY_nm};
  const p2 = m.to   ? resolveEndpoint(m.to)   : {x_nm:m.toX_nm,   y_nm:m.toY_nm};
  if(!p1 || !p2){ ctx.restore(); return; }

  const x1 = cx + nmToPx(p1.x_nm), y1 = cy + nmToPx(p1.y_nm);
  const x2 = cx + nmToPx(p2.x_nm), y2 = cy + nmToPx(p2.y_nm);

  // line
  ctx.strokeStyle="#9ad6ff";
  ctx.lineWidth=1.8;
  ctx.setLineDash([8,6]);
  ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  ctx.setLineDash([]);

  // endpoints
  ctx.fillStyle="#e6f0f7";
  ctx.beginPath(); ctx.arc(x1,y1,3,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x2,y2,3,0,Math.PI*2); ctx.fill();

  // label text (no box): place slightly "above" the segment midpoint
  const dnm = Math.hypot(p2.x_nm-p1.x_nm, p2.y_nm-p1.y_nm);
  const brg = bearingFromTo(p1.x_nm,p1.y_nm,p2.x_nm,p2.y_nm);
  const text = `${dnm.toFixed(1)} NM • HDG ${formatHeading(brg)}`;

  const midx = (x1+x2)/2, midy = (y1+y2)/2;
  // screen-space normal (perpendicular) for offset
  const nx = (y2 - y1), ny = -(x2 - x1);
  const nlen = Math.hypot(nx, ny) || 1;
  const off = 14; // how far above the line (px)
  const tx = midx + (nx / nlen) * off;
  const ty = midy + (ny / nlen) * off;

  // halo + fill for readability
  ctx.font = "12px ui-monospace";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.lineWidth = 4;
  ctx.strokeStyle = "rgba(7,16,24,0.9)"; // dark halo
  ctx.strokeText(text, tx, ty);
  ctx.fillStyle = "#cfe8f7";
  ctx.fillText(text, tx, ty);

  ctx.restore();
}


function drawActiveMeasure(){
  if(!state.measure) return;
  ctx.save();
  ctx.globalAlpha = 1;      // don’t inherit any dimming
  ctx.setLineDash([]);      // don’t inherit dashes
  drawMeasureSegment(state.measure);
  ctx.restore();
}
function drawRulers(){
  ctx.save();
  ctx.globalAlpha = 1;
  ctx.setLineDash([]);
  for(const m of state.measures) drawMeasureSegment(m);
  ctx.restore();
}

// ===== Bright-green route preview =========================================
function drawRoutePreview(){
  const id = state.routePreviewId;
  if (id == null) return;

  const a = state.ac.find(t => t.id === id);
  if (!a || !a.route.length) return;

  ctx.save();
  ctx.strokeStyle = "#00ff6b";   // neon green
  ctx.lineWidth   = 2.4;
  ctx.setLineDash([3,6]);        // dashed; delete line for solid

  // start at the aircraft's current position
  let px = cx + nmToPx(a.x_nm);
  let py = cy + nmToPx(a.y_nm);

  for (let i = Math.max(a.routeIdx, 0); i < a.route.length; i++){
    const w = env.getWaypoint(a.route[i]);
    if (!w) continue;
    const wx = cx + nmToPx(w.x_nm);
    const wy = cy + nmToPx(w.y_nm);

    ctx.beginPath();
    ctx.moveTo(px, py);
    ctx.lineTo(wx, wy);
    ctx.stroke();

    px = wx; py = wy;   // next leg starts here
  }
  ctx.restore();
}


// NEW: Shift+Left click handler — snaps to aircraft (live) or uses free point.
function handleMeasureSmartClick(xPx, yPx){
  const ac = findNearestAcPx(xPx, yPx, 16);
  const ep = ac ? { type:'ac', id: ac.id }
                : pxToNm(xPx, yPx); // {x_nm, y_nm}

  if(!state.measure){
    // Start: from = ep, to = cursor (temporary same ep)
    state.measure = { from: ep, to: ep };
  }else{
    // Finish: set 'to' endpoint and commit
    state.measure.to = ep;
    state.measures.push({ ...state.measure }); // store by reference
    state.measure = null;
  }
  drawAll();
}



  function drawCanvasBase(){
  drawScope();
  detectConflicts();

  for(const a of state.ac){
    if (!Number.isFinite(a.x_nm) || !Number.isFinite(a.y_nm) ||
        !Number.isFinite(a.hdg)  || !Number.isFinite(a.spd_kt)) {
      continue; // skip broken track this frame
    }
    const selected = a.id===state.selectedId;
    const dim = !inFilter(a.alt_ft); ctx.globalAlpha = dim?0.35:1.0;

    // dotted trail
    ctx.fillStyle = "#ffffff";
    for(const p of a.trail){
      if(!Number.isFinite(p.x) || !Number.isFinite(p.y)) continue;
      const tx = cx+nmToPx(p.x), ty = cy+nmToPx(p.y);
      ctx.beginPath(); ctx.arc(tx,ty,2.4,0,Math.PI*2); ctx.fill();
    }

    // vectors
    const showPred = state.predFor==="all" || (state.predFor==="sel" && selected);
    if(showPred) drawPredictLines(a);

    // symbol
    const x = cx + nmToPx(a.x_nm), y = cy + nmToPx(a.y_nm);
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    const s = 5;
    ctx.moveTo(x, y - s);
    ctx.lineTo(x + s, y);
    ctx.lineTo(x, y + s);
    ctx.lineTo(x - s, y);
    ctx.closePath(); ctx.fill();
  }

  drawConflicts();
  ctx.globalAlpha=1.0;
}


  function drawLeaders(){
    for(const a of state.ac){
      const dotX=cx+nmToPx(a.x_nm), dotY=cy+nmToPx(a.y_nm);
      const tag = tagMap.get(a.id); if(!tag) continue;
      const rect = tag.getBoundingClientRect(), wrapRect = wrap.getBoundingClientRect();
      const left = rect.left - wrapRect.left, top = rect.top - wrapRect.top;
      const right = left + rect.width, bottom = top + rect.height;
      const ex = clamp(dotX, left, right), ey = clamp(dotY, top, bottom);
      ctx.strokeStyle = "#ffffff";

      ctx.beginPath(); ctx.moveTo(dotX, dotY); ctx.lineTo(ex, ey); ctx.stroke();
    }
  }

  function drawCanvasOnly(){ // fast path during drags
    drawCanvasBase();
    drawLeaders();
    drawRoutePreview();
    drawRulers();     // NEW: draw committed rulers
    drawActiveMeasure();
  }

  function drawAll(){
  drawCanvasBase();
  layoutWptLabels();
  layoutTags();
  drawLeaders();
  drawRoutePreview();   // ← only ONE call here
  drawRulers();
  drawActiveMeasure();
}


// ---------- Simulation (3s refresh) ----------
function stepOnce(){
  if(state.paused){ 
    drawCanvasOnly(); 
    return; 
  }

  // advance sim clock
  simNowSec += state.refreshSec * state.simSpeed;
  const dt = state.refreshSec * state.simSpeed;

  // move all aircraft
  for(const a of state.ac) a.update(dt, env);
  // Seen-once bookkeeping (viewport-based)
for (const a of state.ac) {
  if (acInScopeNm(a, 0)) a.seenOnScreenOnce = true;
}

const now = simNowSec;
state.ac = state.ac.filter(a => {
  // Primary rules
  if (a.finishedAtSec != null && (now - a.finishedAtSec) >= DESPAWN_AFTER_LASTFIX_SEC) return false;
  if (a.role === 'arrival' && a.alt_ft <= DESPAWN_FL0_FT) return false;

  // Safety: if truly never seen, give them a long leash
  if (!a.seenOnScreenOnce) return (now - a.spawnSec) < NEVER_SEEN_MAX_SEC;

  return true;
});

// Clear selection if culled
if (state.selectedId && !state.ac.some(x => x.id === state.selectedId)) {
  state.selectedId = null;
}



// auto-spawn (cooldown)
if (AutoSpawn.enabled && Number.isFinite(AutoSpawn.cooldownSec)) {
  AutoSpawn.cooldownSec -= dt;        // dt = state.refreshSec * state.simSpeed
  if (AutoSpawn.cooldownSec <= 0) {
    if (Math.random() < AutoSpawn.conflictChance) {
  spawnConflictPack(true);   // routed conflicts for autos
} else {
  spawnPlannedAircraft();    // routed singles for autos
}

    armCooldown();                    // reset for next randomized gap
  }
}


  drawAll();
}
let timer = setInterval(stepOnce, 3000);


  // ---------- UI ----------
  const altInput=document.getElementById('alt'); const useFL=document.getElementById('useFL'); const altHint=document.getElementById('altModeHint');
  function updateAltPlaceholder(){
    if(useFL.checked){ altInput.placeholder="e.g. 150 (FL150)"; altHint.textContent="Input interpreted as Flight Level (hundreds of feet)"; }
    else{ altInput.placeholder="e.g. 15000 (ft)"; altHint.textContent="Input interpreted as feet (type FL120 to use FL)"; }
  }
  useFL.addEventListener('change', ()=>{
    const a=getSelected();
    if(a){ altInput.value = useFL.checked ? Math.round(a.tgtAlt/100) : Math.round(a.tgtAlt); }
    updateAltPlaceholder();
  });
  updateAltPlaceholder();

  // Canvas interactions
  canvas.addEventListener('click', e=>{
    if(state.addingWpt){
      const rect=canvas.getBoundingClientRect();
      const xPx=e.clientX-rect.left, yPx=e.clientY-rect.top;
      const {x_nm,y_nm}=pxToNm(xPx,yPx);
      addWaypointAt(x_nm,y_nm); state.addingWpt=false;
      document.getElementById('addWpt').textContent="Add waypoint"; return;
    }
    state.selectedId=null; updateSelectedPanel(); layoutTags(); drawCanvasOnly();
  });

// Measuring: Shift+MMB start/update, RMB now DROPS (commits) instead of clearing.
//           NEW: Shift+Left Click = start/finish with snapping
canvas.addEventListener('pointerdown', e=>{
  const rect = canvas.getBoundingClientRect();
  const xPx = e.clientX - rect.left, yPx = e.clientY - rect.top;

  // Start panning with RMB, or with LMB while RMB is held (no Shift)
  const wantsPan = (e.button === 2) || (e.button === 0 && (e.buttons & 2));
  if (!e.shiftKey && wantsPan){
    isPanning = true;
    panStartClient.x = e.clientX; panStartClient.y = e.clientY;
    panStartPx.x = PAN.x; panStartPx.y = PAN.y;
    try{ canvas.setPointerCapture(e.pointerId); }catch{}
    e.preventDefault();
    return;
  }

  // Shift + Left Click = smart start/finish (snaps to aircraft if close)
  if (e.shiftKey && e.button === 0) {
    try{ canvas.setPointerCapture(e.pointerId); }catch{}
    handleMeasureSmartClick(xPx, yPx);
    e.preventDefault();
    return;
  }

  // Plain Left Click = if already measuring, drop/commit immediately
  if (!e.shiftKey && e.button === 0 && state.measure) {
    state.measures.push({ ...state.measure });
    state.measure = null;
    drawAll();
    e.preventDefault();
    return;
  }
});



canvas.addEventListener('pointermove', e=>{
  // Panning
  if (isPanning){
    const dx = e.clientX - panStartClient.x;
    const dy = e.clientY - panStartClient.y;
    PAN.x = panStartPx.x + dx;
    PAN.y = panStartPx.y + dy;
    // Recompute center and redraw
    cx = W/2 + CENTER_SHIFT.x + PAN.x;
    cy = H/2 + CENTER_SHIFT.y + PAN.y;
    drawAll();
    e.preventDefault();
    return;
  }

  // Measuring preview follows cursor (works over labels thanks to capture)
  if(!state.measure) return;
  const rect=canvas.getBoundingClientRect();
  const xPx=e.clientX-rect.left, yPx=e.clientY-rect.top;

  // If 'to' is aircraft-linked, don't override it.
  if(state.measure.to && state.measure.to.type === 'ac') return;

  const {x_nm,y_nm}=pxToNm(xPx,yPx);
  if(!state.measure.from && 'fromX_nm' in state.measure){
    state.measure = { from:{x_nm:state.measure.fromX_nm, y_nm:state.measure.fromY_nm},
                      to:{x_nm, y_nm} };
  }else{
    state.measure.to = {x_nm, y_nm};
  }
  drawCanvasOnly();
});



canvas.addEventListener('pointerup', e=>{
  if (isPanning) isPanning = false;
  try { canvas.releasePointerCapture(e.pointerId); } catch {}
});


canvas.addEventListener('pointercancel', e=>{
  isPanning = false;
  try { canvas.releasePointerCapture(e.pointerId); } catch {}
});

// Allow context menu unless we just handled a commit above
// Suppress browser menu while panning or if a ruler is active
// Always suppress right-click menu on the radar canvas
canvas.addEventListener('contextmenu', e=>{
  e.preventDefault();
});
// Also suppress right-click menu on the wrapper (edges around the canvas)
wrap.addEventListener('contextmenu', e=>{
  e.preventDefault();
});




  function flashSelected(){ const card=document.getElementById('selectedInfo'); card.classList.add('selected'); setTimeout(()=>card.classList.remove('selected'), 450); }

  function updateSelectedPanel(){
    const el=document.getElementById('selectedInfo'); const a=getSelected();
    if(!a){ state.editing = null; el.className='aircraftCard small'; el.innerHTML='Tap/click a tag to select; drag tags anywhere (works on mobile).'; return; }
    el.className='aircraftCard selected';
    const route = a.navMode==="DIRECT"&&a.directWptId ? ` • DIR ${env.getWaypoint(a.directWptId)?.name||""}` : "";
    el.innerHTML = `
  <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
    <div><strong>${a.cs}</strong> — H${formatHeading(a.hdg)} • S${a.spd_kt|0} kt/M${a.mach.toFixed(2)} • ${formatAltitude(a.alt_ft)}${route}</div>
    <button class="btnSfp small" style="white-space:nowrap;">SFP</button>
  </div>
  <div class="small">Targets: H${formatHeading(a.tgtHdg)} • ${
  a.tgtSpeedMode==='MACH'
  ? ('M'+(a.tgtMach?.toFixed(2) ?? (a.spd_kt/isaSpeedOfSoundKts(a.alt_ft)).toFixed(2)))
  : ('S'+(Math.round(a.tgtIAS_kt))+' kt')

} • ALT ${formatAltitude(a.tgtAlt)} • VS${fmtVS100(a.vs_fpm)} • SEC ${a.inSector?'IN':'OUT'}

`;
const sfpBtn = el.querySelector('.btnSfp');
if(sfpBtn){
  sfpBtn.addEventListener('click', ()=>{
    openSFP(a);
  });
  // If SFP window is open, refresh it for the new selection (or close if none)
const openWin = document.querySelector('.sfpWin');
if(openWin){
  const sel = getSelected();
  if(sel) renderSFP(sel); else closeSFP();
}

}

    altInput.value = useFL.checked ? Math.round(a.tgtAlt/100) : Math.round(a.tgtAlt);
    document.getElementById('hdg').value = Math.round(a.tgtHdg)||0;
    document.getElementById('spd').value = a.tgtSpeedMode==='KT' ? a.tgtSpd_kt|0 : "";
    document.getElementById('mach').value = a.tgtSpeedMode==='MACH'&&a.tgtMach ? a.tgtMach.toFixed(2) : "";
    document.getElementById('vs').value = a.vs_fpm ? (Math.abs(a.vs_fpm)|0) : "";
  }

  document.getElementById('spawn').addEventListener('click', spawnPlannedAircraft);
  document.getElementById('autoSpawnToggle').addEventListener('change', e=>{
  AutoSpawn.enabled = e.target.checked;
  if (AutoSpawn.enabled){
    armCooldown();      // start a fresh randomized gap
  } else {
    disarmCooldown();   // stop any pending spawn
  }
});


document.getElementById('spawnConflict').addEventListener('click', ()=>{
  spawnConflictPack();
});

  document.getElementById('clear').addEventListener('click', clearAll);
  document.getElementById('pause').addEventListener('click', e=>{
    state.paused=!state.paused; e.target.textContent=state.paused?"Resume":"Pause";
  });
  document.getElementById('rangeSel').addEventListener('change', e=>{ rangeNM=parseInt(e.target.value,10); drawAll(); });
  document.getElementById('simSpeed').addEventListener('change', e=>{ state.simSpeed=parseFloat(e.target.value); });
  document.getElementById('labelSize').addEventListener('change', e=>{
  document.body.classList.remove('label-sm','label-lg'); // medium = default (no class)
  if (e.target.value==='sm') document.body.classList.add('label-sm');
  else if (e.target.value==='lg') document.body.classList.add('label-lg');
});

// 20…800 inclusive, every 20 NM
const RANGE_STEPS = Array.from({ length: 40 }, (_, i) => 20 * (i + 1));


function isEditingUI(ev){
  if (state.editing) return true;
  const ae = document.activeElement;
  if (ae && (ae.tagName === 'INPUT' || ae.tagName === 'SELECT' || ae.tagName === 'TEXTAREA' || ae.isContentEditable)) return true;
  const picker = window._levelPicker?.el;
  if (picker && picker.contains(ev.target)) return true;
  return false;
}

function rebuildRangeSelect(){
  const sel = document.getElementById('rangeSel');
  if (!sel) return;
  sel.innerHTML = RANGE_STEPS
    .map(n => `<option${n===rangeNM ? ' selected' : ''}>${n}</option>`)
    .join('');
}

function setRangeNM(newNm){
  rangeNM = newNm;
  rebuildRangeSelect(); // keep the dropdown in sync even for 100/140/etc
  drawAll();
}


// Scroll only on the radar area; up = zoom in, down = zoom out
wrap.addEventListener('wheel', (e)=>{
  if (isEditingUI(e)) return;          // don’t steal scroll while editing
  const dir = e.deltaY < 0 ? -1 : 1;   // wheel up/down
  const idx = RANGE_STEPS.indexOf(rangeNM);
  if (idx === -1) return;
  const next = clamp(idx + dir, 0, RANGE_STEPS.length - 1);
  if (next !== idx){
    setRangeNM(RANGE_STEPS[next]);
    e.preventDefault();                // allow smooth zoom without page scroll
  }
}, { passive: false });


  for(const id of ["pred1","pred3","pred5"]) document.getElementById(id).addEventListener('change', e=>{ state[id]=e.target.checked; drawAll(); });
  document.getElementById('predFor').addEventListener('change', e=>{ state.predFor=e.target.value; drawAll(); });

  document.getElementById('lookahead').addEventListener('change', e=>{ state.lookaheadMin=parseInt(e.target.value,10); drawAll(); });

  document.getElementById('btnFilter').addEventListener('click', ()=>{
    state.filterMin=parseInt(document.getElementById('fltMin').value,10)||0;
    state.filterMax=parseInt(document.getElementById('fltMax').value,10)||60000;
    drawAll();
  });



  document.getElementById('addWpt').addEventListener('click', ()=>{
  alert("Dynamic waypoints are disabled in this version.");
});
document.getElementById('clearWpt').addEventListener('click', ()=>{
  alert("Dynamic waypoints are disabled in this version.");
});


  document.getElementById('autoHandoff').addEventListener('change', e=>{ env.autoHandoff=e.target.checked; });
  document.getElementById('btnHandoff').addEventListener('click', ()=>{
  const a = getSelected(); 
  if(!a){ alert("Select a track first."); return; }

  // Manual toggle of transfer of control (independent of geometry)
  a.handedOff = !a.handedOff;
  if (a.handedOff) a.hoArmed = false; // disarm when completed

  layoutTags();
  updateSelectedPanel(); 
  drawAll();
});

  document.getElementById('btnRect').addEventListener('click', ()=>{
    env.rectW=Math.max(5,parseFloat(document.getElementById('rectW').value)||env.rectW);
    env.rectH=Math.max(5,parseFloat(document.getElementById('rectH').value)||env.rectH);
    drawAll();
  });

  // NEW: Measure tool UI button
  document.getElementById('clearRulers').addEventListener('click', ()=>{ state.measures.length=0; drawAll(); });

  // Commands
  document.getElementById('btnHdg').addEventListener('click', ()=>{
    const a=getSelected(); if(!a) return;
    let hdg=parseInt(document.getElementById('hdg').value,10);
    if(!Number.isFinite(hdg)) return;
    if(hdg===360) hdg=0;
    a.setHeading(mod360(hdg));
    updateSelectedPanel(); drawAll();
  });

  document.getElementById('btnAlt').addEventListener('click', ()=>{
  const a=getSelected(); if(!a) return;
  const altFt = parseAltitudeInput(document.getElementById('alt').value, useFL.checked);
  const vs = parseVsHundreds(document.getElementById('vs').value);
  if(altFt!=null) a.setAltitude(altFt, vs);
  document.getElementById('vs').value = "";
  updateSelectedPanel(); drawAll();
});



  document.getElementById('btnHold').addEventListener('click', ()=>{ const a=getSelected(); if(!a) return; a.holdAltitude(); updateSelectedPanel(); drawAll(); });
  document.getElementById('btnSpd').addEventListener('click', ()=>{
    const a=getSelected(); if(!a) return; const spd=parseInt(document.getElementById('spd').value,10);
    if(Number.isFinite(spd)) a.setSpeedKt(spd); updateSelectedPanel(); drawAll();
  });
  document.getElementById('btnMach').addEventListener('click', ()=>{
    const a=getSelected(); if(!a) return; const m=parseFloat(document.getElementById('mach').value);
    if(Number.isFinite(m)) a.setMach(m); updateSelectedPanel(); drawAll();
  });
// --- Enter-to-confirm + highlight which field is being edited ---
function bindEnterAndHighlight(inputId, btnId, labelField){
  const inp = document.getElementById(inputId);
  if (!inp) return;
  inp.addEventListener('keydown', e=>{
    if(e.key === 'Enter'){
      const btn = document.getElementById(btnId);
      if (btn) btn.click();
      inp.blur();
    }
  });
  inp.addEventListener('focus', ()=> setEditing(labelField));
  inp.addEventListener('blur',  ()=> clearEditing(labelField));
}

// Map inputs → buttons → which label span to highlight
bindEnterAndHighlight('hdg',  'btnHdg',  'hdg');
bindEnterAndHighlight('spd',  'btnSpd',  'spd');
bindEnterAndHighlight('mach', 'btnMach', 'mach');
bindEnterAndHighlight('alt',  'btnAlt',  'cfl'); // editing ALT highlights CFL
bindEnterAndHighlight('vs',   'btnAlt',  'vs');  // VS shares the ALT apply


  // Shortcuts
  window.addEventListener('keydown', e=>{
    if (e.key === 'Escape') {
      if (state.measure) { state.measure = null; drawCanvasOnly(); return; }
      if (state.measures.length) { state.measures.pop(); drawAll(); return; }
    }
    const a=getSelected();
    if(e.code==='Space'){ e.preventDefault(); state.paused=!state.paused; document.getElementById('pause').textContent=state.paused?"Resume":"Pause"; }
    else if(e.key==='N'||e.key==='n'){ spawnAircraft(); }
    else if(a){
      if(e.key==='H'||e.key==='h'){
        const v=prompt("Vector: heading (1–360)", Math.min(360,Math.max(1, Math.round(a.tgtHdg)||1)));
        if(v!==null){ let h=parseInt(v,10); if(h===360) h=0; if(Number.isFinite(h)) a.setHeading(mod360(h)); updateSelectedPanel(); drawAll(); }
      }else if(e.key==='A'||e.key==='a'){
  const hint = useFL.checked ? "FL (e.g. 120), optional VS×100 like 120,18" : "ft (e.g. 12000), optional VS×100 like 12000,18";
  const v=prompt("Altitude — "+hint, useFL.checked? String(Math.round(a.tgtAlt/100)) : String(Math.round(a.tgtAlt)));
  if(v!==null){
    const parts=v.toUpperCase().split(',');
    const altFt = parseAltitudeInput(parts[0], useFL.checked);
    const vs = parts[1]? parseVsHundreds(parts[1]) : null;
    if(altFt!=null) a.setAltitude(altFt, vs);
    updateSelectedPanel(); drawAll();
  }

      }else if(e.key==='S'||e.key==='s'){
        const v=prompt("Speed (kt)", a.tgtSpeedMode==='KT'?(a.tgtSpd_kt|0):"");
        if(v!==null && v.trim()!==""){ a.setSpeedKt(parseInt(v,10)); updateSelectedPanel(); drawAll(); }
      }else if(e.key==='M'||e.key==='m'){
        const v=prompt("Mach (e.g. 0.78)", a.tgtSpeedMode==='MACH'&&a.tgtMach?a.tgtMach.toFixed(2):"");
        if(v!==null && v.trim()!==""){ a.setMach(parseFloat(v)); updateSelectedPanel(); drawAll(); }
      }
    }
  });

window.addEventListener('load', () => {
  resize();
  renderWptList();
  // NEW: sync the actual range to the selected option (160 by default)
  rangeNM = parseInt(document.getElementById('rangeSel').value, 10) || 120;
    rebuildRangeSelect();


  spawnPlannedAircraft();
  spawnPlannedAircraft();
  booted = true;
  drawAll();
});


</script>
</body>
</html>
