<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>ATC Radar Trainer — v6.2.1</title>
<style>
  :root{
  /* Near-black scope */
  --bg:#060707;
  --grid:#0c0c0c;         /* very faint grid (optional) */
  --ring:#141414;         /* very faint rings (optional) */

  /* UI text + panel remain readable */
  --text:#e8eef2;
  --accent:#8fd3ff;
  --panel:#0d1115;

  /* not used for labels anymore, but keep */
  --tag:#0d2230; --tagBorder:#1b3a4f;
  --sel:#9bf6a9; --warn:#ffcc66; --alert:#ff6a6a;
  --muted:#9fb3c1; --magenta:#ff7bff;

  /* leader/rect colors no longer blue; vectors & leaders will be white in JS */
  --leader:#ffffff; --rect:#3a3a3a;
}
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:var(--bg); color:var(--text);
    font:15px/1.35 ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Courier New",monospace;
    display:grid; grid-template-columns:1fr 380px; grid-template-rows:56px 1fr;
    grid-template-areas:"top top" "radar panel";
    overflow:hidden auto;
  }
  header{grid-area:top; display:flex; align-items:center; gap:12px;
    padding:10px 14px; background:linear-gradient(180deg,#0d1921,#0a1117);
    border-bottom:1px solid #162737}
  header h1{margin:0; font-size:16px; font-weight:600; letter-spacing:.5px; color:var(--accent)}
  header .controls{display:flex; gap:8px; flex-wrap:wrap; margin-left:auto}
  button,input,select{background:#0d1a22; border:1px solid #1b3243; color:var(--text); padding:8px 10px; border-radius:8px; outline:none}
  button:hover{border-color:#24516e; cursor:pointer}
  input[type="number"],input[type="text"]{width:110px}
  #radarWrap{grid-area:radar; position:relative}
  canvas{display:block; width:100%; height:100%}
  aside{grid-area:panel; border-left:1px solid #162737; background:var(--panel); padding:12px; overflow:auto}
  .section{margin-bottom:14px; padding-bottom:12px; border-bottom:1px dashed #173243}
  .row{display:flex; gap:8px; align-items:center; margin:6px 0; flex-wrap:wrap}
  label{font-size:12px; color:var(--muted); min-width:86px}
  .small{font-size:12px; color:var(--muted)}
  .aircraftCard{border:1px solid #193246; background:#0b1620; border-radius:10px; padding:10px; margin:8px 0}
  .aircraftCard.selected{border-color:var(--sel)}
  .grid2{display:grid; grid-template-columns:1fr 1fr; gap:8px}
  .kbd{padding:2px 6px; border:1px solid #274b64; border-radius:6px; background:#0c1b25}

/* ===== Track labels (text only; no box) ===== */
.tag{
  position:absolute;
  background:transparent;        /* no box */
  border:none;                   /* no border */
  padding:0;                     /* tight */
  filter:none;
  touch-action:none; user-select:none; cursor:grab;
  opacity:1;                     /* solid text */
}
.tag:hover,.tag.dragging{opacity:1}

/* simple type ramp */
.tag .l1{ font-weight:700; font-size:14px; line-height:1.05 }
.tag .l2{ font-size:12px; line-height:1.05; letter-spacing:.2px }
/* label size presets */
body.label-sm .tag .l1{ font-size:12px }
body.label-sm .tag .l2{ font-size:10px }
body.label-lg .tag .l1{ font-size:16px }
body.label-lg .tag .l2{ font-size:14px }


/* state-driven colors */
.tag.st-controlled { color:#69ff8a; }     /* green */
.tag.st-inbound    { color:#ffffff; }     /* white */
.tag.st-intruder   { color:#ffd9b3; }     /* very light orange */
.tag.st-outbound   { color:#9aa3aa; }     /* greyed out */
/* highlight the field currently being edited */
.tag [data-act].editing{
  outline:1px dashed currentColor;
  outline-offset:2px;
  border-radius:4px;
  padding:0 2px;
}


/* tiny inline button to mark handoff (optional) */
.tag .ho{
  display:inline-block; margin-left:8px; padding:1px 6px;
  font-size:10px; border:1px solid currentColor; border-radius:999px;
}
  .tag:hover,.tag.dragging{opacity:1}
  .tag .line1{font-weight:600}
  .tag .line2{font-size:12px; color:var(--muted)}
  .tag.alert{border-color:var(--alert)}
  .tag.warn{border-color:var(--warn)}
  .pill{padding:2px 6px; border:1px solid #2c4a5f; border-radius:999px; background:#0c1b25; font-size:11px; color:var(--muted)}
  .waypointLabel{position:absolute; background:transparent; border:0px solid #2c4a5f; border-radius:6px; padding:0px 6px; font-size:11px; color:#cde; opacity:.85}
  /* --- SFP floating window --- */
.sfpWin{
  position:absolute; right:12px; top:64px; width:260px;
  background:#0b1620; border:1px solid #1b3a4f; border-radius:10px;
  box-shadow:0 6px 18px rgba(0,0,0,.35); z-index:20; user-select:auto;
}
.sfpWin .hdr{ cursor:grab; }
.sfpWin.is-dragging .hdr{ cursor:grabbing; }

.sfpWin .hdr{
  display:flex; align-items:center; justify-content:space-between;
  padding:8px 10px; border-bottom:1px solid #173243; color:#9fb3c1; font-size:12px;
  background:linear-gradient(180deg,#0e1820,#0b141a);
  border-top-left-radius:10px; border-top-right-radius:10px;
}
.sfpWin .hdr .title{ font-weight:600; color:#cfe8f7; font-size:12px; letter-spacing:.3px }
.sfpWin .hdr button{
  background:#0d1a22; border:1px solid #274b64; color:#cfe8f7; padding:4px 8px; border-radius:6px; cursor:pointer;
}
.sfpWin .body{ padding:10px }
.sfpWin table{ width:100%; border-collapse:collapse; font-size:12px; color:#cfe8f7 }
.sfpWin td{ padding:4px 0; vertical-align:top }
.sfpWin td.key{ color:#9fb3c1; width:88px }
.sfpWin .route{ margin-top:8px; font-size:12px; color:#9ad6ff; line-height:1.35 }

</style>
</head>
<body>
<header>
  <h1>ATC Radar Trainer — v6.2.1</h1>
  <div class="controls">
    <button id="spawn">Spawn traffic</button>
    <label class="small">
  <input id="autoSpawnToggle" type="checkbox"> Auto-spawn
</label>
<button id="spawnConflict">Spawn conflict</button>

    <button id="clear">Clear all</button>
    <button id="pause">Pause</button>
    <label class="small">Range (NM)
      <select id="rangeSel"><option>20</option><option >40</option><option>60</option><option selected>80</option><option>120</option></select>
    </label>
    <label class="small">Sim speed
      <select id="simSpeed"><option value="0.5">0.5×</option><option value="1" selected>1×</option><option value="2">2×</option><option value="4">4×</option></select>
    </label>
    <label class="small">Labels
  <select id="labelSize">
    <option value="sm">Small</option>
    <option value="md" selected>Medium</option>
    <option value="lg">Large</option>
  </select>
</label>

  </div>
</header>

<div id="radarWrap">
  <canvas id="radar"></canvas>
</div>

<aside>
  <div class="section">
    <div class="row"><strong>Selected track</strong></div>
    <div id="selectedInfo" class="aircraftCard small">Tap/click a tag to select; drag tags anywhere (works on mobile).</div>
  </div>

  <div class="section">
    <div class="row"><strong>Vectors</strong></div>
    <div class="row">
      <label for="hdg">Heading</label>
      <input id="hdg" type="number" min="1" max="360" placeholder="1–360">
      <button id="btnHdg">Issue vector</button>
    </div>
    <div class="row small">Standard-rate ≈3°/s, shortest way. (Displays 360, not 000.)</div>
  </div>

  <div class="section">
    <div class="row"><strong>Altitude</strong></div>
    <div class="row">
      <label for="alt">Altitude</label>
      <input id="alt" type="number" step="1" min="0" placeholder="e.g. 150">
      <button id="btnAlt">Climb/Descent</button>
    </div>
    <div class="row">
      <label for="vs">Vertical speed</label>
      <input id="vs" type="number" step="100" placeholder="×100 fpm (default 18)">
      <button id="btnHold">Altitude hold</button>
    </div>
    <div class="row small">
      <label><input id="useFL" type="checkbox" checked> Enter Flight Level (e.g., <b>150</b> for FL150)</label>
      <span id="altModeHint" class="small"></span>
    </div>
  </div>

  <div class="section">
    <div class="row"><strong>Speed</strong></div>
    <div class="row">
      <label for="spd">Speed (kt)</label>
      <input id="spd" type="number" step="5" min="60" placeholder="e.g. 250">
      <button id="btnSpd">Set kt</button>
    </div>
    <div class="row">
      <label for="mach">Mach</label>
      <input id="mach" type="number" step="0.01" min="0.30" max="0.99" placeholder="e.g. 0.78">
      <button id="btnMach">Set M</button>
    </div>
    <div class="row small">Mach converts using ISA a(alt).</div>
  </div>

  <div class="section">
    <div class="row"><strong>Predict vectors</strong></div>
    <div class="row small">
      <label><input type="checkbox" id="pred1" checked> 1 min</label>
      <label><input type="checkbox" id="pred3" checked> 3 min</label>
      <label><input type="checkbox" id="pred5" checked> 5 min</label>
      <label style="margin-left:auto;">Show for
        <select id="predFor"><option value="sel">selected</option><option value="all" selected>all tracks</option></select>
      </label>
    </div>
    <div class="row small">Solid lines only; no labels on scope.</div>
  </div>

  <div class="section">
    <div class="row"><strong>Conflict alerts</strong></div>
    <div class="row small">Minima: <span class="pill">5 NM</span> / <span class="pill">1000 ft</span></div>
    <div class="row">
      <label for="lookahead">Lookahead</label>
      <select id="lookahead"><option value="0">0 min (current)</option><option value="1">1 min</option><option value="2" selected>2 min</option><option value="3">3 min</option></select>
    </div>
    <div class="row small">Red = actual, Amber = predicted within lookahead.</div>
  </div>

  <!-- NEW: Measure tool controls -->
  <div class="section">
    <div class="row"><strong>Measure tool</strong></div>
    <div class="row">
      <button id="clearRulers">Clear rulers</button>
    </div>
    <div class="row small">Shift+LMB = start/finish (snaps to nearest a/c) •
Plain Left Click = place ruler •
Esc = delete last ruler</div>
  </div>

  <div class="section">
    <div class="row"><strong>Altitude filter</strong></div>
    <div class="row">
      <label for="fltMin">Min (ft)</label><input id="fltMin" type="number" step="100" value="0">
      <label for="fltMax">Max (ft)</label><input id="fltMax" type="number" step="100" value="60000">
      <button id="btnFilter">Apply</button>
    </div>
    <div class="row small">Off-band tracks dimmed.</div>
  </div>

  <div class="section">
    <div class="row"><strong>Speed restrictions</strong></div>
    <div class="row small">
      <label><input id="spd250" type="checkbox" checked> 250 kt at/under 10,000 ft</label>
    </div>
  </div>

  <div class="section">
    <div class="row"><strong>Waypoints & Direct-to</strong></div>
    <div class="row">
      <button id="addWpt">Add waypoint</button>
      <button id="clearWpt">Clear wpts</button>
    </div>
    <div id="wptList" class="small"></div>
  </div>

  <div class="section">
    <div class="row"><strong>Sector (rectangular)</strong></div>
    <div class="row small">Rect centered on scope. Handoff triggers when crossing the rectangle boundary.</div>
    <div class="row">
      <label for="rectW">Width (NM)</label><input id="rectW" type="number" value="160">
      <label for="rectH">Height (NM)</label><input id="rectH" type="number" value="120">
      <button id="btnRect">Apply</button>
    </div>
    <div class="row small">
      <label><input id="autoHandoff" type="checkbox" checked> Auto-handoff</label>
      <button id="btnHandoff">Handoff selected</button>
    </div>
  </div>

  <div class="section small">
    <div class="row"><strong>Shortcuts</strong></div>
    <div class="grid2">
      <div><span class="kbd">H</span> vector • <span class="kbd">A</span> altitude • <span class="kbd">S</span> speed • <span class="kbd">M</span> Mach</div>
      <div><span class="kbd">Space</span> pause • <span class="kbd">N</span> spawn • Click scope to add waypoint (when enabled)</div>
    </div>
  </div>
</aside>

<script>
  // ---------- Utilities ----------
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const toRad=d=>d*Math.PI/180; const toDeg=r=>r*180/Math.PI;
  const mod360=d=>(d%360+360)%360;
  const nmPerKtPerSec = 1/3600; const ftPerMinToFtPerSec = 1/60;
  // --- fix pass logic (buffer + trend) ---
const FIX_PASS_NM = 1.2;       // consider a fix 'made' when within this many NM
const FIX_PASS_TREND_NM = 2.0; // or, if we've been closer than this and range starts increasing, also 'made'


  function isaSpeedOfSoundKts(alt_ft){
    const h = Math.max(0, Math.min(86000, alt_ft)) * 0.3048;
    let T; if(h<=11000) T=288.15-0.0065*h; else if(h<=20000) T=216.65; else T=216.65+0.001*(h-20000);
    const a_ms = Math.sqrt(1.4*287.05287*T); return a_ms*1.943844;
  }
  function formatHeading(h){
    let n = Math.round(mod360(h));
    n = n===0 ? 360 : n;
    return String(n).padStart(3,'0');
  }
  function parseAltitudeInput(val, useFL){
    if(val===""||val==null) return null;
    let txt = String(val).trim().toUpperCase();
    if(useFL){
      if(txt.startsWith("FL")) txt = txt.slice(2);
      const fl = parseInt(txt,10);
      if(Number.isFinite(fl)) return fl*100;
      return null;
    }else{
      if(txt.startsWith("FL")){
        const fl=parseInt(txt.slice(2),10); return Number.isFinite(fl)? fl*100:null;
      }
      const ft = parseInt(txt,10); return Number.isFinite(ft)? ft:null;
    }
  }
  function bearingFromTo(x1,y1,x2,y2){
    return mod360(toDeg(Math.atan2(x2-x1, -(y2-y1))));
  }
  // === closest static waypoint to a raw x_nm / y_nm ===
function nearestStaticFixId(x_nm, y_nm){
  let bestId = null, bestD = Infinity;
  for(const w of WP_ALL){
    const d = Math.hypot(w.x_nm - x_nm, w.y_nm - y_nm);
    if(d < bestD){ bestD = d; bestId = w.id; }
  }
  return bestId;
}
// signed angle (deg) between two vectors originating at the *same* point
function turnAngleDeg(ax, ay, bx, by){
  const dot  = ax*bx + ay*by;
  const det  = ax*by - ay*bx;          // cross-product z-component
  const ang  = Math.atan2(det, dot);   // −π … +π
  return Math.abs(ang * 180 / Math.PI);
}


  function nextWptName(a, env){
  if(a.navMode==="DIRECT" && a.directWptId) return env.getWaypoint(a.directWptId)?.name || "—";
  if(a.navMode==="ROUTE" && a.routeIdx < a.route.length) return env.getWaypoint(a.route[a.routeIdx])?.name || "—";
  return "—";
}
function fmtFLshort(ft){ return 'FL' + String(Math.round(ft/100)).padStart(3,'0'); }
function fmtCFL(ft){ return 'CFL' + String(Math.round(ft/100)).padStart(3,'0'); }
function fmtVS100(vs_fpm){
  const h = Math.round(vs_fpm/100);
  if (h===0) return "0";
  return (h>0?"+":"−") + Math.abs(h);
}
function parseVsHundreds(txt){
  if (txt==null) return null;
  const n = parseInt(String(txt).trim(),10);
  return Number.isFinite(n) ? n*100 : null;  // “18” -> 1800 fpm
}

function getTrackState(a){
  if (a.inSector){
    return a.hoMarked ? "intruder" : "controlled";
  } else {
    return a.everInRect ? "outbound" : "inbound";
  }
}

  // --- Short Flight Plan (SFP) & helpers ---
const DEP_PORTS = ["EPWA","EPKT","EPPO"];   // tweak later
const ARR_PORTS = ["EDDF","EPWR","EPLL"];   // tweak later
const TYPES     = ["A320","B738","E190","B744","B789"];

const rand = (a,b)=> a + Math.random()*(b-a);
const randi = (a,b)=> Math.floor(rand(a,b+1));
const pick = arr => arr[Math.floor(Math.random()*arr.length)];

function makeSFP({dep=null, dest=null, cruiseFL=360, tasKt=450, type=null}={}){
  return {
    dep:  dep  ?? pick(DEP_PORTS),
    dest: dest ?? pick(ARR_PORTS),
    cruiseFL, tasKt, type: type ?? pick(TYPES)
  };
}
// Pick a dynamic waypoint that sits closest to the great-circle* line
// between two static fixes (entry → exit).  If no dynamic WPTs exist
// fall back to a random inner dynamic fix (or null if none).
// Return a dynamic fix that sits *near* the line Entry–Exit and
// produces a turn ≤ maxTurnDeg at that fix.  If none fits, return null.
function pickGentleMidFix(entryId, exitId, maxOffNm = 100, maxTurnDeg = 115){
  if (!wpts.length) return null;
  const A = getWPById(entryId), B = getWPById(exitId);
  if (!A || !B) return null;

  const dxAB = B.x_nm - A.x_nm, dyAB = B.y_nm - A.y_nm;
  const len2 = dxAB*dxAB + dyAB*dyAB;
  if (len2 < 1e-6) return null;

  let best = null, bestScore = Infinity;

  // allow a little beyond the segment so near-corner fixes still count
  const tMin = -0.12, tMax = 1.12;

  for (const w of wpts){
    const t = ((w.x_nm - A.x_nm)*dxAB + (w.y_nm - A.y_nm)*dyAB) / len2;
    if (t < tMin || t > tMax) continue;

    const px = A.x_nm + t*dxAB, py = A.y_nm + t*dyAB;
    const off = Math.hypot(px - w.x_nm, py - w.y_nm);
    if (off > maxOffNm) continue;

    const inX =  w.x_nm - A.x_nm, inY =  w.y_nm - A.y_nm;
    const outX = B.x_nm - w.x_nm, outY = B.y_nm - w.y_nm;
    const turn = turnAngleDeg(inX, inY, outX, outY);
    if (!Number.isFinite(turn) || turn > maxTurnDeg) continue;

    // slight bias toward central fixes so we don't hug the rim too much
    const center = Math.hypot(w.x_nm, w.y_nm);

    // you had: turn*1.0 + off*0.15 — keep that vibe but make it a bit more generous
    const score = turn*1.0 + off*0.2 + center*0.04;

    if (score < bestScore){ bestScore = score; best = w.id; }
  }
  return best;
}

function forceMidBetween(entryId, exitId){
  // Try the gentle picker first
  let mid = pickGentleMidFix(entryId, exitId, 40, 50);
  if (mid) return mid;

  // Fallback 1: closest-to-segment dynamic waypoint (keeps it reasonable)
  const A = getWPById(entryId), B = getWPById(exitId);
  if (A && B && wpts.length){
    const dx = B.x_nm - A.x_nm, dy = B.y_nm - A.y_nm, len2 = dx*dx + dy*dy;
    if (len2 > 1e-6){
      let best=null, bestOff=Infinity;
      for (const w of wpts){
        const t = ((w.x_nm - A.x_nm)*dx + (w.y_nm - A.y_nm)*dy) / len2;
        if (t <= 0 || t >= 1) continue; // avoid extremes
        const px = A.x_nm + t*dx, py = A.y_nm + t*dy;
        const off = Math.hypot(w.x_nm - px, w.y_nm - py);
        if (off < bestOff){ bestOff = off; best = w.id; }
      }
      if (best != null) return best;
    }
  }
  // Return up to `want` mids that keep every leg ≤ maxTurn / maxOff
function pickMidFixes(entryId, exitId, want = 2,
                       maxOffNm = GENTLE.maxOffNm,
                       maxTurnDeg = GENTLE.maxTurnDeg)
{
  if (!wpts.length || want < 1) return [];

  const A = getWPById(entryId), B = getWPById(exitId);
  if (!A || !B) return [];

  // Score every dynamic fix just like before
  const cand = [];
  for (const w of wpts){
    // project W onto AB
    const dxAB = B.x_nm - A.x_nm, dyAB = B.y_nm - A.y_nm;
    const len2 = dxAB*dxAB + dyAB*dyAB;
    const t = ((w.x_nm-A.x_nm)*dxAB + (w.y_nm-A.y_nm)*dyAB)/len2;
    if (t < -0.12 || t > 1.12) continue;

    const px = A.x_nm + t*dxAB, py = A.y_nm + t*dyAB;
    const off = Math.hypot(w.x_nm-px, w.y_nm-py);
    if (off > maxOffNm) continue;

    // turn angle if this becomes the only mid
    const inX = w.x_nm-A.x_nm,  inY = w.y_nm-A.y_nm;
    const outX= B.x_nm-w.x_nm, outY = B.y_nm-w.y_nm;
    const ang = turnAngleDeg(inX,inY,outX,outY);
    if (ang > maxTurnDeg) continue;

    const center = Math.hypot(w.x_nm, w.y_nm);
    const score  = ang*1.0 + off*0.2 + center*0.04;
    cand.push({ id:w.id, score, t });
  }
  cand.sort((p,q)=>p.score-q.score);

  // Take up to `want` mids, spread roughly along the route
  const mids = [];
  for (const c of cand){
    if (mids.length >= want) break;
    // keep some spacing: ±0.2 of route length
    if (mids.some(m => Math.abs(m.t - c.t) < 0.12)) continue;
    mids.push(c);
  }
  return mids.map(m=>m.id);
}

  
  function nearestRingTo(x_nm, y_nm){
  let bestId = null, bestD = Infinity;
  for (const fid of STATIC_RING_FIXES){
    const w = getWPById(fid);
    const d = Math.hypot(w.x_nm - x_nm, w.y_nm - y_nm);
    if (d < bestD){ bestD = d; bestId = fid; }
  }
  return bestId;
}

// Build with the *final* entry chosen from spawn coords
function buildTransitRouteFromSpawn(spawnX, spawnY, fp){
  const entry = randomEdge(null);
  const exit  = randomEdge(entry);
  const mids  = pickMidFixes(entry, exit, 2);   // ← new
  const legs  = [entry, ...mids, exit];         // ← new
  return enforceRingEnds(legs);
}

function buildArrivalRouteFromSpawn(spawnX, spawnY, fp){
  const entry = nearestRingTo(spawnX, spawnY);
  const mid   = forceMidBetween(entry, WP.CTR.id);
  const legs  = mid ? [entry, mid, WP.CTR.id] : [entry, WP.CTR.id];
  return enforceRingEnds(legs);
}

// Departure starts at CTR, exit is opposite-ish; spawnX/Y don’t matter here
function buildDepartureRoute(fp){
  const exit = randomEdge(null);
  const mid  = forceMidBetween(WP.CTR.id, exit);
  const legs = mid ? [WP.CTR.id, mid, exit] : [WP.CTR.id, exit];
  return enforceRingEnds(legs);
}


  // Fallback 2: nearest-to-center dynamic waypoint
  if (wpts.length){
    return wpts.reduce((b,w)=>{
      const d = Math.hypot(w.x_nm,w.y_nm);
      return d < b.d ? {id:w.id,d} : b;
    }, {id:null,d:Infinity}).id;
  }
  return null;
}


const GENTLE = { maxOffNm: 100, maxTurnDeg: 115 };  // was 25/45

function sanitizeMidpoints(route, limits = GENTLE){
  if (!Array.isArray(route) || route.length < 3) return route;
  const { maxOffNm, maxTurnDeg } = limits;

  const out = [route[0]];
  for (let i = 1; i < route.length - 1; i++){
    const prevId = out[out.length - 1];
    const curId  = route[i];
    const nextId = route[i+1];

    const prev = getWPById(prevId), cur = getWPById(curId), next = getWPById(nextId);
    if (!prev || !cur || !next) continue;

    // ignore interior ring fixes entirely (we strip them anyway)
    if (isRing(curId)) continue;

    // turn at 'cur'
    const inX  = cur.x_nm - prev.x_nm, inY  = cur.y_nm - prev.y_nm;
    const outX = next.x_nm - cur.x_nm, outY = next.y_nm - cur.y_nm;
    const turn = turnAngleDeg(inX, inY, outX, outY);

    // perpendicular offset from Prev–Next line
    const dx = next.x_nm - prev.x_nm, dy = next.y_nm - prev.y_nm;
    const len2 = dx*dx + dy*dy;
    let off = Infinity;
    if (len2 > 1e-6){
      const t  = ((cur.x_nm - prev.x_nm)*dx + (cur.y_nm - prev.y_nm)*dy) / len2;
      const px = prev.x_nm + t*dx, py = prev.y_nm + t*dy;
      off = Math.hypot(cur.x_nm - px, cur.y_nm - py);
    }

    if (Number.isFinite(turn) && Number.isFinite(off) &&
        turn <= maxTurnDeg && off <= maxOffNm){
      out.push(curId);
    } // else: drop this mid, it's too sharp or too far off-line
  }
  out.push(route[route.length-1]);
  return out;
}


function buildTransitRoute(fp){
  const entry = randomEdge(null);
  const exit  = randomEdge(entry);
  const mid   = forceMidBetween(entry, exit);
  const legs  = mid ? [entry, mid, exit] : [entry, exit];
  return enforceRingEnds(legs);
}

function buildArrivalRoute(fp){
  const entry = randomEdge(null);
  const mid   = forceMidBetween(entry, WP.CTR.id);
  const legs  = mid ? [entry, mid, WP.CTR.id] : [entry, WP.CTR.id];
  return enforceRingEnds(legs);
}

function buildDepartureRoute(fp){
  const exit = randomEdge(null);
  const mid  = forceMidBetween(WP.CTR.id, exit);
  const legs = mid ? [WP.CTR.id, mid, exit] : [WP.CTR.id, exit];
  return enforceRingEnds(legs);
}






 function findNearestAcPx(xPx, yPx, tolPx=16){
  let best=null, bestD=Infinity;
  for(const a of state.ac){
    const ax = cx + nmToPx(a.x_nm);
    const ay = cy + nmToPx(a.y_nm);
    const d = Math.hypot(ax - xPx, ay - yPx);
    if(d < bestD){ bestD = d; best = a; }
  }
  return bestD <= tolPx ? best : null;
}

function resolveEndpoint(ep){
  if(!ep) return null;
  if(ep.type === 'ac'){
    const ac = state.ac.find(a=>a.id===ep.id);
    if(!ac) return null; // a/c may have been cleared
    return { x_nm: ac.x_nm, y_nm: ac.y_nm };
  }
  // point endpoint
  if('x_nm' in ep && 'y_nm' in ep) return { x_nm: ep.x_nm, y_nm: ep.y_nm };
  return null;
}


  // ---------- Aircraft ----------
  let nextId=1;
  function genCallsign(){
    const ops=["LOT","DLH","BAW","RYR","WZZ","KLM","AFR","AUA","SAS","UAE","QTR","IBE"];
    return ops[Math.floor(Math.random()*ops.length)]+String(Math.floor(100+Math.random()*899));
  }

  class Aircraft{
    constructor(opts){
      this.id=nextId++; this.cs=opts.cs||genCallsign();
      this.x_nm=opts.x_nm??0; this.y_nm=opts.y_nm??0;
      this.hdg=opts.hdg??Math.floor(Math.random()*360);
      this.alt_ft=opts.alt_ft??(30000);
      this.spd_kt=opts.spd_kt??(this.alt_ft>24000?450:250);
      this.fp = opts.fp ?? null;   // Short Flight Plan (dep, dest, cruiseFL, tasKt, type)
      this.type = opts.type ?? pick(TYPES);   // <-- new: default a random type
      this.route = [];         // array of waypoint ids
      this.routeIdx = 0;       // current active leg target index



      // Dotted trail: last 5 positions max
      this.trail=[]; this.trailMax=5;

      // Targets
      this.tgtHdg=this.hdg; this.tgtAlt=this.alt_ft;
      this.vs_fpm=0; this.defaultVS=1800;
      this.tgtSpeedMode="KT"; this.tgtSpd_kt=this.spd_kt; this.tgtMach=null;

      // Dynamics
      this.turnRateDps=3; this.accel_ktps=1.0; this.maxVS_fps=4000*ftPerMinToFtPerSec;

      // Nav
      this.navMode=null; this.directWptId=null;
          this.route = [];        // array of waypoint ids
    this.routeIdx = 0;      // which fix we’re heading to now
    // pass logic helpers
this.prevDistToTarget = null; // last range to active fix
this.lastNavTargetId   = null; // which fix that range belonged to



      // Label offsets
      this.labelDx=12; this.labelDy=-16;
      // Visibility/despawn bookkeeping
this.seenOnScreenOnce = false;
this.spawnSec = (typeof simNowSec !== 'undefined') ? simNowSec : 0;


      // Rect sector state
      this.inSector = true; this.handoffPending=false; this.pendingState=null; 
      // coloring / state bookkeeping
this.everInRect = env.inRect(this.x_nm, this.y_nm); // ever been inside?
this.hoMarked   = false;                             // we marked H/O manually

    }
    setHeading(h){ this.navMode=null; this.directWptId=null; this.tgtHdg=mod360(h); }
    setAltitude(alt_ft,vs=null){ this.tgtAlt=Math.max(0,Math.round(alt_ft));
      const sign=this.tgtAlt>this.alt_ft?1:-1; const mag=Math.max(0,Math.abs(vs??this.defaultVS)); this.vs_fpm=sign*mag; }
    holdAltitude(){ this.tgtAlt=this.alt_ft; this.vs_fpm=0; }
    setSpeedKt(kt){ this.tgtSpeedMode="KT"; this.tgtSpd_kt=Math.max(60,kt|0); this.tgtMach=null; }
    setMach(m){ this.tgtSpeedMode="MACH"; this.tgtMach=clamp(m,0.3,0.99); }
    directTo(id){ this.navMode="DIRECT"; this.directWptId=id; }
    get mach(){ return this.spd_kt/isaSpeedOfSoundKts(this.alt_ft); }
      setRoute(ids){
    this.route = Array.isArray(ids) ? ids.slice() : [];
    this.routeIdx = 0;
    this.navMode = this.route.length ? "ROUTE" : null;
    this.directWptId = null; // clear direct if switching
  }


    update(dt, env){
      if(this.tgtSpeedMode==="MACH" && this.tgtMach) this.tgtSpd_kt=this.tgtMach*isaSpeedOfSoundKts(this.alt_ft);
      let targetSpd=this.tgtSpd_kt;
      if(env.restrict250 && this.alt_ft<=10000) targetSpd=Math.min(targetSpd,250);

      // --- DIRECT-to nav ---
if (this.navMode==="DIRECT" && this.directWptId!=null){
  const w = env.getWaypoint(this.directWptId);
  if (w){
    const hdgTo = mod360(toDeg(Math.atan2(w.x_nm-this.x_nm, -(w.y_nm-this.y_nm))));
    this.tgtHdg = hdgTo;
    const dist = Math.hypot(w.x_nm-this.x_nm, w.y_nm-this.y_nm);

    // trend detection (reset if target changes)
    if (this.lastNavTargetId !== this.directWptId) this.prevDistToTarget = null;

    const passed =
      dist < FIX_PASS_NM ||
      (this.prevDistToTarget != null &&
       this.prevDistToTarget < FIX_PASS_TREND_NM &&
       dist > this.prevDistToTarget);

    if (passed){
      // Try to rejoin FPL after this fix
      const idxInRoute = Array.isArray(this.route) ? this.route.indexOf(this.directWptId) : -1;
      this.directWptId = null;

      if (idxInRoute >= 0 && idxInRoute + 1 < this.route.length){
        this.routeIdx = idxInRoute + 1;
        this.navMode = "ROUTE";
      } else {
        // No FPL/no next fix → continue present heading
        this.navMode = null;
        this.tgtHdg = this.hdg;
      }
      this.prevDistToTarget = null;
      this.lastNavTargetId  = null;
    } else {
      this.lastNavTargetId  = this.directWptId;
      this.prevDistToTarget = dist;
    }
  } else {
    // waypoint missing → cancel DIR and hold current
    this.directWptId = null;
    this.navMode = null;
    this.tgtHdg = this.hdg;
    this.prevDistToTarget = null;
    this.lastNavTargetId = null;
  }
}

// --- ROUTE nav: fly fix-to-fix, same pass logic ---
if (this.navMode==="ROUTE" && this.routeIdx < this.route.length){
  const targetId = this.route[this.routeIdx];
  const w = env.getWaypoint(targetId);
  if (w){
    const hdgTo = mod360(toDeg(Math.atan2(w.x_nm-this.x_nm, -(w.y_nm-this.y_nm))));
    this.tgtHdg = hdgTo;
    const dist = Math.hypot(w.x_nm-this.x_nm, w.y_nm-this.y_nm);

    if (this.lastNavTargetId !== targetId) this.prevDistToTarget = null;

    const passed =
      dist < FIX_PASS_NM ||
      (this.prevDistToTarget != null &&
       this.prevDistToTarget < FIX_PASS_TREND_NM &&
       dist > this.prevDistToTarget);

    if (passed){
      this.routeIdx++;
      this.prevDistToTarget = null;
      this.lastNavTargetId  = null;

      if (this.routeIdx >= this.route.length){
        this.navMode = null;   // route complete → continue present heading
        this.tgtHdg = this.hdg;
      }
    } else {
      this.lastNavTargetId  = targetId;
      this.prevDistToTarget = dist;
    }
  } else {
    // target vanished → drop to present heading
    this.navMode = null;
    this.tgtHdg = this.hdg;
    this.prevDistToTarget = null;
    this.lastNavTargetId = null;
  }
}



      let diff = mod360(this.tgtHdg-this.hdg); if(diff>180) diff-=360;
      const maxTurn=this.turnRateDps*dt; if(Math.abs(diff)<maxTurn) this.hdg=this.tgtHdg; else this.hdg=mod360(this.hdg+Math.sign(diff)*maxTurn);

      const dSpd=targetSpd-this.spd_kt; const maxAcc=this.accel_ktps*dt;
      if(Math.abs(dSpd)<maxAcc) this.spd_kt=targetSpd; else this.spd_kt+=Math.sign(dSpd)*maxAcc;

      if(this.alt_ft!==this.tgtAlt){
        let vs_fps=this.vs_fpm*ftPerMinToFtPerSec; const delta=this.tgtAlt-this.alt_ft;
        if(Math.abs(delta)<600){ const s=Math.sign(delta); vs_fps=s*Math.min(Math.abs(vs_fps),800*ftPerMinToFtPerSec); }
        vs_fps=clamp(vs_fps,-this.maxVS_fps,this.maxVS_fps);
        const step=vs_fps*dt;
        if(Math.sign(delta)!==Math.sign(step)||Math.abs(step)>Math.abs(delta)){ this.alt_ft=this.tgtAlt; this.vs_fpm=0; }
        else this.alt_ft+=step;
      }

      const dist_nm=this.spd_kt*nmPerKtPerSec*dt;
      this.x_nm += Math.sin(toRad(this.hdg))*dist_nm;
      this.y_nm += -Math.cos(toRad(this.hdg))*dist_nm;

      // Sector (rectangle)
const inside = env.inRect(this.x_nm, this.y_nm);
if (inside) this.everInRect = true;

if (inside !== this.inSector) {
  const leftSector = this.inSector && !inside; // just crossed OUT
  if (env.autoHandoff) {
    this.inSector = inside;
    this.handoffPending = false;
    this.pendingState = null;
  } else {
    this.handoffPending = true;
    this.pendingState = inside;
  }
  if (leftSector) {
    // leaving sector: stop any nav guidance and keep current track
    this.navMode = null;
    this.directWptId = null;
    this.tgtHdg = this.hdg; // hold present heading
  }
}

      // Dotted trail (every step call adds one); keep only last 5
      this.trail.push({x:this.x_nm,y:this.y_nm});
      if(this.trail.length>this.trailMax) this.trail.shift();
    }
  }

 // ---------- World / Sim ----------
const canvas=document.getElementById('radar'); const ctx=canvas.getContext('2d');
const wrap=document.getElementById('radarWrap');
let W=0,H=0,cx=0,cy=0;
let booted = false;

function resize(){
  const r=wrap.getBoundingClientRect();
  canvas.width=r.width; canvas.height=r.height;
  W=canvas.width; H=canvas.height; cx=W/2; cy=H/2;
  if (booted) drawAll(); // only redraw after full boot
}
window.addEventListener('resize', resize);

  let rangeNM=80; function nmToPx(nm){ return nm*(Math.min(W,H)/2)/rangeNM; }
  function pxToNm(xPx,yPx){ return { x_nm:(xPx-cx)*rangeNM/(Math.min(W,H)/2), y_nm:(yPx-cy)*rangeNM/(Math.min(W,H)/2) }; }
  function isOnScreenPx(x_px, y_px, marginPx=24){
  return x_px >= -marginPx && x_px <= W + marginPx &&
         y_px >= -marginPx && y_px <= H + marginPx;
}
function acIsOnScreen(a, marginPx=24){
  const x = cx + nmToPx(a.x_nm);
  const y = cy + nmToPx(a.y_nm);
  return isOnScreenPx(x, y, marginPx);
}

function acInScopeNm(a, marginNm=0){
  // inside the circular scope radius + margin
  return Math.hypot(a.x_nm, a.y_nm) <= (rangeNM + marginNm);
}



  const env = {
    restrict250:true, autoHandoff:true,
    rectW:160, rectH:120,
    getWaypoint: id => getWPById(id),
    inRect: (x_nm,y_nm)=>Math.abs(x_nm)<=env.rectW/2 && Math.abs(y_nm)<=env.rectH/2
  };

  const state = {
    ac:[], selectedId:null, paused:false,
    simSpeed:1,
    filterMin:0, filterMax:60000,
    pred1:true, pred3:true, pred5:true, predFor:"all",
    lookaheadMin:2,
    conflictsNow:[], conflictsPred:[],
    addingWpt:false,
    refreshSec:3,
    measure:null,        // active ruler being drawn {fromX_nm,fromY_nm,toX_nm,toY_nm}
    measures:[],          // committed rulers
    editing:null,          // {id, field} e.g. {id: 3, field:'hdg'|'spd'|'mach'|'vs'|'cfl'}
    routePreviewId : null,    // ⇐ NEW – id of a/c to highlight
    

  };
  function getSelected(){ return state.ac.find(a=>a.id===state.selectedId)||null; }
  // --- Sim clock (seconds) ---
let simNowSec = 0;


  // Waypoints
  let wptNext=1; const wpts=[];
  // ---- Random waypoint naming + min-spacing placement ----
const WPT_MIN_SPACING_NM = 15;     // tweak to taste
const WPT_TRIES_PER_POINT = 350;  // how hard we try per waypoint

function randWptName(){
  const vowels = "AEIOU";
  const cons   = "BCDFGHJKLMNPQRSTVWXYZ";
  // Make it feel "airway-ish": CVCVC or CVCCV with a dash of weirdness
  const pat = Math.random() < 0.5 ? "CVCVC" : "CVCCV";
  const pick = (s)=> s[Math.floor(Math.random()*s.length)];
  let out = "";
  for (const c of pat){
    out += (c==="C") ? pick(cons) : pick(vowels);
  }
  // ~15% chance to flip one letter to make it quirky
  if (Math.random() < 0.15){
    const i = Math.floor(Math.random()*out.length);
    const pool = Math.random()<0.5?vowels:cons;
    out = out.slice(0,i) + pick(pool) + out.slice(i+1);
  }
  return out;
}

function addWaypointNamedAt(name, x_nm, y_nm){
  const id = wptNext++;
  const w = { id, name, x_nm, y_nm };
  wpts.push(w);
  return w;
}

/** Place N random waypoints inside the current rectangular sector
 *  with at least WPT_MIN_SPACING_NM separation.
 */
function seedRandomWaypoints(count){
  const halfW = env.rectW/2, halfH = env.rectH/2;
  for (let k=0; k<count; k++){
    let placed = false;
    let tries = 0;
    let spacing = WPT_MIN_SPACING_NM;

    while(!placed && tries < WPT_TRIES_PER_POINT){
      tries++;
      const x = (Math.random()*2 - 1) * (halfW * 0.95);
      const y = (Math.random()*2 - 1) * (halfH * 0.95);

      // inside rect (belt-and-suspenders)
      if (!env.inRect(x,y)) continue;

      // distance check vs all existing waypoints
      let ok = true;
      for (const w of wpts){
        const d = Math.hypot(x - w.x_nm, y - w.y_nm);
        if (d < spacing){ ok = false; break; }
      }
      if (!ok) {
        // After many misses, ease spacing a bit so we don’t stall
        if (tries % 50 === 0) spacing *= 0.9;
        continue;
      }

      addWaypointNamedAt(randWptName(), x, y);
      placed = true;
    }
  }
  renderWptList();
  drawAll();
}

  function addWaypointAt(x_nm,y_nm){ const id=wptNext++; const w={id,name:"WPT"+id,x_nm,y_nm}; wpts.push(w); renderWptList(); drawAll(); }
  function clearWaypoints(){ wpts.length=0; renderWptList(); drawAll(); }
  function renderWptList(){
    const box=document.getElementById('wptList');
    if(wpts.length===0){ box.innerHTML='<div class="small">No waypoints.</div>'; return; }
    box.innerHTML=wpts.map(w=>`
      <div style="display:flex;align-items:center;gap:8px;margin:4px 0;">
        <span class="pill">${w.name}</span>
        <button data-w="${w.id}" class="btnDirect small">Direct-to</button>
      </div>`).join("");
    for(const btn of box.querySelectorAll('.btnDirect')){
      btn.addEventListener('click', e=>{
        const id=parseInt(e.target.getAttribute('data-w'),10);
        const sel=getSelected(); if(!sel){ alert("Select a track first."); return; }
        sel.directTo(id); updateSelectedPanel(); drawAll();
      });
    }
  }
  function fmtFL(flFt){ return 'FL' + String(Math.round(flFt/100)).padStart(3,'0'); }
function fmtTas(kt){ return (kt|0) + " kt"; }

function ensureSfpWin(){
  let el = document.querySelector('.sfpWin');
  if(el) return el;

  el = document.createElement('div');
  el.className = 'sfpWin';
  el.innerHTML = `
    <div class="hdr">
      <div class="title">Short Flight Plan</div>
      <div><button class="btnSfpClose">Close</button></div>
    </div>
    <div class="body"></div>
  `;
  document.getElementById('radarWrap').appendChild(el);
  const closeBtn = el.querySelector('.btnSfpClose');
closeBtn.addEventListener('pointerdown', e=>{ e.stopPropagation(); });
closeBtn.addEventListener('click', closeSFP);


  // Dragging by header — LEFT BUTTON ONLY; capture on the SAME node we listen on
  const hdr = el.querySelector('.hdr');
  let dragging=false, sx=0, sy=0, startLeft=0, startTop=0;

  function endDrag(ev){
    if(!dragging) return;
    dragging=false;
    el.classList.remove('is-dragging');
    try{ hdr.releasePointerCapture(ev.pointerId);}catch{}
  }

  hdr.addEventListener('pointerdown', ev=>{
    if (ev.button !== 0) return;                 // left button only
    if (ev.target.closest('button')) return;
    dragging = true;
    hdr.setPointerCapture(ev.pointerId);         // <-- capture on hdr (not el)
    const r  = el.getBoundingClientRect();
    const wr = document.getElementById('radarWrap').getBoundingClientRect();
    startLeft = r.left - wr.left;
    startTop  = r.top  - wr.top;
    sx = ev.clientX; sy = ev.clientY;
    el.classList.add('is-dragging');
    ev.preventDefault();
    ev.stopPropagation();
  });

  hdr.addEventListener('pointermove', ev=>{
    if(!dragging) return;
    // If LMB is no longer down (missed pointerup), drop the drag.
    if ((ev.buttons & 1) === 0) { endDrag(ev); return; }
    const dx = ev.clientX - sx, dy = ev.clientY - sy;
    el.style.left = (startLeft + dx) + 'px';
    el.style.top  = (startTop  + dy) + 'px';
    el.style.right = 'auto';
  });

  hdr.addEventListener('pointerup', endDrag);
  hdr.addEventListener('pointercancel', endDrag);
  hdr.addEventListener('lostpointercapture', ()=>{ dragging=false; el.classList.remove('is-dragging'); });

  return el;
}




function renderSFP(ac){
  const el = ensureSfpWin();
  const body = el.querySelector('.body');
  if(!ac || !ac.fp){
    body.innerHTML = `<div class="small" style="color:#9fb3c1">No SFP for this aircraft.</div>`;
    return;
  }
  const fp = ac.fp;
  const routeNames = (ac.route||[]).map(id => (env.getWaypoint(id)?.name || String(id)));
  body.innerHTML = `
    <table>
      <tr><td class="key">Callsign</td><td>${ac.cs}</td></tr>
      <tr><td class="key">Type</td><td>${fp.type || ac.type || '—'}</td></tr>
      <tr><td class="key">From</td><td>${fp.dep || '—'}</td></tr>
      <tr><td class="key">To</td><td>${fp.dest || '—'}</td></tr>
      <tr><td class="key">Cruise</td><td>${fmtFL(fp.cruiseFL*100)}</td></tr>
      <tr><td class="key">TAS</td><td>${fmtTas(fp.tasKt||ac.spd_kt)}</td></tr>
    </table>
    <div class="route"><span style="color:#9fb3c1">Route:</span> ${
      routeNames.length ? routeNames.join(' → ') : '—'
    }</div>
  `;
  // keep it on-screen if window is small
  const r = el.getBoundingClientRect(), wrapR = document.getElementById('radarWrap').getBoundingClientRect();
  if(r.right > wrapR.right) el.style.right = '12px';
  if(r.top < wrapR.top) el.style.top = '64px';
}

function openSFP(ac){ renderSFP(ac); }
function closeSFP(){
  const el = document.querySelector('.sfpWin');
  if(el) el.remove();
}

  
  // ===== Random waypoints inside sector + faint airways =====
let airways = []; // pairs of waypoint ids to draw lines between

const FUN_FIXES = [
  "YEETR","BORKD","LOLNO","NOMMY","PIZZA","SAUCE","ZAPPY","FIZZY","BANJO","NINJA",
  "TANGO","NACHO","BAGEL","WAFFL","DONUT","BINGO","CHILL","HAPPY","GRUMP","ZORRO",
  "BEEFY","NOODS","SPICY","MUNCH","CRONK","GOOFY","SNEKD","WHAAA","YUMMY","BUBBL"
];
const VOWELS = ["A","E","I","O","U","Y"];
const CONS   = ["B","C","D","F","G","H","J","K","L","M","N","P","Q","R","S","T","V","W","X","Z"];
const usedFixNames = new Set();

function genFunnyFixName(){
  // prefer from list without reusing
  const candidates = FUN_FIXES.filter(n => !usedFixNames.has(n));
  if (candidates.length){
    const n = candidates[Math.floor(Math.random()*candidates.length)];
    usedFixNames.add(n);
    return n;
  }
  // fallback: make something pronounceable(ish) CCVCV
  const pick = arr => arr[Math.floor(Math.random()*arr.length)];
  const name = (pick(CONS)+pick(CONS)+pick(VOWELS)+pick(CONS)+pick(VOWELS)).toUpperCase();
  usedFixNames.add(name);
  return name;
}

// Seed N random waypoints inside current rectangular sector
function seedWaypointsInside(count=16, minSepNm=5){
  const halfW = env.rectW/2, halfH = env.rectH/2;
  const margin = 4; // keep a little away from the edge

  function tooClose(x_nm,y_nm){
    return wpts.some(w => Math.hypot(w.x_nm - x_nm, w.y_nm - y_nm) < minSepNm);
  }

  for(let i=0;i<count;i++){
    let tries=0, x=0, y=0;
    do{
      x = (Math.random()*2-1) * (halfW - margin);
      y = (Math.random()*2-1) * (halfH - margin);
      tries++;
    } while(tries<40 && tooClose(x,y));

    const id = wptNext++;
    const w = { id, name: genFunnyFixName(), x_nm:x, y_nm:y };
    wpts.push(w);
  }
  renderWptList();
}

// Build “airways” by connecting each waypoint to its k nearest neighbors
function buildAirways(k=2){
  const pts = [...WP_ALL, ...wpts];
  const uniq = new Set(); // "min-max" id keys
  for(const a of pts){
    const dists = [];
    for(const b of pts){
      if (a.id===b.id) continue;
      dists.push([b.id, Math.hypot(a.x_nm-b.x_nm, a.y_nm-b.y_nm)]);
    }
    dists.sort((p,q)=>p[1]-q[1]);
    for(let i=0;i<Math.min(k,dists.length);i++){
      const bId = dists[i][0];
      const key = a.id < bId ? `${a.id}-${bId}` : `${bId}-${a.id}`;
      uniq.add(key);
    }
  }
  airways = Array.from(uniq).map(s => s.split('-').map(n=>parseInt(n,10)));
}


  
  // === Named waypoints & airways (static catalog) ===
const WP = {
  CTR: { id: 1000, name: "CTR", x_nm:  0,  y_nm:   0 },
  ENE: { id: 1001, name: "ENE", x_nm: 65,  y_nm: -60 },
  ESE: { id: 1002, name: "ESE", x_nm: 65,  y_nm:  60 },
  WNW: { id: 1003, name: "WNW", x_nm:-65,  y_nm: -60 },
  WSW: { id: 1004, name: "WSW", x_nm:-65,  y_nm:  60 },
  N01: { id: 1005, name: "N01", x_nm:  0,  y_nm: -80 },
  S01: { id: 1006, name: "S01", x_nm:  0,  y_nm:  80 },
  E01: { id: 1007, name: "E01", x_nm: 80,  y_nm:   0 }, // NEW
  W01: { id: 1008, name: "W01", x_nm:-80,  y_nm:   0 }  // NEW
};

/* ── helper lists ─────────────────────────────────────────────── */
const STATIC_RING_FIXES = [
  WP.ENE.id, WP.ESE.id, WP.WNW.id, WP.WSW.id,
  WP.N01.id, WP.S01.id, WP.E01.id, WP.W01.id
];
const isRing = id => STATIC_RING_FIXES.includes(id);


// Make an immutable array for drawing labels if you want
const WP_ALL = Object.values(WP);

// Airways are pairs of waypoint ids (segments)
const AIRWAYS = [
  [WP.WNW.id, WP.CTR.id], [WP.CTR.id, WP.ENE.id],
  [WP.WSW.id, WP.CTR.id], [WP.CTR.id, WP.ESE.id],
  [WP.N01.id, WP.CTR.id], [WP.CTR.id, WP.S01.id],
  [WP.CTR.id, WP.E01.id], [WP.W01.id, WP.CTR.id], // NEW links
];


// helper
function getWPById(id){
  // prefer dynamic wpts the user added, then static catalog
  return wpts.find(w=>w.id===id) || WP_ALL.find(w=>w.id===id) || null;
}

function setEditing(field){
  const sel = getSelected();
  state.editing = sel ? { id: sel.id, field } : null;
  layoutTags(); drawLeaders(); // quick visual refresh
}
function clearEditing(field){
  if (!state.editing) return;
  if (!field || state.editing.field === field) {
    state.editing = null;
    layoutTags(); drawLeaders();
  }
}

// lookup by name (static + dynamic), case-insensitive
function findFixByName(name){
  const nm = String(name||"").trim().toUpperCase();
  if (!nm) return null;
  return wpts.find(w=>w.name.toUpperCase()===nm)
      || WP_ALL.find(w=>w.name.toUpperCase()===nm)
      || null;
}

// ---- Routing config + helpers (avoid dogpiling CTR) ----
const EDGE_FIXES = [
  WP.ENE.id, WP.ESE.id, WP.WNW.id, WP.WSW.id, WP.N01.id, WP.S01.id,
  WP.E01.id, WP.W01.id
];


const ROUTE_CFG = {
  goViaCTRProb: 0.00,     // 20% still via CTR; set 0 to ban it
  innerRadiusNm: 16,      // pick a dynamic fix within this radius of center
  addMidProb: 0.3         // chance to include an inner mid-fix on transits/deps
};

function pickInnerFixId(radiusNm = ROUTE_CFG.innerRadiusNm){
  const cands = wpts.filter(w => Math.hypot(w.x_nm, w.y_nm) <= radiusNm);
  if (cands.length) return cands[Math.random()*cands.length|0].id;
  return WP.CTR.id; // fallback if no dynamic waypoints exist yet
}

function randomEdge(excludeId=null){
  const opts = EDGE_FIXES.filter(id => id !== excludeId);
  return opts[Math.random()*opts.length|0];
}

function enforceRingEnds(route){
  // strip any *interior* ring fixes that might already be there
  route = route.filter((id, idx) =>
    idx === 0 || idx === route.length-1 || !isRing(id));

  // make sure first is a ring fix ───────────────────────────────
  if (!isRing(route[0])){
    const nearest = STATIC_RING_FIXES
      .reduce((best, fid) => {
        const w = getWPById(fid);
        const d = Math.hypot(w.x_nm, w.y_nm);    // from centre is fine
        return d < best.dist ? {id: fid, dist: d} : best;
      }, {id: null, dist: Infinity}).id;
    route.unshift(nearest);
  }

  // make sure last is a *different* ring fix ────────────────────
  if (!isRing(route[route.length-1]))
    route.push( randomEdge(route[0]) );

  // collapse accidental duplicates (ENE, ENE → ENE) -------------
  for (let i=route.length-1; i>0; i--)
    if (route[i] === route[i-1]) route.splice(i,1);

  return route;
}

// Force the first leg to the **nearest** static ring fix to the spawn,
// but keep the rest of the route intact and ring-clean.
function alignFirstFixToSpawn(route, spawnX_nm, spawnY_nm){
  if (!route.length) return route;

  // find closest ring fix to the spawn coords
  let nearest = route[0], best = Infinity;
  for (const fid of STATIC_RING_FIXES){
    const w = getWPById(fid);
    const d = Math.hypot(w.x_nm - spawnX_nm, w.y_nm - spawnY_nm);
    if (d < best){ best = d; nearest = fid; }
  }

  // slam it in as the first leg
  route[0] = nearest;

  // make sure the exit isn’t the same ring fix
  if (route.length > 1 && route[route.length-1] === route[0]){
    route[route.length-1] = randomEdge(route[0]);   // pick any other ring
  }

  // if we now have two ring fixes in a row, collapse the duplicate
  for (let i = route.length-1; i > 0; i--){
  if (route[i] === route[i-1]) {      // only drop exact duplicates
    route.splice(i,1);
  }
}
  return route;
}



// Put this near your other globals (above spawnAircraft)
const SPAWN = {
  flMin: 330,      // inclusive
  flMax: 400,      // inclusive
  marginNM: 25,     // how far outside the sector to spawn
  jitterDeg: 45    // ± jitter to avoid perfectly cardinal inbounds
};

// --- Auto spawner (cooldown-based; guarantees ≤1 spawn per tick) ---
const AutoSpawn = {
  enabled: false,
  cooldownSec: Infinity,   // counts down while enabled; Infinity when disabled
  minGap: 65,
  maxGap: 85,
  conflictChance: 0.00
};
function randGap(){
  return AutoSpawn.minGap + Math.random()*(AutoSpawn.maxGap - AutoSpawn.minGap);
}
function armCooldown(){ AutoSpawn.cooldownSec = randGap(); }
function disarmCooldown(){ AutoSpawn.cooldownSec = Infinity; }

// routeMode can be 'arrival' | 'departure' | 'transit' | null
function spawnWithParams({x_nm,y_nm,hdg,alt_ft,spd_kt, jitterDeg=0, routeMode=null}, fp=null){
  const a = new Aircraft({ x_nm, y_nm, hdg, alt_ft, spd_kt, fp });

  if (jitterDeg) hdg = mod360(hdg + rand(-jitterDeg, +jitterDeg));
  a.setHeading(hdg);
  a.inSector = env.inRect(a.x_nm, a.y_nm);

  if (fp) {
    // Decide routing mode if caller didn't force one
    let mode = routeMode ?? (!env.inRect(x_nm, y_nm) ? 'arrival' : 'departure');

    // 1) BUILD the route first
    let route;
    if (mode === 'transit')      route = buildTransitRoute(fp);
    else if (mode === 'arrival') route = buildArrivalRoute(fp);
    else                         route = buildDepartureRoute(fp);

    // 2) Tidy & align after it exists
    if (Array.isArray(route) && route.length){
      route = alignFirstFixToSpawn(route, x_nm, y_nm);

      if (mode === 'arrival') {
        if (route[route.length-1] !== WP.CTR.id) route.push(WP.CTR.id);
      } else if (mode === 'departure') {
        if (route[0] !== WP.CTR.id) route.unshift(WP.CTR.id);
      }

      route = enforceRingEnds(route);
      route = sanitizeMidpoints(route, GENTLE);
a.setRoute(route);

    }
  }

  state.ac.push(a);

  // Fallback: no route? at least fly toward nearest ring fix so it enters sensibly
  if (!a.route.length){
    a.directTo( nearestStaticFixId(a.x_nm, a.y_nm) );
  }

  state.selectedId = a.id;
  flashSelected(); updateSelectedPanel(); drawAll();
  return a;
}



function spawnPlannedAircraft(){
  const halfW = env.rectW/2, halfH = env.rectH/2, m = SPAWN.marginNM;

  // --- choose mode (weights) ---
  const wTransit=0.80, wArrival=0.10, wDepart=0.10; // tweak to taste
  const r = Math.random();
  let mode = 'transit';
  if (r < wTransit) mode = 'transit';
  else if (r < wTransit + wArrival) mode = 'arrival';
  else mode = 'departure';

  // Choose alt/speed & SFP
  const tMin = Math.floor(SPAWN.flMin/10);
  const tMax = Math.floor(SPAWN.flMax/10);
  const FL   = (tMin + randi(0, tMax - tMin))*10;
  const alt  = FL*100;
  const spd  = 420 + Math.random()*70;
  const fp   = makeSFP({ cruiseFL: FL, tasKt: Math.round(spd) });

  if (mode === 'departure'){
    // spawn near center pointing out
    const ang = Math.random()*Math.PI*2;
    const r   = rand(0, Math.min(halfW, halfH)*0.25);
    const x   = Math.sin(ang)*r;
    const y   = -Math.cos(ang)*r;
    const hdg = mod360(toDeg(Math.atan2(x, -y)));
    return spawnWithParams({x_nm:x,y_nm:y,hdg,alt_ft:alt,spd_kt:spd, routeMode:'departure'}, fp);
  }

  // edge spawns share similar logic
  const side = randi(0,3);
  let x=0,y=0,baseHdg=0;
  if (side===0){ y=-(halfH+m); x=rand(-halfW*0.9, halfW*0.9); baseHdg=180; }
  else if(side===1){ x=(halfW+m); y=rand(-halfH*0.9, halfH*0.9); baseHdg=270; }
  else if(side===2){ y=(halfH+m); x=rand(-halfW*0.9, halfW*0.9); baseHdg=0; }
  else { x=-(halfW+m); y=rand(-halfH*0.9, halfH*0.9); baseHdg=90; }

  // small jitter to avoid perfect lines
  const hdg = mod360(baseHdg + rand(-SPAWN.jitterDeg, SPAWN.jitterDeg));

  if (mode === 'arrival'){
    // treat as arrival route (could still avoid CTR per your ROUTE_CFG)
    return spawnWithParams({x_nm:x,y_nm:y,hdg,alt_ft:alt,spd_kt:spd, routeMode:'arrival'}, fp);
  } else {
    // true transit: edge -> inner/exit (route builder ensures exit ≠ entry)
    return spawnWithParams({x_nm:x,y_nm:y,hdg,alt_ft:alt,spd_kt:spd, routeMode:'transit'}, fp);
  }
}


// Spawn a conflict pack (pair or triple) that will converge near center
function spawnConflictPack(useRoutes=false){
  const halfW = env.rectW/2, halfH = env.rectH/2, m = SPAWN.marginNM;

  // Same level for all units in the pack
  const tMin = Math.floor(SPAWN.flMin/10);
  const tMax = Math.floor(SPAWN.flMax/10);
  const FL   = (tMin + randi(0, tMax - tMin))*10;
  const alt  = FL*100;
  const spd1 = 430 + Math.random()*60;
  const spd2 = 430 + Math.random()*60;

  // Choose axis pair (E↔W or N↔S) so they cross the middle
  const EW = Math.random() < 0.5;
  
    const fpArg = useRoutes ? makeSFP({cruiseFL:FL}) : null;


  if (EW){
    // One from West → East, one from East → West, slight vertical offset
    const y = rand(-halfH*0.6, halfH*0.6);
    spawnWithParams({ x_nm:-(halfW+m), y_nm:y+rand(-4, +4), hdg:90+rand(-10,10), alt_ft:alt, spd_kt:spd1 }, fpArg);
    spawnWithParams({ x_nm:(halfW+m),  y_nm:y+rand(-4, +4), hdg:270+rand(-10,10),alt_ft:alt, spd_kt:spd2 }, fpArg);


  } else {
    // One from North → South, one from South → North
    const x = rand(-halfW*0.6, halfW*0.6);
    spawnWithParams({ x_nm:x+rand(-4,+4), y_nm:-(halfH+m), hdg:180+rand(-10,10), alt_ft:alt, spd_kt:spd1 }, fpArg);
    spawnWithParams({ x_nm:x+rand(-4,+4), y_nm:(halfH+m),  hdg:0+rand(-10,10),   alt_ft:alt, spd_kt:spd2 }, fpArg);

  }

  // 30% chance add a third crosser to spice it up
  if (Math.random() < 0.30){
    const hdg = randi(0,3)*90 + rand(-20,20);
    const side = randi(0,3);
    let x=0,y=0;
    if (side===0){ y=-(halfH+m); x=rand(-halfW*0.9, halfW*0.9); }
    else if(side===1){ x=(halfW+m); y=rand(-halfH*0.9, halfH*0.9); }
    else if(side===2){ y=(halfH+m); x=rand(-halfW*0.9, halfW*0.9); }
    else { x=-(halfW+m); y=rand(-halfH*0.9, halfH*0.9); }
    spawnWithParams({ x_nm:x, y_nm:y, hdg, alt_ft:alt, spd_kt: 430+Math.random()*60 }, fpArg);
  }
}


 function spawnAircraft(){
  // Choose a sector edge to spawn from: 0=N, 1=E, 2=S, 3=W
  const side = Math.floor(Math.random()*4);
  const halfW = env.rectW/2, halfH = env.rectH/2;
  const m = SPAWN.marginNM;

  let x=0, y=0, hdg=0;

  switch(side){
    case 0: // from North → heading South
      y = -(halfH + m);
      x = (Math.random()*2 - 1) * (halfW * 0.9);
      hdg = 180;
      break;
    case 1: // from East → heading West
      x =  (halfW + m);
      y = (Math.random()*2 - 1) * (halfH * 0.9);
      hdg = 270;
      break;
    case 2: // from South → heading North
      y =  (halfH + m);
      x = (Math.random()*2 - 1) * (halfW * 0.9);
      hdg = 0;
      break;
    default: // from West → heading East
      x = -(halfW + m);
      y = (Math.random()*2 - 1) * (halfH * 0.9);
      hdg = 90;
      break;
  }



  // Add a little randomization so they’re not laser-straight
  hdg = mod360(hdg + (Math.random()*SPAWN.jitterDeg*2 - SPAWN.jitterDeg));

  // Pick FL in tens within [flMin, flMax]
  const tMin = Math.floor(SPAWN.flMin/10);
  const tMax = Math.floor(SPAWN.flMax/10);
  const tens = tMin + Math.floor(Math.random()*(tMax - tMin + 1)); // integer step of 10 FLs
  const FL = tens * 10;
  const alt = FL * 100; // your sim uses FL * 100 = feet

  // Cruise-y speed; you can also switch to Mach if you prefer
  const spd = 430 + Math.random()*60;

  const a = new Aircraft({ x_nm:x, y_nm:y, hdg:hdg, alt_ft:alt, spd_kt:spd });
  a.setHeading(hdg);                   // ensure initial vector is inbound
  a.inSector = env.inRect(a.x_nm, a.y_nm);

  state.ac.push(a);
  state.selectedId = a.id;
  flashSelected();
  updateSelectedPanel();
  drawAll();
}

  function clearAll(){
    state.ac.length=0; state.selectedId=null; updateSelectedPanel();
    // remove leftover tags
    for(const el of tagMap.values()) el.remove(); tagMap.clear();
    drawAll();
  }

  // ---------- Conflict detection ----------
  const sepNM=5, sepFT=1000;
  function project(ac,tSec){
    const dist_nm=ac.spd_kt*nmPerKtPerSec*tSec;
    const x=ac.x_nm+Math.sin(toRad(ac.hdg))*dist_nm;
    const y=ac.y_nm-Math.cos(toRad(ac.hdg))*dist_nm;
    let alt=ac.alt_ft;
    if(ac.alt_ft!==ac.tgtAlt){
      const vs_fps=clamp(ac.vs_fpm*ftPerMinToFtPerSec, -ac.maxVS_fps, ac.maxVS_fps);
      const delta=vs_fps*tSec; const rem=ac.tgtAlt-ac.alt_ft;
      if(Math.sign(rem)===Math.sign(delta)&&Math.abs(delta)<=Math.abs(rem)) alt=ac.alt_ft+delta; else alt=ac.tgtAlt;
    }
    return {x,y,alt};
  }
  function detectConflicts(){
    state.conflictsNow.length=0; state.conflictsPred.length=0;
    for(let i=0;i<state.ac.length;i++){
      for(let j=i+1;j<state.ac.length;j++){
        const a=state.ac[i], b=state.ac[j];
        const dnm=Math.hypot(a.x_nm-b.x_nm,a.y_nm-b.y_nm);
        const dft=Math.abs(a.alt_ft-b.alt_ft);
        if(dnm<sepNM && dft<sepFT){ state.conflictsNow.push([a.id,b.id]); continue; }
        const t=state.lookaheadMin*60; if(t>0){
          const pa=project(a,t), pb=project(b,t);
          const dnmP=Math.hypot(pa.x-pb.x,pa.y-pb.y);
          const dftP=Math.abs(pa.alt-pb.alt);
          if(dnmP<sepNM && dftP<sepFT) state.conflictsPred.push([a.id,b.id]);
        }
      }
    }
  }

  // ---------- Drawing (split: canvas vs DOM) ----------
  const tagMap = new Map(); // id -> element
  let wptElems=[];

  function layoutWptLabels(){
  for(const e of wptElems) e.remove(); wptElems.length=0;
  const all = [...WP_ALL, ...wpts];
  for(const w of all){
    const x=cx+nmToPx(w.x_nm), y=cy+nmToPx(w.y_nm);
    const lab=document.createElement('div');
    lab.className='waypointLabel';
    lab.textContent=w.name;
    lab.style.left=(x+8)+'px';
    lab.style.top =(y-10)+'px';
    wptElems.push(lab); wrap.appendChild(lab);
  }
}


  function layoutTags(){
    const presentIds = new Set();
    for(const a of state.ac){
      presentIds.add(a.id);
      const x=cx+nmToPx(a.x_nm), y=cy+nmToPx(a.y_nm);
      let tag = tagMap.get(a.id);
      if(!tag){
        tag=document.createElement('div');
        tag.className='tag';
        tag.dataset.trackId=String(a.id);
        // Drag/select handlers
        let dragging=false, startX=0,startY=0, startDx=0,startDy=0, moved=false;
        tag.addEventListener('pointerdown', ev=>{
  // NEW: Shift + Left Click on tag → use that aircraft position as a measure point
  if (ev.shiftKey && ev.button === 0) {
    const ax = cx + nmToPx(a.x_nm);
    const ay = cy + nmToPx(a.y_nm);
    handleMeasureSmartClick(ax, ay);
    ev.preventDefault();
    return;
  }

  if(ev.button!==0) return; // left only
  dragging=true; moved=false; tag.setPointerCapture(ev.pointerId);
  tag.classList.add('dragging');
  const aObj = state.ac.find(z=>z.id===a.id); if(!aObj) return;
  startX=ev.clientX; startY=ev.clientY; startDx=aObj.labelDx; startDy=aObj.labelDy; ev.preventDefault();
});

        tag.addEventListener('pointermove', ev=>{
  if(!dragging) return;
  if ((ev.buttons & 1) === 0) {  // LMB no longer held
    dragging=false; tag.classList.remove('dragging');
    try{ tag.releasePointerCapture(ev.pointerId);}catch{}
    return;
  }
  const aObj = state.ac.find(z=>z.id===a.id); if(!aObj) return;
  const dx=ev.clientX-startX, dy=ev.clientY-startY;
  if(Math.hypot(dx,dy)>3) moved=true;
  aObj.labelDx = startDx + dx; aObj.labelDy = startDy + dy;
  tag.style.left = (cx+nmToPx(aObj.x_nm) + aObj.labelDx) + 'px';
  tag.style.top  = (cy+nmToPx(aObj.y_nm) + aObj.labelDy) + 'px';
  drawCanvasOnly();
});

        tag.addEventListener('pointerup', ev=>{
  tag.classList.remove('dragging');
  if(dragging && !moved){ state.selectedId=a.id; flashSelected(); updateSelectedPanel(); layoutTags(); drawCanvasOnly(); }
  dragging=false;
  try{ tag.releasePointerCapture(ev.pointerId);}catch{}
});
tag.addEventListener('pointercancel', ()=>{
  dragging=false; tag.classList.remove('dragging');
});
tag.addEventListener('lostpointercapture', ()=>{
  dragging=false; tag.classList.remove('dragging');
});

        tag.addEventListener('click', ev=>{ ev.stopPropagation(); });
        wrap.appendChild(tag);
        tagMap.set(a.id, tag);
        
        // Bind once per tag: Shift+MMB toggles the green route preview;
// also block the browser’s autoscroll on Shift+MMB.
tag.addEventListener('auxclick', (ev)=>{
  if (ev.button === 1 && ev.shiftKey){
    state.routePreviewId = (state.routePreviewId === a.id) ? null : a.id;
    drawAll(); // or drawCanvasOnly();
    ev.preventDefault();
    ev.stopPropagation();
  }
});
tag.addEventListener('mousedown', (ev)=>{
  if (ev.button === 1 && ev.shiftKey){
    ev.preventDefault();
    ev.stopPropagation();
  }
});

      }
      // Update classes/content/position
      tag.classList.toggle('alert', state.conflictsNow.some(([p,q])=>p===a.id||q===a.id));
      tag.classList.toggle('warn', !tag.classList.contains('alert') && state.conflictsPred.some(([p,q])=>p===a.id||q===a.id));
      // apply state color class for text-only labels
const st = getTrackState(a);   // uses helpers from step 2.3
tag.classList.remove('st-controlled','st-inbound','st-intruder','st-outbound');
tag.classList.add('st-'+st);

// build 4 text lines (no box, no table)
const curFL = fmtFLshort(a.alt_ft);
const cfl   = fmtCFL(a.tgtAlt);
const type  = a.fp?.type || a.type;
const wpt   = nextWptName(a, env);
const vs100 = fmtVS100(a.vs_fpm);

tag.innerHTML = `
  <div class="l1"><span data-cs>${a.cs}</span><span class="ho" data-ho="1" title="Toggle H/O">H/O</span></div>
  <div class="l2"><span data-act="curfl">${curFL}</span>&nbsp;&nbsp;&nbsp;<span data-act="cfl">${cfl}</span>&nbsp;&nbsp;VS<span data-act="vs">${vs100}</span></div>
  <div class="l2"><span data-act="type">${type}</span>&nbsp;&nbsp;&nbsp;<span data-act="wpt">${wpt}</span></div>
  <div class="l2">H<span data-act="hdg">${formatHeading(a.hdg)}</span>&nbsp;&nbsp;&nbsp;S<span data-act="spd">${a.spd_kt|0}</span>/M<span data-act="mach">${a.mach.toFixed(2)}</span></div>
`;


// wire the tiny H/O toggle (marks a.hoMarked to drive "intruder" color)
const hoBtn = tag.querySelector('[data-ho]');
if (hoBtn){
  hoBtn.onclick = (ev)=>{
    ev.stopPropagation();
    a.hoMarked = !a.hoMarked;
    layoutTags(); drawCanvasOnly();
  };
}
// Middle-click on callsign => open SFP
const csBtn = tag.querySelector('[data-cs]');
if (csBtn){
  csBtn.addEventListener('mousedown', ev=>{
    if (ev.button === 1){ openSFP(a); ev.preventDefault(); }
  });
}

// ===== MMB-only editing for label values =====
const act = sel => tag.querySelector(`[data-act="${sel}"]`);

// clear previous highlight on this tag, then apply if this tag is being edited
tag.querySelectorAll('[data-act]').forEach(s=>s.classList.remove('editing'));
if (state.editing && state.editing.id === a.id){
  const hi = act(state.editing.field);
  if (hi) hi.classList.add('editing');
}

// prevent autoscroll on middle mouse and stop it bubbling into drag
function blockMMB(el){
  if(!el) return;
  el.addEventListener('mousedown', ev=>{
    if (ev.button === 1){ ev.preventDefault(); ev.stopPropagation(); }
  });
}

// run an action only on true MMB (auxclick)
function withMMB(el, fn){
  if(!el) return;
  el.addEventListener('auxclick', ev=>{
    if (ev.button !== 1 || ev.shiftKey) return;  // plain-MMB only
    ev.preventDefault();
    ev.stopPropagation();
    fn();
  });
}


// H
const hdgEl = act('hdg'); blockMMB(hdgEl);
withMMB(hdgEl, ()=>{
  state.selectedId=a.id; updateSelectedPanel();
  const inp = document.getElementById('hdg');
  setEditing('hdg');
  inp.focus(); inp.select();
});

// S (kt)
const spdEl = act('spd'); blockMMB(spdEl);
withMMB(spdEl, ()=>{
  state.selectedId=a.id; updateSelectedPanel();
  const inp = document.getElementById('spd');
  setEditing('spd');
  inp.focus(); inp.select();
});

// M
const machEl = act('mach'); blockMMB(machEl);
withMMB(machEl, ()=>{
  state.selectedId=a.id; updateSelectedPanel();
  const inp = document.getElementById('mach');
  setEditing('mach');
  inp.focus(); inp.select();
});

// VS (×100)
const vsEl = act('vs'); blockMMB(vsEl);
withMMB(vsEl, ()=>{
  state.selectedId=a.id; updateSelectedPanel();
  const inp = document.getElementById('vs');
  inp.value = Math.round(Math.abs(a.vs_fpm)/100);
  setEditing('vs');
  inp.focus(); inp.select();
});

// Waypoint direct-to via MMB prompt
const wptEl = act('wpt'); blockMMB(wptEl);
withMMB(wptEl, ()=>{
  const name = prompt("Direct-to waypoint (e.g. CTR, ENE, any dynamic name):", "");
  if (!name) return;
  const w = findFixByName(name);
  if (w) { a.directTo(w.id); updateSelectedPanel(); drawAll(); }
  else { alert("No waypoint with that name."); }
  



});



      tag.style.left=(x+a.labelDx)+'px'; tag.style.top=(y+a.labelDy)+'px';
    }
    

    // Remove tags for AC that no longer exist
    for(const [id,el] of tagMap.entries()){
      if(!presentIds.has(Number(id))){ el.remove(); tagMap.delete(id); }
    }
  }

  function drawScope(){
  // Background (near-black)
  ctx.save();
  ctx.setTransform(1,0,0,1,0,0);
  ctx.globalAlpha = 1;
  ctx.fillStyle = "#060707";
  ctx.fillRect(0,0,W,H);

  // Very faint grid (optional)
  ctx.strokeStyle = "#0b0b0b";
  ctx.lineWidth = 1;
  ctx.beginPath();
  for(let x=0;x<W;x+=40){ ctx.moveTo(x,0); ctx.lineTo(x,H); }
  for(let y=0;y<H;y+=40){ ctx.moveTo(0,y); ctx.lineTo(W,y); }
  ctx.stroke();

  // Faint range rings (no labels)
  ctx.strokeStyle = "#141414";
  ctx.lineWidth = 1;
  const ringCount = 5;
  for(let i=1;i<=ringCount;i++){
    const r = (Math.min(W,H)/2) * i / ringCount;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI*2);
    ctx.stroke();
  }

  // Crosshair
  ctx.strokeStyle = "#1a1a1a";
  ctx.beginPath();
  ctx.moveTo(cx,0); ctx.lineTo(cx,H);
  ctx.moveTo(0,cy); ctx.lineTo(W,cy);
  ctx.stroke();

  // Rectangular sector (subtle grey)
  const halfWpx = nmToPx(env.rectW/2);
  const halfHpx = nmToPx(env.rectH/2);
  ctx.strokeStyle = "#3a3a3a";
  ctx.lineWidth = 1.6;
  ctx.setLineDash([6,6]);
  ctx.strokeRect(cx-halfWpx, cy-halfHpx, halfWpx*2, halfHpx*2);
  ctx.setLineDash([]);
  ctx.restore();
}


  function formatAltitude(ft){ return ft>=18000?("FL"+String(Math.round(ft/100)).padStart(3,'0')):((ft|0)+" ft"); }
  function inFilter(ft){ return ft>=state.filterMin && ft<=state.filterMax; }

  function drawPredictLines(ac){
  const wants=[ state.pred1?60:0, state.pred3?180:0, state.pred5?300:0 ].filter(Boolean);
  if(!wants.length) return;
  if(!Number.isFinite(ac.x_nm) || !Number.isFinite(ac.y_nm) || !Number.isFinite(ac.hdg) || !Number.isFinite(ac.spd_kt)) return;

  const x0=cx+nmToPx(ac.x_nm), y0=cy+nmToPx(ac.y_nm);
  ctx.lineWidth=1.5; ctx.setLineDash([]); ctx.strokeStyle = "#ffffff";
  for(const t of wants){
    const dist_nm=ac.spd_kt*nmPerKtPerSec*t;
    if(!Number.isFinite(dist_nm)) continue;
    const x=x0+nmToPx(Math.sin(toRad(ac.hdg))*dist_nm);
    const y=y0+nmToPx(-Math.cos(toRad(ac.hdg))*dist_nm);
    ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(x,y); ctx.stroke();
  }
}


  
function drawAirways(){
  ctx.save();
  ctx.strokeStyle = "rgba(150, 200, 255, 0.5)";
  ctx.lineWidth = 1.2;
  ctx.setLineDash([2,10]);
  for(const [a,b] of AIRWAYS){
    const A = getWPById(a), B = getWPById(b);
    if(!A || !B) continue;
    const x1 = cx + nmToPx(A.x_nm), y1 = cy + nmToPx(A.y_nm);
    const x2 = cx + nmToPx(B.x_nm), y2 = cy + nmToPx(B.y_nm);
    ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  }
  ctx.restore();
}

  function drawWaypointsCrosses(){
  // Airways (all nodes)
  ctx.strokeStyle = "rgba(150, 200, 255, 0.5)";
  ctx.lineWidth = 1;
  ctx.setLineDash([4,8]); // faint dashed
  ctx.beginPath();
  for(const [aId,bId] of airways){
    const A = getWPById(aId), B = getWPById(bId);
    if(!A||!B) continue;
    const x1 = cx + nmToPx(A.x_nm), y1 = cy + nmToPx(A.y_nm);
    const x2 = cx + nmToPx(B.x_nm), y2 = cy + nmToPx(B.y_nm);
    ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
  }
  ctx.stroke();
  ctx.setLineDash([]);

  // Static crosses (cyan-ish)
  for(const w of WP_ALL){
    const x=cx+nmToPx(w.x_nm), y=cy+nmToPx(w.y_nm);
    ctx.strokeStyle="#9ad6ff"; ctx.lineWidth=1.2;
    ctx.beginPath(); ctx.moveTo(x-6,y); ctx.lineTo(x+6,y); ctx.moveTo(x,y-6); ctx.lineTo(x,y+6); ctx.stroke();
  }
  // Dynamic crosses (magenta-ish like before)
  for(const w of wpts){
    const x=cx+nmToPx(w.x_nm), y=cy+nmToPx(w.y_nm);
    ctx.strokeStyle="#ff7bff"; ctx.lineWidth=1.2;
    ctx.beginPath(); ctx.moveTo(x-6,y); ctx.lineTo(x+6,y); ctx.moveTo(x,y-6); ctx.lineTo(x,y+6); ctx.stroke();
  }
}



  function drawConflicts(){
    for(const [aId,bId] of state.conflictsPred){
      const a=state.ac.find(x=>x.id===aId), b=state.ac.find(x=>x.id===bId); if(!a||!b) continue;
      ctx.strokeStyle="#ffcc66"; ctx.lineWidth=1.5; ctx.setLineDash([4,6]);
      ctx.beginPath(); ctx.moveTo(cx+nmToPx(a.x_nm), cy+nmToPx(a.y_nm)); ctx.lineTo(cx+nmToPx(b.x_nm), cy+nmToPx(b.y_nm)); ctx.stroke();
    }
    for(const [aId,bId] of state.conflictsNow){
      const a=state.ac.find(x=>x.id===aId), b=state.ac.find(x=>x.id===bId); if(!a||!b) continue;
      ctx.strokeStyle="#ff6a6a"; ctx.lineWidth=2.2; ctx.setLineDash([]);
      ctx.beginPath(); ctx.moveTo(cx+nmToPx(a.x_nm), cy+nmToPx(a.y_nm)); ctx.lineTo(cx+nmToPx(b.x_nm), cy+nmToPx(b.y_nm)); ctx.stroke();
    }
    ctx.setLineDash([]);
  }

// --- Measuring (refactored) ---
// Measures now support endpoints that can be either:
//  - {type:'ac', id:<trackId>}  -> follows that aircraft live
//  - {x_nm:<num>, y_nm:<num>}   -> fixed point in space
// Backward compatibility: we still render old {fromX_nm, toX_nm, ...} shapes.

function drawMeasureSegment(m){
  ctx.save();

  // Resolve endpoints (support both new and legacy shapes)
  const p1 = m.from ? resolveEndpoint(m.from) : {x_nm:m.fromX_nm, y_nm:m.fromY_nm};
  const p2 = m.to   ? resolveEndpoint(m.to)   : {x_nm:m.toX_nm,   y_nm:m.toY_nm};
  if(!p1 || !p2){ ctx.restore(); return; }

  const x1 = cx + nmToPx(p1.x_nm), y1 = cy + nmToPx(p1.y_nm);
  const x2 = cx + nmToPx(p2.x_nm), y2 = cy + nmToPx(p2.y_nm);

  // line
  ctx.strokeStyle="#9ad6ff";
  ctx.lineWidth=1.8;
  ctx.setLineDash([8,6]);
  ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
  ctx.setLineDash([]);

  // endpoints
  ctx.fillStyle="#e6f0f7";
  ctx.beginPath(); ctx.arc(x1,y1,3,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(x2,y2,3,0,Math.PI*2); ctx.fill();

  // label text (no box): place slightly "above" the segment midpoint
  const dnm = Math.hypot(p2.x_nm-p1.x_nm, p2.y_nm-p1.y_nm);
  const brg = bearingFromTo(p1.x_nm,p1.y_nm,p2.x_nm,p2.y_nm);
  const text = `${dnm.toFixed(1)} NM • HDG ${formatHeading(brg)}`;

  const midx = (x1+x2)/2, midy = (y1+y2)/2;
  // screen-space normal (perpendicular) for offset
  const nx = (y2 - y1), ny = -(x2 - x1);
  const nlen = Math.hypot(nx, ny) || 1;
  const off = 14; // how far above the line (px)
  const tx = midx + (nx / nlen) * off;
  const ty = midy + (ny / nlen) * off;

  // halo + fill for readability
  ctx.font = "12px ui-monospace";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.lineWidth = 4;
  ctx.strokeStyle = "rgba(7,16,24,0.9)"; // dark halo
  ctx.strokeText(text, tx, ty);
  ctx.fillStyle = "#cfe8f7";
  ctx.fillText(text, tx, ty);

  ctx.restore();
}


function drawActiveMeasure(){
  if(!state.measure) return;
  ctx.save();
  ctx.globalAlpha = 1;      // don’t inherit any dimming
  ctx.setLineDash([]);      // don’t inherit dashes
  drawMeasureSegment(state.measure);
  ctx.restore();
}
function drawRulers(){
  ctx.save();
  ctx.globalAlpha = 1;
  ctx.setLineDash([]);
  for(const m of state.measures) drawMeasureSegment(m);
  ctx.restore();
}

// ===== Bright-green route preview =========================================
function drawRoutePreview(){
  const id = state.routePreviewId;
  if (id == null) return;

  const a = state.ac.find(t => t.id === id);
  if (!a || !a.route.length) return;

  ctx.save();
  ctx.strokeStyle = "#00ff6b";   // neon green
  ctx.lineWidth   = 2.4;
  ctx.setLineDash([3,6]);        // dashed; delete line for solid

  // start at the aircraft's current position
  let px = cx + nmToPx(a.x_nm);
  let py = cy + nmToPx(a.y_nm);

  for (let i = Math.max(a.routeIdx, 0); i < a.route.length; i++){
    const w = env.getWaypoint(a.route[i]);
    if (!w) continue;
    const wx = cx + nmToPx(w.x_nm);
    const wy = cy + nmToPx(w.y_nm);

    ctx.beginPath();
    ctx.moveTo(px, py);
    ctx.lineTo(wx, wy);
    ctx.stroke();

    px = wx; py = wy;   // next leg starts here
  }
  ctx.restore();
}


// NEW: Shift+Left click handler — snaps to aircraft (live) or uses free point.
function handleMeasureSmartClick(xPx, yPx){
  const ac = findNearestAcPx(xPx, yPx, 16);
  const ep = ac ? { type:'ac', id: ac.id }
                : pxToNm(xPx, yPx); // {x_nm, y_nm}

  if(!state.measure){
    // Start: from = ep, to = cursor (temporary same ep)
    state.measure = { from: ep, to: ep };
  }else{
    // Finish: set 'to' endpoint and commit
    state.measure.to = ep;
    state.measures.push({ ...state.measure }); // store by reference
    state.measure = null;
  }
  drawAll();
}



  function drawCanvasBase(){
  drawScope();
  drawAirways();
  drawWaypointsCrosses();
  detectConflicts();

  for(const a of state.ac){
    if (!Number.isFinite(a.x_nm) || !Number.isFinite(a.y_nm) ||
        !Number.isFinite(a.hdg)  || !Number.isFinite(a.spd_kt)) {
      continue; // skip broken track this frame
    }
    const selected = a.id===state.selectedId;
    const dim = !inFilter(a.alt_ft); ctx.globalAlpha = dim?0.35:1.0;

    // dotted trail
    ctx.fillStyle = "#ffffff";
    for(const p of a.trail){
      if(!Number.isFinite(p.x) || !Number.isFinite(p.y)) continue;
      const tx = cx+nmToPx(p.x), ty = cy+nmToPx(p.y);
      ctx.beginPath(); ctx.arc(tx,ty,2.4,0,Math.PI*2); ctx.fill();
    }

    // vectors
    const showPred = state.predFor==="all" || (state.predFor==="sel" && selected);
    if(showPred) drawPredictLines(a);

    // symbol
    const x = cx + nmToPx(a.x_nm), y = cy + nmToPx(a.y_nm);
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    const s = 5;
    ctx.moveTo(x, y - s);
    ctx.lineTo(x + s, y);
    ctx.lineTo(x, y + s);
    ctx.lineTo(x - s, y);
    ctx.closePath(); ctx.fill();
  }

  drawConflicts();
  ctx.globalAlpha=1.0;
}


  function drawLeaders(){
    for(const a of state.ac){
      const dotX=cx+nmToPx(a.x_nm), dotY=cy+nmToPx(a.y_nm);
      const tag = tagMap.get(a.id); if(!tag) continue;
      const rect = tag.getBoundingClientRect(), wrapRect = wrap.getBoundingClientRect();
      const left = rect.left - wrapRect.left, top = rect.top - wrapRect.top;
      const right = left + rect.width, bottom = top + rect.height;
      const ex = clamp(dotX, left, right), ey = clamp(dotY, top, bottom);
      ctx.strokeStyle = "#ffffff";

      ctx.beginPath(); ctx.moveTo(dotX, dotY); ctx.lineTo(ex, ey); ctx.stroke();
    }
  }

  function drawCanvasOnly(){ // fast path during drags
    drawCanvasBase();
    drawLeaders();
    drawRoutePreview();
    drawRulers();     // NEW: draw committed rulers
    drawActiveMeasure();
  }

  function drawAll(){
  drawCanvasBase();
  layoutWptLabels();
  layoutTags();
  drawLeaders();
  drawRoutePreview();   // ← only ONE call here
  drawRulers();
  drawActiveMeasure();
}


// ---------- Simulation (3s refresh) ----------
function stepOnce(){
  if(state.paused){ 
    drawCanvasOnly(); 
    return; 
  }

  // advance sim clock
  simNowSec += state.refreshSec * state.simSpeed;
  const dt = state.refreshSec * state.simSpeed;

  // move all aircraft
  for(const a of state.ac) a.update(dt, env);
  // Mark seen-once and cull only after they actually appeared
for (const a of state.ac) {
  if (acInScopeNm(a, 0)) a.seenOnScreenOnce = true;
}

const TTL_NEVER_SEEN_SEC = 280; // safety: if something never appears in 3 min, drop it
state.ac = state.ac.filter(a => {
  if (!a.seenOnScreenOnce) {
    // Keep until it appears, unless TTL expires (or it has already entered)
    return (simNowSec - a.spawnSec) < TTL_NEVER_SEEN_SEC || acInScopeNm(a, 0);
  }
  // Once seen at least once, despawn after it leaves the scope by 8 NM
  return acInScopeNm(a, 8);
});

if (state.selectedId && !state.ac.some(a => a.id === state.selectedId)) {
  state.selectedId = null;
}


// auto-spawn (cooldown)
if (AutoSpawn.enabled && Number.isFinite(AutoSpawn.cooldownSec)) {
  AutoSpawn.cooldownSec -= dt;        // dt = state.refreshSec * state.simSpeed
  if (AutoSpawn.cooldownSec <= 0) {
    if (Math.random() < AutoSpawn.conflictChance) {
  spawnConflictPack(true);   // routed conflicts for autos
} else {
  spawnPlannedAircraft();    // routed singles for autos
}

    armCooldown();                    // reset for next randomized gap
  }
}


  drawAll();
}
let timer = setInterval(stepOnce, 3000);


  // ---------- UI ----------
  const altInput=document.getElementById('alt'); const useFL=document.getElementById('useFL'); const altHint=document.getElementById('altModeHint');
  function updateAltPlaceholder(){
    if(useFL.checked){ altInput.placeholder="e.g. 150 (FL150)"; altHint.textContent="Input interpreted as Flight Level (hundreds of feet)"; }
    else{ altInput.placeholder="e.g. 15000 (ft)"; altHint.textContent="Input interpreted as feet (type FL120 to use FL)"; }
  }
  useFL.addEventListener('change', ()=>{
    const a=getSelected();
    if(a){ altInput.value = useFL.checked ? Math.round(a.tgtAlt/100) : Math.round(a.tgtAlt); }
    updateAltPlaceholder();
  });
  updateAltPlaceholder();

  // Canvas interactions
  canvas.addEventListener('click', e=>{
    if(state.addingWpt){
      const rect=canvas.getBoundingClientRect();
      const xPx=e.clientX-rect.left, yPx=e.clientY-rect.top;
      const {x_nm,y_nm}=pxToNm(xPx,yPx);
      addWaypointAt(x_nm,y_nm); state.addingWpt=false;
      document.getElementById('addWpt').textContent="Add waypoint"; return;
    }
    state.selectedId=null; updateSelectedPanel(); layoutTags(); drawCanvasOnly();
  });

// Measuring: Shift+MMB start/update, RMB now DROPS (commits) instead of clearing.
//           NEW: Shift+Left Click = start/finish with snapping
canvas.addEventListener('pointerdown', e=>{
  const rect = canvas.getBoundingClientRect();
  const xPx = e.clientX - rect.left, yPx = e.clientY - rect.top;

  // Shift + Left Click = smart start/finish (snaps to aircraft if close)
  if (e.shiftKey && e.button === 0) {
    handleMeasureSmartClick(xPx, yPx);
    e.preventDefault();
    return;
  }

  // Plain Left Click = if already measuring, drop/commit immediately
  if (!e.shiftKey && e.button === 0 && state.measure) {
    state.measures.push({ ...state.measure });
    state.measure = null;
    drawAll();
    e.preventDefault();
    return;
  }
});



canvas.addEventListener('pointermove', e=>{
  if(!state.measure) return;
  // If we're mid-placing the second endpoint and it's NOT an aircraft-linked endpoint,
  // update it to follow the cursor for a live preview.
  const rect=canvas.getBoundingClientRect();
  const xPx=e.clientX-rect.left, yPx=e.clientY-rect.top;

  // If 'to' is aircraft-linked, don't override it.
  if(state.measure.to && state.measure.to.type === 'ac') return;

  const {x_nm,y_nm}=pxToNm(xPx,yPx);
  // Ensure the new-style shape exists
  if(!state.measure.from && 'fromX_nm' in state.measure){
    state.measure = { from:{x_nm:state.measure.fromX_nm, y_nm:state.measure.fromY_nm},
                      to:{x_nm, y_nm} };
  }else{
    state.measure.to = {x_nm, y_nm};
  }
  drawCanvasOnly();
});


canvas.addEventListener('pointerup', e=>{
  // keep the ruler until RMB/Esc clears or commits; release capture if we had it
  try { canvas.releasePointerCapture(e.pointerId); } catch {}
});

canvas.addEventListener('pointercancel', e=>{
  try { canvas.releasePointerCapture(e.pointerId); } catch {}
});

// Allow context menu unless we just handled a commit above
canvas.addEventListener('contextmenu', e=>{
  // If a ruler is active, let RMB commit handler above run and suppress menu; otherwise allow menu.
  if (state.measure) e.preventDefault();
});

  function flashSelected(){ const card=document.getElementById('selectedInfo'); card.classList.add('selected'); setTimeout(()=>card.classList.remove('selected'), 450); }

  function updateSelectedPanel(){
    const el=document.getElementById('selectedInfo'); const a=getSelected();
    if(!a){ state.editing = null; el.className='aircraftCard small'; el.innerHTML='Tap/click a tag to select; drag tags anywhere (works on mobile).'; return; }
    el.className='aircraftCard selected';
    const route = a.navMode==="DIRECT"&&a.directWptId ? ` • DIR ${env.getWaypoint(a.directWptId)?.name||""}` : "";
    el.innerHTML = `
  <div style="display:flex;align-items:center;justify-content:space-between;gap:8px;">
    <div><strong>${a.cs}</strong> — H${formatHeading(a.hdg)} • S${a.spd_kt|0} kt/M${a.mach.toFixed(2)} • ${formatAltitude(a.alt_ft)}${route}</div>
    <button class="btnSfp small" style="white-space:nowrap;">SFP</button>
  </div>
  <div class="small">Targets: H${formatHeading(a.tgtHdg)} • ${
  a.tgtSpeedMode==='MACH'
    ? ('M'+(a.tgtMach?.toFixed(2) ?? (a.tgtSpd_kt/isaSpeedOfSoundKts(a.alt_ft)).toFixed(2)))
    : ('S'+((a.tgtSpd_kt|0))+' kt')
} • ALT ${formatAltitude(a.tgtAlt)} • VS${fmtVS100(a.vs_fpm)} • SEC ${a.inSector?'IN':'OUT'}

`;
const sfpBtn = el.querySelector('.btnSfp');
if(sfpBtn){
  sfpBtn.addEventListener('click', ()=>{
    openSFP(a);
  });
  // If SFP window is open, refresh it for the new selection (or close if none)
const openWin = document.querySelector('.sfpWin');
if(openWin){
  const sel = getSelected();
  if(sel) renderSFP(sel); else closeSFP();
}

}

    altInput.value = useFL.checked ? Math.round(a.tgtAlt/100) : Math.round(a.tgtAlt);
    document.getElementById('hdg').value = Math.round(a.tgtHdg)||0;
    document.getElementById('spd').value = a.tgtSpeedMode==='KT' ? a.tgtSpd_kt|0 : "";
    document.getElementById('mach').value = a.tgtSpeedMode==='MACH'&&a.tgtMach ? a.tgtMach.toFixed(2) : "";
    document.getElementById('vs').value = a.vs_fpm ? (Math.abs(a.vs_fpm)|0) : "";
  }

  document.getElementById('spawn').addEventListener('click', spawnAircraft);
  document.getElementById('autoSpawnToggle').addEventListener('change', e=>{
  AutoSpawn.enabled = e.target.checked;
  if (AutoSpawn.enabled){
    armCooldown();      // start a fresh randomized gap
  } else {
    disarmCooldown();   // stop any pending spawn
  }
});


document.getElementById('spawnConflict').addEventListener('click', ()=>{
  spawnConflictPack();
});

  document.getElementById('clear').addEventListener('click', clearAll);
  document.getElementById('pause').addEventListener('click', e=>{
    state.paused=!state.paused; e.target.textContent=state.paused?"Resume":"Pause";
  });
  document.getElementById('rangeSel').addEventListener('change', e=>{ rangeNM=parseInt(e.target.value,10); drawAll(); });
  document.getElementById('simSpeed').addEventListener('change', e=>{ state.simSpeed=parseFloat(e.target.value); });
  document.getElementById('labelSize').addEventListener('change', e=>{
  document.body.classList.remove('label-sm','label-lg'); // medium = default (no class)
  if (e.target.value==='sm') document.body.classList.add('label-sm');
  else if (e.target.value==='lg') document.body.classList.add('label-lg');
});


  for(const id of ["pred1","pred3","pred5"]) document.getElementById(id).addEventListener('change', e=>{ state[id]=e.target.checked; drawAll(); });
  document.getElementById('predFor').addEventListener('change', e=>{ state.predFor=e.target.value; drawAll(); });

  document.getElementById('lookahead').addEventListener('change', e=>{ state.lookaheadMin=parseInt(e.target.value,10); drawAll(); });

  document.getElementById('btnFilter').addEventListener('click', ()=>{
    state.filterMin=parseInt(document.getElementById('fltMin').value,10)||0;
    state.filterMax=parseInt(document.getElementById('fltMax').value,10)||60000;
    drawAll();
  });

  document.getElementById('spd250').addEventListener('change', e=>{ env.restrict250=e.target.checked; });

  document.getElementById('addWpt').addEventListener('click', e=>{
    state.addingWpt=!state.addingWpt; e.target.textContent=state.addingWpt?"Click scope…":"Add waypoint";
  });
  document.getElementById('clearWpt').addEventListener('click', clearWaypoints);

  document.getElementById('autoHandoff').addEventListener('change', e=>{ env.autoHandoff=e.target.checked; });
  document.getElementById('btnHandoff').addEventListener('click', ()=>{
    const a=getSelected(); if(!a){ alert("Select a track first."); return; }
    if(a.handoffPending){ a.inSector=a.pendingState; a.handoffPending=false; a.pendingState=null; }
    updateSelectedPanel(); drawAll();
  });
  document.getElementById('btnRect').addEventListener('click', ()=>{
    env.rectW=Math.max(5,parseFloat(document.getElementById('rectW').value)||env.rectW);
    env.rectH=Math.max(5,parseFloat(document.getElementById('rectH').value)||env.rectH);
    drawAll();
  });

  // NEW: Measure tool UI button
  document.getElementById('clearRulers').addEventListener('click', ()=>{ state.measures.length=0; drawAll(); });

  // Commands
  document.getElementById('btnHdg').addEventListener('click', ()=>{
    const a=getSelected(); if(!a) return;
    let hdg=parseInt(document.getElementById('hdg').value,10);
    if(!Number.isFinite(hdg)) return;
    if(hdg===360) hdg=0;
    a.setHeading(mod360(hdg));
    updateSelectedPanel(); drawAll();
  });

  document.getElementById('btnAlt').addEventListener('click', ()=>{
  const a=getSelected(); if(!a) return;
  const altFt = parseAltitudeInput(document.getElementById('alt').value, useFL.checked);
  const vs = parseVsHundreds(document.getElementById('vs').value);
  if(altFt!=null) a.setAltitude(altFt, vs);
  updateSelectedPanel(); drawAll();
});


  document.getElementById('btnHold').addEventListener('click', ()=>{ const a=getSelected(); if(!a) return; a.holdAltitude(); updateSelectedPanel(); drawAll(); });
  document.getElementById('btnSpd').addEventListener('click', ()=>{
    const a=getSelected(); if(!a) return; const spd=parseInt(document.getElementById('spd').value,10);
    if(Number.isFinite(spd)) a.setSpeedKt(spd); updateSelectedPanel(); drawAll();
  });
  document.getElementById('btnMach').addEventListener('click', ()=>{
    const a=getSelected(); if(!a) return; const m=parseFloat(document.getElementById('mach').value);
    if(Number.isFinite(m)) a.setMach(m); updateSelectedPanel(); drawAll();
  });
// --- Enter-to-confirm + highlight which field is being edited ---
function bindEnterAndHighlight(inputId, btnId, labelField){
  const inp = document.getElementById(inputId);
  if (!inp) return;
  inp.addEventListener('keydown', e=>{
    if(e.key === 'Enter'){
      const btn = document.getElementById(btnId);
      if (btn) btn.click();
      inp.blur();
    }
  });
  inp.addEventListener('focus', ()=> setEditing(labelField));
  inp.addEventListener('blur',  ()=> clearEditing(labelField));
}

// Map inputs → buttons → which label span to highlight
bindEnterAndHighlight('hdg',  'btnHdg',  'hdg');
bindEnterAndHighlight('spd',  'btnSpd',  'spd');
bindEnterAndHighlight('mach', 'btnMach', 'mach');
bindEnterAndHighlight('alt',  'btnAlt',  'cfl'); // editing ALT highlights CFL
bindEnterAndHighlight('vs',   'btnAlt',  'vs');  // VS shares the ALT apply


  // Shortcuts
  window.addEventListener('keydown', e=>{
    if (e.key === 'Escape') {
      if (state.measure) { state.measure = null; drawCanvasOnly(); return; }
      if (state.measures.length) { state.measures.pop(); drawAll(); return; }
    }
    const a=getSelected();
    if(e.code==='Space'){ e.preventDefault(); state.paused=!state.paused; document.getElementById('pause').textContent=state.paused?"Resume":"Pause"; }
    else if(e.key==='N'||e.key==='n'){ spawnAircraft(); }
    else if(a){
      if(e.key==='H'||e.key==='h'){
        const v=prompt("Vector: heading (1–360)", Math.min(360,Math.max(1, Math.round(a.tgtHdg)||1)));
        if(v!==null){ let h=parseInt(v,10); if(h===360) h=0; if(Number.isFinite(h)) a.setHeading(mod360(h)); updateSelectedPanel(); drawAll(); }
      }else if(e.key==='A'||e.key==='a'){
  const hint = useFL.checked ? "FL (e.g. 120), optional VS×100 like 120,18" : "ft (e.g. 12000), optional VS×100 like 12000,18";
  const v=prompt("Altitude — "+hint, useFL.checked? String(Math.round(a.tgtAlt/100)) : String(Math.round(a.tgtAlt)));
  if(v!==null){
    const parts=v.toUpperCase().split(',');
    const altFt = parseAltitudeInput(parts[0], useFL.checked);
    const vs = parts[1]? parseVsHundreds(parts[1]) : null;
    if(altFt!=null) a.setAltitude(altFt, vs);
    updateSelectedPanel(); drawAll();
  }

      }else if(e.key==='S'||e.key==='s'){
        const v=prompt("Speed (kt)", a.tgtSpeedMode==='KT'?(a.tgtSpd_kt|0):"");
        if(v!==null && v.trim()!==""){ a.setSpeedKt(parseInt(v,10)); updateSelectedPanel(); drawAll(); }
      }else if(e.key==='M'||e.key==='m'){
        const v=prompt("Mach (e.g. 0.78)", a.tgtSpeedMode==='MACH'&&a.tgtMach?a.tgtMach.toFixed(2):"");
        if(v!==null && v.trim()!==""){ a.setMach(parseFloat(v)); updateSelectedPanel(); drawAll(); }
      }
    }
  });

// Start AFTER the page has laid out (canvas has real size)
window.addEventListener('load', () => {
  resize();            // compute sizes once
  renderWptList();
  seedWaypointsInside(15);   // tweak the number if you want more/less
  buildAirways(2);           // connect each fix to 2 nearest neighbors
  spawnAircraft();
  spawnAircraft();
  booted = true;       // now future resizes can redraw
  drawAll();
});
</script>
</body>
</html>
